
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Unmanaged.Native where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.Type
import Aten.Class

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/ATen.h>"

C.include "<torch/torch.h>"


_cudnn_init_dropout_state_dblo
  :: CDouble
  -> CBool
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_cudnn_init_dropout_state_dblo _dropout _train _dropout_seed _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::_cudnn_init_dropout_state(
    $(double _dropout)
  , $(bool _train)
  , $(int64_t _dropout_seed)
  , *$(at::TensorOptions* _options)));
  }|]

arange_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_so _end _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::arange(
    *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_sso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_sso _start _end _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_ssso _start _end _step _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

bartlett_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::bartlett_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

bartlett_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::bartlett_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

blackman_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::blackman_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

blackman_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::blackman_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

empty_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::empty(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_empty_affine_quantized_lodl
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
_empty_affine_quantized_lodl _size _options _scale _zero_point =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::_empty_affine_quantized(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)
  , $(double _scale)
  , $(int64_t _zero_point)));
  }|]

empty_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::empty_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

empty_strided_llo
  :: Ptr IntArray
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_strided_llo _size _stride _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::empty_strided(
    *$(std::vector<int64_t>* _size)
  , *$(std::vector<int64_t>* _stride)
  , *$(at::TensorOptions* _options)));
  }|]

eye_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
eye_lo _n _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::eye(
    $(int64_t _n)
  , *$(at::TensorOptions* _options)));
  }|]

eye_llo
  :: Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
eye_llo _n _m _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::eye(
    $(int64_t _n)
  , $(int64_t _m)
  , *$(at::TensorOptions* _options)));
  }|]

full_lso
  :: Ptr IntArray
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_lso _size _fill_value _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::full(
    *$(std::vector<int64_t>* _size)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)));
  }|]

full_like_tso
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_like_tso _self _fill_value _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::full_like(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)));
  }|]

from_file_sblo
  :: Ptr StdString
  -> CBool
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
from_file_sblo _filename _shared _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::from_file(
    *$(std::string* _filename)
  , $(bool _shared)
  , $(int64_t _size)
  , *$(at::TensorOptions* _options)));
  }|]

hann_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hann_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::hann_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

hann_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hann_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::hann_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lo _window_length _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::hamming_window(
    $(int64_t _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lbo
  :: Int64
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbo _window_length _periodic _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lbdo
  :: Int64
  -> CBool
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbdo _window_length _periodic _alpha _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , $(double _alpha)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_lbddo
  :: Int64
  -> CBool
  -> CDouble
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_lbddo _window_length _periodic _alpha _beta _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::hamming_window(
    $(int64_t _window_length)
  , $(bool _periodic)
  , $(double _alpha)
  , $(double _beta)
  , *$(at::TensorOptions* _options)));
  }|]

linspace_sslo
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
linspace_sslo _start _end _steps _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , *$(at::TensorOptions* _options)));
  }|]

logspace_ssldo
  :: Ptr Scalar
  -> Ptr Scalar
  -> Int64
  -> CDouble
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
logspace_ssldo _start _end _steps _base _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int64_t _steps)
  , $(double _base)
  , *$(at::TensorOptions* _options)));
  }|]

ones_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::ones(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

ones_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::ones_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

scalar_tensor_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
scalar_tensor_so _s _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::scalar_tensor(
    *$(at::Scalar* _s)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::rand(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lpo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lpo _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::rand(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

rand_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::rand_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

randint_llo
  :: Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_llo _high _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_llpo
  :: Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_llpo _high _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randint(
    $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_lllo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_lllo _low _high _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_lllpo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_lllpo _low _high _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randint(
    $(int64_t _low)
  , $(int64_t _high)
  , *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_like_tlo
  :: Ptr Tensor
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tlo _self _high _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)));
  }|]

randint_like_tllo
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tllo _self _low _high _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randint_like(
    *$(at::Tensor* _self)
  , $(int64_t _low)
  , $(int64_t _high)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randn(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lpo
  :: Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lpo _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randn(
    *$(std::vector<int64_t>* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randn_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randn_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_lo
  :: Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_lo _n _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randperm(
    $(int64_t _n)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_lpo
  :: Int64
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_lpo _n _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::randperm(
    $(int64_t _n)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

range_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
range_ssso _start _end _step _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

range_sso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
range_sso _start _end _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

zeros_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::zeros(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

zeros_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_like_to _self _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::zeros_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_lo
  :: Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_lo _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::sparse_coo_tensor(
    *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_tto
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_tto _indices _values _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_ttlo _indices _values _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_unsafe_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_unsafe_ttlo _indices _values _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::_sparse_coo_tensor_unsafe(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_with_dims_lllo
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_with_dims_lllo _sparse_dim _dense_dim _size _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::_sparse_coo_tensor_with_dims(
    $(int64_t _sparse_dim)
  , $(int64_t _dense_dim)
  , *$(std::vector<int64_t>* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_with_dims_and_tensors_llltto
  :: Int64
  -> Int64
  -> Ptr IntArray
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_with_dims_and_tensors_llltto _sparse_dim _dense_dim _size _indices _values _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::_sparse_coo_tensor_with_dims_and_tensors(
    $(int64_t _sparse_dim)
  , $(int64_t _dense_dim)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

tril_indices_lllo
  :: Int64
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
tril_indices_lllo _row _col _offset _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::tril_indices(
    $(int64_t _row)
  , $(int64_t _col)
  , $(int64_t _offset)
  , *$(at::TensorOptions* _options)));
  }|]

triu_indices_lllo
  :: Int64
  -> Int64
  -> Int64
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
triu_indices_lllo _row _col _offset _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(torch::triu_indices(
    $(int64_t _row)
  , $(int64_t _col)
  , $(int64_t _offset)
  , *$(at::TensorOptions* _options)));
  }|]

