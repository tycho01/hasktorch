
-- generated by using spec/native_functions_modified.yaml and deps/libtorch/include/ATen/NativeFunctions.h

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Aten.NativeFunctions.Common where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.NativeFunctions.Type

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"


_cast_Byte_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Byte_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Byte(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Char_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Char_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Char(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Double_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Double_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Double(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Float_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Float_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Float(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Int_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Int_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Int(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Long_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Long_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Long(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Short_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Short_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Short(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_cast_Half_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cast_Half_tb _self _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Half(
    *$(at::Tensor* _self)
  , $(bool _non_blocking)));
  }|]

_reshape_from_tensor_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_reshape_from_tensor_tt _self _shape =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_reshape_from_tensor(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _shape)));
  }|]

_shape_as_tensor_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_shape_as_tensor_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_shape_as_tensor(
    *$(at::Tensor* _self)));
  }|]

dropout_tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
dropout_tfb _input _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::native::dropout(
    *$(at::Tensor* _input)
  , $(float _p)
  , $(bool _train)));
  }|]

dropout__Tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
dropout__Tfb _self _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::native::dropout_(
    *$(at::Tensor* _self)
  , $(float _p)
  , $(bool _train)));
  }|]

feature_dropout_tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
feature_dropout_tfb _input _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::native::feature_dropout(
    *$(at::Tensor* _input)
  , $(float _p)
  , $(bool _train)));
  }|]

feature_dropout__Tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
feature_dropout__Tfb _self _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::native::feature_dropout_(
    *$(at::Tensor* _self)
  , $(float _p)
  , $(bool _train)));
  }|]

alpha_dropout_tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
alpha_dropout_tfb _input _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::native::alpha_dropout(
    *$(at::Tensor* _input)
  , $(float _p)
  , $(bool _train)));
  }|]

alpha_dropout__Tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
alpha_dropout__Tfb _self _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::native::alpha_dropout_(
    *$(at::Tensor* _self)
  , $(float _p)
  , $(bool _train)));
  }|]

feature_alpha_dropout_tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
feature_alpha_dropout_tfb _input _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::native::feature_alpha_dropout(
    *$(at::Tensor* _input)
  , $(float _p)
  , $(bool _train)));
  }|]

feature_alpha_dropout__Tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
feature_alpha_dropout__Tfb _self _p _train =
  [C.block| at::Tensor* { return new at::Tensor(at::native::feature_alpha_dropout_(
    *$(at::Tensor* _self)
  , $(float _p)
  , $(bool _train)));
  }|]

abs_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
abs_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::abs(
    *$(at::Tensor* _self)));
  }|]

acos_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
acos_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::acos(
    *$(at::Tensor* _self)));
  }|]

avg_pool1d_tlllbb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool1d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool1d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

adaptive_avg_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
adaptive_avg_pool1d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool1d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_max_pool1d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool1d_tl _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool1d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

add_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_tts _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::add(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add__Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add__Tts _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::add_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_out_Ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_out_Ttts _out _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::add_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_tss _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::add(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

add__Tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add__Tss _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::add_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

addmv_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_tttss _self _mat _vec _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addmv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv__Tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv__Tttss _self _mat _vec _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addmv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmv_out_Ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmv_out_Ttttss _out _self _mat _vec _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addmv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat)
  , *$(at::Tensor* _vec)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_tttss _self _vec1 _vec2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr__Tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr__Tttss _self _vec1 _vec2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addr_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addr_out_Ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addr_out_Ttttss _out _self _vec1 _vec2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec1)
  , *$(at::Tensor* _vec2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

affine_grid_generator_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
affine_grid_generator_tl _theta _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::affine_grid_generator(
    *$(at::Tensor* _theta)
  , *$(at::IntArrayRef* _size)));
  }|]

affine_grid_generator_backward_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
affine_grid_generator_backward_tl _grad _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::affine_grid_generator_backward(
    *$(at::Tensor* _grad)
  , *$(at::IntArrayRef* _size)));
  }|]

all_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
all_tib _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::all(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

all_out_Ttib
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
all_out_Ttib _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::all_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

allclose_ttffb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CFloat
  -> CBool
  -> IO (CBool)
allclose_ttffb _self _other _rtol _atol _equal_nan =
  [C.block| bool { return (at::native::allclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(float _rtol)
  , $(float _atol)
  , $(bool _equal_nan)));
  }|]

any_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
any_tib _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::any(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

any_out_Ttib
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
any_out_Ttib _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::any_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

arange_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_so _end _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::arange(
    *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_sso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_sso _start _end _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

arange_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
arange_ssso _start _end _step _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::arange(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

arange_out_Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_out_Ts _out _end =
  [C.block| at::Tensor* { return new at::Tensor(at::native::arange_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _end)));
  }|]

_dim_arange_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
_dim_arange_ti _like _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_dim_arange(
    *$(at::Tensor* _like)
  , $(int _dim)));
  }|]

argmax_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
argmax_tib _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::argmax(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

argmax_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argmax_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::argmax(
    *$(at::Tensor* _self)));
  }|]

_argmax_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
_argmax_tib _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_argmax(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

argmin_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
argmin_tib _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::argmin(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

argmin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argmin_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::argmin(
    *$(at::Tensor* _self)));
  }|]

_argmin_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
_argmin_tib _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_argmin(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

as_strided_tlli
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> IO (Ptr Tensor)
as_strided_tlli _self _size _stride _storage_offset =
  [C.block| at::Tensor* { return new at::Tensor(at::native::as_strided(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)
  , *$(at::IntArrayRef* _stride)
  , $(int _storage_offset)));
  }|]

as_strided__Tlli
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> IO (Ptr Tensor)
as_strided__Tlli _self _size _stride _storage_offset =
  [C.block| at::Tensor* { return new at::Tensor(at::native::as_strided_(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)
  , *$(at::IntArrayRef* _stride)
  , $(int _storage_offset)));
  }|]

asin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
asin_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::asin(
    *$(at::Tensor* _self)));
  }|]

atan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
atan_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::atan(
    *$(at::Tensor* _self)));
  }|]

_baddbmm_mkl__Tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_baddbmm_mkl__Tttss _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_baddbmm_mkl_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

bartlett_window_io
  :: CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_io _window_length _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bartlett_window(
    $(int _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

bartlett_window_ibo
  :: CInt
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
bartlett_window_ibo _window_length _periodic _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bartlett_window(
    $(int _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

batch_norm_tttttbffb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CFloat
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
batch_norm_tttttbffb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled =
  [C.block| at::Tensor* { return new at::Tensor(at::native::batch_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(float _momentum)
  , $(float _eps)
  , $(bool _cudnn_enabled)));
  }|]

_batch_norm_impl_index_tttttbffb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CFloat
  -> CFloat
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Int64))
_batch_norm_impl_index_tttttbffb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,int64_t>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,int64_t>(at::native::_batch_norm_impl_index(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(float _momentum)
  , $(float _eps)
  , $(bool _cudnn_enabled)));
  }|]

_batch_norm_impl_index_backward_ltttttttbfa
  :: Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CFloat
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
_batch_norm_impl_index_backward_ltttttttbfa _impl_index _input _grad_output _weight _running_mean _running_var _save_mean _save_var_transform _train _eps _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::_batch_norm_impl_index_backward(
    $(int64_t _impl_index)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_var_transform)
  , $(bool _train)
  , $(float _eps)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

bernoulli_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tp _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

bernoulli_out_Ttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_out_Ttp _out _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

bernoulli_tfp
  :: Ptr Tensor
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tfp _self _p _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli(
    *$(at::Tensor* _self)
  , $(float _p)
  , $(at::Generator * _generator)));
  }|]

bilinear_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bilinear_tttt _input1 _input2 _weight _bias =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bilinear(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

binary_cross_entropy_with_logits_tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_tttti _self _target _weight _pos_weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_with_logits(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)
  , $(int _reduction)));
  }|]

binary_cross_entropy_with_logits_backward_ttttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_ttttti _grad_output _self _target _weight _pos_weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_with_logits_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _pos_weight)
  , $(int _reduction)));
  }|]

blackman_window_io
  :: CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_io _window_length _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::blackman_window(
    $(int _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

blackman_window_ibo
  :: CInt
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
blackman_window_ibo _window_length _periodic _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::blackman_window(
    $(int _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

broadcast_tensors_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
broadcast_tensors_l _tensors =
  [C.block| at::TensorList* { return new at::TensorList(at::native::broadcast_tensors(
    *$(at::TensorList* _tensors)));
  }|]

cat_li
  :: Ptr TensorList
  -> CInt
  -> IO (Ptr Tensor)
cat_li _tensors _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cat(
    *$(at::TensorList* _tensors)
  , $(int _dim)));
  }|]

cat_out_Tli
  :: Ptr Tensor
  -> Ptr TensorList
  -> CInt
  -> IO (Ptr Tensor)
cat_out_Tli _out _tensors _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cat_out(
    *$(at::Tensor* _out)
  , *$(at::TensorList* _tensors)
  , $(int _dim)));
  }|]

ceil_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ceil_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ceil(
    *$(at::Tensor* _self)));
  }|]

chain_matmul_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
chain_matmul_l _matrices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::chain_matmul(
    *$(at::TensorList* _matrices)));
  }|]

chunk_tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
chunk_tii _self _chunks _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::chunk(
    *$(at::Tensor* _self)
  , $(int _chunks)
  , $(int _dim)));
  }|]

clamp_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_tss _self _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::native::clamp(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

clamp_max_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_max_ts _self _max =
  [C.block| at::Tensor* { return new at::Tensor(at::native::clamp_max(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

clamp_min_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
clamp_min_ts _self _min =
  [C.block| at::Tensor* { return new at::Tensor(at::native::clamp_min(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

cudnn_is_acceptable_t
  :: Ptr Tensor
  -> IO (CBool)
cudnn_is_acceptable_t _self =
  [C.block| bool { return (at::native::cudnn_is_acceptable(
    *$(at::Tensor* _self)));
  }|]

constant_pad_nd_tls
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr Scalar
  -> IO (Ptr Tensor)
constant_pad_nd_tls _self _pad _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::constant_pad_nd(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _pad)
  , *$(at::Scalar* _value)));
  }|]

contiguous_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
contiguous_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::contiguous(
    *$(at::Tensor* _self)));
  }|]

convolution_tttlllbli
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> Ptr IntList
  -> CInt
  -> IO (Ptr Tensor)
convolution_tttlllbli _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::native::convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _transposed)
  , *$(at::IntArrayRef* _output_padding)
  , $(int _groups)));
  }|]

_convolution_tttlllblibbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> Ptr IntList
  -> CInt
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
_convolution_tttlllblibbb _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _transposed)
  , *$(at::IntArrayRef* _output_padding)
  , $(int _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)));
  }|]

_convolution_nogroup_tttlllbl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> Ptr IntList
  -> IO (Ptr Tensor)
_convolution_nogroup_tttlllbl _input _weight _bias _stride _padding _dilation _transposed _output_padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_convolution_nogroup(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _transposed)
  , *$(at::IntArrayRef* _output_padding)));
  }|]

_convolution_double_backward_ttttttlllblibbba
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> Ptr IntList
  -> CInt
  -> CBool
  -> CBool
  -> CBool
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
_convolution_double_backward_ttttttlllblibbba _ggI _ggW _ggb _gO _weight _self _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::_convolution_double_backward(
    *$(at::Tensor* _ggI)
  , *$(at::Tensor* _ggW)
  , *$(at::Tensor* _ggb)
  , *$(at::Tensor* _gO)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _transposed)
  , *$(at::IntArrayRef* _output_padding)
  , $(int _groups)
  , $(bool _benchmark)
  , $(bool _deterministic)
  , $(bool _cudnn_enabled)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

conv1d_tttllli
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> IO (Ptr Tensor)
conv1d_tttllli _input _weight _bias _stride _padding _dilation _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::native::conv1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(int _groups)));
  }|]

conv2d_tttllli
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> IO (Ptr Tensor)
conv2d_tttllli _input _weight _bias _stride _padding _dilation _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::native::conv2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(int _groups)));
  }|]

conv3d_tttllli
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> IO (Ptr Tensor)
conv3d_tttllli _input _weight _bias _stride _padding _dilation _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::native::conv3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(int _groups)));
  }|]

conv_tbc_ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
conv_tbc_ttti _self _weight _bias _pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::conv_tbc(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(int _pad)));
  }|]

conv_tbc_backward_tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr (Tensor,Tensor,Tensor))
conv_tbc_backward_tttti _self _input _weight _bias _pad =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::conv_tbc_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(int _pad)));
  }|]

conv_transpose1d_tttlllil
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> Ptr IntList
  -> IO (Ptr Tensor)
conv_transpose1d_tttlllil _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::conv_transpose1d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , $(int _groups)
  , *$(at::IntArrayRef* _dilation)));
  }|]

conv_transpose2d_tttlllil
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> Ptr IntList
  -> IO (Ptr Tensor)
conv_transpose2d_tttlllil _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::conv_transpose2d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , $(int _groups)
  , *$(at::IntArrayRef* _dilation)));
  }|]

conv_transpose3d_tttlllil
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> Ptr IntList
  -> IO (Ptr Tensor)
conv_transpose3d_tttlllil _input _weight _bias _stride _padding _output_padding _groups _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::conv_transpose3d(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , $(int _groups)
  , *$(at::IntArrayRef* _dilation)));
  }|]

cos_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cos_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cos(
    *$(at::Tensor* _self)));
  }|]

cosh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
cosh_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cosh(
    *$(at::Tensor* _self)));
  }|]

cosine_embedding_loss_tttfi
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CInt
  -> IO (Ptr Tensor)
cosine_embedding_loss_tttfi _input1 _input2 _target _margin _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cosine_embedding_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(float _margin)
  , $(int _reduction)));
  }|]

cumsum_tis
  :: Ptr Tensor
  -> CInt
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
cumsum_tis _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cumsum(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

cumsum_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
cumsum_ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cumsum(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

cumsum_out_Ttis
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
cumsum_out_Ttis _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

cumsum_out_Tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
cumsum_out_Tti _out _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cumsum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

cumprod_tis
  :: Ptr Tensor
  -> CInt
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
cumprod_tis _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cumprod(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

cumprod_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
cumprod_ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cumprod(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

cumprod_out_Ttis
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
cumprod_out_Ttis _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

cumprod_out_Tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
cumprod_out_Tti _out _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cumprod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

ctc_loss_ttlliib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
ctc_loss_ttlliib _log_probs _targets _input_lengths _target_lengths _blank _reduction _zero_infinity =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::IntArrayRef* _input_lengths)
  , *$(at::IntArrayRef* _target_lengths)
  , $(int _blank)
  , $(int _reduction)
  , $(bool _zero_infinity)));
  }|]

ctc_loss_ttttiib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
ctc_loss_ttttiib _log_probs _targets _input_lengths _target_lengths _blank _reduction _zero_infinity =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ctc_loss(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::Tensor* _input_lengths)
  , *$(at::Tensor* _target_lengths)
  , $(int _blank)
  , $(int _reduction)
  , $(bool _zero_infinity)));
  }|]

det_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
det_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::det(
    *$(at::Tensor* _self)));
  }|]

diag_embed_tiii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
diag_embed_tiii _self _offset _dim1 _dim2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::diag_embed(
    *$(at::Tensor* _self)
  , $(int _offset)
  , $(int _dim1)
  , $(int _dim2)));
  }|]

diagflat_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
diagflat_ti _self _offset =
  [C.block| at::Tensor* { return new at::Tensor(at::native::diagflat(
    *$(at::Tensor* _self)
  , $(int _offset)));
  }|]

diagonal_tiii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
diagonal_tiii _self _offset _dim1 _dim2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::diagonal(
    *$(at::Tensor* _self)
  , $(int _offset)
  , $(int _dim1)
  , $(int _dim2)));
  }|]

div_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
div_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

div__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
div__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::div_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

div_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
div_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::div_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

div_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
div_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::div(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

div__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
div__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::div_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

dot_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
dot_tt _self _tensor =
  [C.block| at::Tensor* { return new at::Tensor(at::native::dot(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor)));
  }|]

dot_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
dot_out_Ttt _out _self _tensor =
  [C.block| at::Tensor* { return new at::Tensor(at::native::dot_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor)));
  }|]

einsum_sl
  :: Ptr StdString
  -> Ptr TensorList
  -> IO (Ptr Tensor)
einsum_sl _equation _tensors =
  [C.block| at::Tensor* { return new at::Tensor(at::native::einsum(
    *$(std::string* _equation)
  , *$(at::TensorList* _tensors)));
  }|]

embedding_ttibb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
embedding_ttibb _weight _indices _padding_idx _scale_grad_by_freq _sparse =
  [C.block| at::Tensor* { return new at::Tensor(at::native::embedding(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , $(int _padding_idx)
  , $(bool _scale_grad_by_freq)
  , $(bool _sparse)));
  }|]

embedding_backward_ttiibb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
embedding_backward_ttiibb _grad _indices _num_weights _padding_idx _scale_grad_by_freq _sparse =
  [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , $(int _num_weights)
  , $(int _padding_idx)
  , $(bool _scale_grad_by_freq)
  , $(bool _sparse)));
  }|]

embedding_sparse_backward_ttiib
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
embedding_sparse_backward_ttiib _grad _indices _num_weights _padding_idx _scale_grad_by_freq =
  [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_sparse_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , $(int _num_weights)
  , $(int _padding_idx)
  , $(bool _scale_grad_by_freq)));
  }|]

embedding_bag_tttbib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Tensor))
embedding_bag_tttbib _weight _indices _offsets _scale_grad_by_freq _mode _sparse =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::native::embedding_bag(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int _mode)
  , $(bool _sparse)));
  }|]

_embedding_bag_backward_ttttttibib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
_embedding_bag_backward_ttttttibib _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode _sparse =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_embedding_bag_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , *$(at::Tensor* _maximum_indices)
  , $(int _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int _mode)
  , $(bool _sparse)));
  }|]

_embedding_bag_sparse_backward_tttttibi
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> CInt
  -> IO (Ptr Tensor)
_embedding_bag_sparse_backward_tttttibi _grad _indices _offsets _offset2bag _bag_size _num_weights _scale_grad_by_freq _mode =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_embedding_bag_sparse_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , $(int _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int _mode)));
  }|]

empty_out_Tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
empty_out_Tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::empty_out(
    *$(at::Tensor* _out)
  , *$(at::IntArrayRef* _size)));
  }|]

empty_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
empty_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::empty_like(
    *$(at::Tensor* _self)));
  }|]

empty_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::empty_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

erf_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erf_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::erf(
    *$(at::Tensor* _self)));
  }|]

erfc_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfc_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::erfc(
    *$(at::Tensor* _self)));
  }|]

exp_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
exp_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::exp(
    *$(at::Tensor* _self)));
  }|]

expm1_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
expm1_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::expm1(
    *$(at::Tensor* _self)));
  }|]

expand_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
expand_tlb _self _size _implicit =
  [C.block| at::Tensor* { return new at::Tensor(at::native::expand(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)
  , $(bool _implicit)));
  }|]

expand_as_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
expand_as_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::expand_as(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

eye_io
  :: CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
eye_io _n _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eye(
    $(int _n)
  , *$(at::TensorOptions* _options)));
  }|]

eye_iio
  :: CInt
  -> CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
eye_iio _n _m _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eye(
    $(int _n)
  , $(int _m)
  , *$(at::TensorOptions* _options)));
  }|]

flatten_tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
flatten_tii _self _start_dim _end_dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::flatten(
    *$(at::Tensor* _self)
  , $(int _start_dim)
  , $(int _end_dim)));
  }|]

fill__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fill__Ts _self _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fill_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _value)));
  }|]

fill__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fill__Tt _self _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fill_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _value)));
  }|]

floor_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
floor_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::floor(
    *$(at::Tensor* _self)));
  }|]

full_lso
  :: Ptr IntList
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_lso _size _fill_value _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::full(
    *$(at::IntArrayRef* _size)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)));
  }|]

full_out_Tls
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr Scalar
  -> IO (Ptr Tensor)
full_out_Tls _out _size _fill_value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::full_out(
    *$(at::Tensor* _out)
  , *$(at::IntArrayRef* _size)
  , *$(at::Scalar* _fill_value)));
  }|]

full_like_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
full_like_ts _self _fill_value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::full_like(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _fill_value)));
  }|]

full_like_tso
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
full_like_tso _self _fill_value _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::full_like(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _fill_value)
  , *$(at::TensorOptions* _options)));
  }|]

grid_sampler_ttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
grid_sampler_ttii _input _grid _interpolation_mode _padding_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::native::grid_sampler(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int _interpolation_mode)
  , $(int _padding_mode)));
  }|]

hann_window_io
  :: CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hann_window_io _window_length _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hann_window(
    $(int _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

hann_window_ibo
  :: CInt
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hann_window_ibo _window_length _periodic _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hann_window(
    $(int _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_io
  :: CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_io _window_length _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hamming_window(
    $(int _window_length)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_ibo
  :: CInt
  -> CBool
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_ibo _window_length _periodic _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hamming_window(
    $(int _window_length)
  , $(bool _periodic)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_ibfo
  :: CInt
  -> CBool
  -> CFloat
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_ibfo _window_length _periodic _alpha _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hamming_window(
    $(int _window_length)
  , $(bool _periodic)
  , $(float _alpha)
  , *$(at::TensorOptions* _options)));
  }|]

hamming_window_ibffo
  :: CInt
  -> CBool
  -> CFloat
  -> CFloat
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
hamming_window_ibffo _window_length _periodic _alpha _beta _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hamming_window(
    $(int _window_length)
  , $(bool _periodic)
  , $(float _alpha)
  , $(float _beta)
  , *$(at::TensorOptions* _options)));
  }|]

hinge_embedding_loss_ttfi
  :: Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CInt
  -> IO (Ptr Tensor)
hinge_embedding_loss_ttfi _self _target _margin _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hinge_embedding_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(float _margin)
  , $(int _reduction)));
  }|]

ger_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ger_tt _self _vec2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ger(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec2)));
  }|]

ger_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ger_out_Ttt _out _self _vec2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ger_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec2)));
  }|]

gesv_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
gesv_tt _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gesv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

gesv_out_TTtt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
gesv_out_TTtt _solution _lu _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gesv_out(
    *$(at::Tensor* _solution)
  , *$(at::Tensor* _lu)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

group_norm_tittfb
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
group_norm_tittfb _input _num_groups _weight _bias _eps _cudnn_enabled =
  [C.block| at::Tensor* { return new at::Tensor(at::native::group_norm(
    *$(at::Tensor* _input)
  , $(int _num_groups)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(float _eps)
  , $(bool _cudnn_enabled)));
  }|]

fft_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
fft_tib _self _signal_ndim _normalized =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fft(
    *$(at::Tensor* _self)
  , $(int _signal_ndim)
  , $(bool _normalized)));
  }|]

ifft_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
ifft_tib _self _signal_ndim _normalized =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ifft(
    *$(at::Tensor* _self)
  , $(int _signal_ndim)
  , $(bool _normalized)));
  }|]

rfft_tibb
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
rfft_tibb _self _signal_ndim _normalized _onesided =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rfft(
    *$(at::Tensor* _self)
  , $(int _signal_ndim)
  , $(bool _normalized)
  , $(bool _onesided)));
  }|]

irfft_tibbl
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> CBool
  -> Ptr IntList
  -> IO (Ptr Tensor)
irfft_tibbl _self _signal_ndim _normalized _onesided _signal_sizes =
  [C.block| at::Tensor* { return new at::Tensor(at::native::irfft(
    *$(at::Tensor* _self)
  , $(int _signal_ndim)
  , $(bool _normalized)
  , $(bool _onesided)
  , *$(at::IntArrayRef* _signal_sizes)));
  }|]

_cufft_get_plan_cache_size_
  :: IO (CInt)
_cufft_get_plan_cache_size_  =
  [C.block| int { return (at::native::_cufft_get_plan_cache_size(
    ));
  }|]

_cufft_get_plan_cache_max_size_
  :: IO (CInt)
_cufft_get_plan_cache_max_size_  =
  [C.block| int { return (at::native::_cufft_get_plan_cache_max_size(
    ));
  }|]

_cufft_set_plan_cache_max_size_i
  :: CInt
  -> IO ()
_cufft_set_plan_cache_max_size_i _max_size =
  [C.block| void {  (at::native::_cufft_set_plan_cache_max_size(
    $(int _max_size)));
  }|]

_cufft_clear_plan_cache_
  :: IO ()
_cufft_clear_plan_cache_  =
  [C.block| void {  (at::native::_cufft_clear_plan_cache(
    ));
  }|]

index_tl
  :: Ptr Tensor
  -> Ptr TensorList
  -> IO (Ptr Tensor)
index_tl _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index(
    *$(at::Tensor* _self)
  , *$(at::TensorList* _indices)));
  }|]

index_copy__Titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_copy__Titt _self _dim _index _source =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_copy_(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_copy_titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_copy_titt _self _dim _index _source =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_copy(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_put__Tltb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
index_put__Tltb _self _indices _values _accumulate =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_put_(
    *$(at::Tensor* _self)
  , *$(at::TensorList* _indices)
  , *$(at::Tensor* _values)
  , $(bool _accumulate)));
  }|]

index_put_tltb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
index_put_tltb _self _indices _values _accumulate =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_put(
    *$(at::Tensor* _self)
  , *$(at::TensorList* _indices)
  , *$(at::Tensor* _values)
  , $(bool _accumulate)));
  }|]

instance_norm_tttttbffb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CFloat
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
instance_norm_tttttbffb _input _weight _bias _running_mean _running_var _use_input_stats _momentum _eps _cudnn_enabled =
  [C.block| at::Tensor* { return new at::Tensor(at::native::instance_norm(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _use_input_stats)
  , $(float _momentum)
  , $(float _eps)
  , $(bool _cudnn_enabled)));
  }|]

inverse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
inverse_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::inverse(
    *$(at::Tensor* _self)));
  }|]

inverse_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
inverse_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::inverse_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

isclose_ttffb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
isclose_ttffb _self _other _rtol _atol _equal_nan =
  [C.block| at::Tensor* { return new at::Tensor(at::native::isclose(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(float _rtol)
  , $(float _atol)
  , $(bool _equal_nan)));
  }|]

isnan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
isnan_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::isnan(
    *$(at::Tensor* _self)));
  }|]

is_distributed_t
  :: Ptr Tensor
  -> IO (CBool)
is_distributed_t _self =
  [C.block| bool { return (at::native::is_distributed(
    *$(at::Tensor* _self)));
  }|]

is_floating_point_t
  :: Ptr Tensor
  -> IO (CBool)
is_floating_point_t _self =
  [C.block| bool { return (at::native::is_floating_point(
    *$(at::Tensor* _self)));
  }|]

is_complex_t
  :: Ptr Tensor
  -> IO (CBool)
is_complex_t _self =
  [C.block| bool { return (at::native::is_complex(
    *$(at::Tensor* _self)));
  }|]

is_nonzero_t
  :: Ptr Tensor
  -> IO (CBool)
is_nonzero_t _self =
  [C.block| bool { return (at::native::is_nonzero(
    *$(at::Tensor* _self)));
  }|]

is_same_size_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
is_same_size_tt _self _other =
  [C.block| bool { return (at::native::is_same_size(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

is_signed_t
  :: Ptr Tensor
  -> IO (CBool)
is_signed_t _self =
  [C.block| bool { return (at::native::is_signed(
    *$(at::Tensor* _self)));
  }|]

kl_div_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
kl_div_tti _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::kl_div(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

kthvalue_tiib
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
kthvalue_tiib _self _k _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::kthvalue(
    *$(at::Tensor* _self)
  , $(int _k)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

kthvalue_out_TTtiib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
kthvalue_out_TTtiib _values _indices _self _k _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::kthvalue_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int _k)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

layer_norm_tlttfb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
layer_norm_tlttfb _input _normalized_shape _weight _bias _eps _cudnn_enable =
  [C.block| at::Tensor* { return new at::Tensor(at::native::layer_norm(
    *$(at::Tensor* _input)
  , *$(at::IntArrayRef* _normalized_shape)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , $(float _eps)
  , $(bool _cudnn_enable)));
  }|]

linear_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
linear_ttt _input _weight _bias =
  [C.block| at::Tensor* { return new at::Tensor(at::native::linear(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_int8_weight_ttttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fbgemm_linear_int8_weight_ttttsst _input _weight _packed _col_offsets _weight_scale _weight_zero_point _bias =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fbgemm_linear_int8_weight(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _packed)
  , *$(at::Tensor* _col_offsets)
  , *$(at::Scalar* _weight_scale)
  , *$(at::Scalar* _weight_zero_point)
  , *$(at::Tensor* _bias)));
  }|]

fbgemm_linear_quantize_weight_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,CFloat,CInt))
fbgemm_linear_quantize_weight_t _input =
  [C.block| std::tuple<at::Tensor,at::Tensor,float,int>* { return new std::tuple<at::Tensor,at::Tensor,float,int>(at::native::fbgemm_linear_quantize_weight(
    *$(at::Tensor* _input)));
  }|]

fbgemm_pack_quantized_matrix_tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
fbgemm_pack_quantized_matrix_tii _input _K _N =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fbgemm_pack_quantized_matrix(
    *$(at::Tensor* _input)
  , $(int _K)
  , $(int _N)));
  }|]

fbgemm_is_cpu_supported_
  :: IO (CBool)
fbgemm_is_cpu_supported_  =
  [C.block| bool { return (at::native::fbgemm_is_cpu_supported(
    ));
  }|]

linspace_ssio
  :: Ptr Scalar
  -> Ptr Scalar
  -> CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
linspace_ssio _start _end _steps _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::linspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int _steps)
  , *$(at::TensorOptions* _options)));
  }|]

log_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log(
    *$(at::Tensor* _self)));
  }|]

log10_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log10_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log10(
    *$(at::Tensor* _self)));
  }|]

log1p_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log1p_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log1p(
    *$(at::Tensor* _self)));
  }|]

log2_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log2_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log2(
    *$(at::Tensor* _self)));
  }|]

logdet_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
logdet_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::logdet(
    *$(at::Tensor* _self)));
  }|]

logspace_ssio
  :: Ptr Scalar
  -> Ptr Scalar
  -> CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
logspace_ssio _start _end _steps _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::logspace(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int _steps)
  , *$(at::TensorOptions* _options)));
  }|]

log_softmax_tis
  :: Ptr Tensor
  -> CInt
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
log_softmax_tis _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

log_softmax_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
log_softmax_ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

logsumexp_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::logsumexp(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

logsumexp_out_Ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
logsumexp_out_Ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::logsumexp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

margin_ranking_loss_tttfi
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CInt
  -> IO (Ptr Tensor)
margin_ranking_loss_tttfi _input1 _input2 _target _margin _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::margin_ranking_loss(
    *$(at::Tensor* _input1)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _target)
  , $(float _margin)
  , $(int _reduction)));
  }|]

matmul_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
matmul_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::matmul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

matmul_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
matmul_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::matmul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

matrix_rank_tfb
  :: Ptr Tensor
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
matrix_rank_tfb _self _tol _symmetric =
  [C.block| at::Tensor* { return new at::Tensor(at::native::matrix_rank(
    *$(at::Tensor* _self)
  , $(float _tol)
  , $(bool _symmetric)));
  }|]

matrix_rank_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
matrix_rank_tb _self _symmetric =
  [C.block| at::Tensor* { return new at::Tensor(at::native::matrix_rank(
    *$(at::Tensor* _self)
  , $(bool _symmetric)));
  }|]

matrix_power_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
matrix_power_ti _self _n =
  [C.block| at::Tensor* { return new at::Tensor(at::native::matrix_power(
    *$(at::Tensor* _self)
  , $(int _n)));
  }|]

max_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_tlb _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

max_out_TTtlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_out_TTtlb _max _max_values _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_out(
    *$(at::Tensor* _max)
  , *$(at::Tensor* _max_values)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

max_values_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
max_values_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_values(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

max_pool1d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool1d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool1d_with_indices(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool1d_tllllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
max_pool1d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool1d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_tllllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
max_pool2d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool2d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_tllllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
max_pool3d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool3d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)));
  }|]

mean_ts
  :: Ptr Tensor
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
mean_ts _self _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mean(
    *$(at::Tensor* _self)
  , *$(at::ScalarType* _dtype)));
  }|]

mean_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
mean_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mean(
    *$(at::Tensor* _self)));
  }|]

mean_tlbs
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
mean_tlbs _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mean(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)
  , *$(at::ScalarType* _dtype)));
  }|]

mean_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
mean_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mean(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

mean_tls
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
mean_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mean(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

mean_out_Ttlbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
mean_out_Ttlbs _out _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)
  , *$(at::ScalarType* _dtype)));
  }|]

mean_out_Ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
mean_out_Ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

mean_out_Ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
mean_out_Ttls _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mean_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

median_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
median_tib _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::median(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

median_out_TTtib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
median_out_TTtib _values _indices _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::median_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

min_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
min_tib _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::min(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

min_out_TTtib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
min_out_TTtib _min _min_indices _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::min_out(
    *$(at::Tensor* _min)
  , *$(at::Tensor* _min_indices)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

min_values_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
min_values_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::min_values(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

mkldnn_convolution_tttllli
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> IO (Ptr Tensor)
mkldnn_convolution_tttllli _self _weight _bias _padding _stride _dilation _groups =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mkldnn_convolution(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _dilation)
  , $(int _groups)));
  }|]

mkldnn_convolution_backward_input_lttlllib
  :: Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
mkldnn_convolution_backward_input_lttlllib _self_size _grad_output _weight _padding _stride _dilation _groups _bias_defined =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mkldnn_convolution_backward_input(
    *$(at::IntArrayRef* _self_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _dilation)
  , $(int _groups)
  , $(bool _bias_defined)));
  }|]

mkldnn_convolution_backward_weights_lttlllib
  :: Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
mkldnn_convolution_backward_weights_lttlllib _weight_size _grad_output _self _padding _stride _dilation _groups _bias_defined =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::mkldnn_convolution_backward_weights(
    *$(at::IntArrayRef* _weight_size)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _dilation)
  , $(int _groups)
  , $(bool _bias_defined)));
  }|]

mkldnn_convolution_backward_tttlllia
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
mkldnn_convolution_backward_tttlllia _self _grad_output _weight _padding _stride _dilation _groups _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::mkldnn_convolution_backward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _dilation)
  , $(int _groups)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

mm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mm_tt _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

mm_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mm_out_Ttt _out _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

_sparse_mm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_mm_tt _sparse _dense =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_mm(
    *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)));
  }|]

mode_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
mode_tib _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::mode(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

mode_out_TTtib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
mode_out_TTtib _values _indices _self _dim _keepdim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::mode_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

mul_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mul_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
mul_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mul(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

mul__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
mul__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mul_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

mv_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mv_tt _self _vec =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _vec)));
  }|]

mv_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mv_out_Ttt _out _self _vec =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _vec)));
  }|]

mvlgamma_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
mvlgamma_ti _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mvlgamma(
    *$(at::Tensor* _self)
  , $(int _p)));
  }|]

mvlgamma__Ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
mvlgamma__Ti _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mvlgamma_(
    *$(at::Tensor* _self)
  , $(int _p)));
  }|]

narrow_tiii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
narrow_tiii _self _dim _start _length =
  [C.block| at::Tensor* { return new at::Tensor(at::native::narrow(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(int _start)
  , $(int _length)));
  }|]

_nnpack_available_
  :: IO (CBool)
_nnpack_available_  =
  [C.block| bool { return (at::native::_nnpack_available(
    ));
  }|]

_nnpack_spatial_convolution_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_tttl _input _weight _bias _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_nnpack_spatial_convolution(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _padding)));
  }|]

_nnpack_spatial_convolution_backward_tttla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
_nnpack_spatial_convolution_backward_tttla _input _grad_output _weight _padding _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::_nnpack_spatial_convolution_backward(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _padding)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

_nnpack_spatial_convolution_backward_input_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_backward_input_tttl _input _grad_output _weight _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_nnpack_spatial_convolution_backward_input(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _padding)));
  }|]

_nnpack_spatial_convolution_backward_weight_tltl
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
_nnpack_spatial_convolution_backward_weight_tltl _input _weightsize _grad_output _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_nnpack_spatial_convolution_backward_weight(
    *$(at::Tensor* _input)
  , *$(at::IntArrayRef* _weightsize)
  , *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _padding)));
  }|]

ones_lo
  :: Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ones(
    *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

ones_out_Tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
ones_out_Tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ones_out(
    *$(at::Tensor* _out)
  , *$(at::IntArrayRef* _size)));
  }|]

ones_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
ones_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ones_like(
    *$(at::Tensor* _self)));
  }|]

ones_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
ones_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ones_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

pairwise_distance_ttffb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CFloat
  -> CBool
  -> IO (Ptr Tensor)
pairwise_distance_ttffb _x1 _x2 _p _eps _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pairwise_distance(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(float _p)
  , $(float _eps)
  , $(bool _keepdim)));
  }|]

cdist_ttf
  :: Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> IO (Ptr Tensor)
cdist_ttf _x1 _x2 _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cdist(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(float _p)));
  }|]

pdist_tf
  :: Ptr Tensor
  -> CFloat
  -> IO (Ptr Tensor)
pdist_tf _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pdist(
    *$(at::Tensor* _self)
  , $(float _p)));
  }|]

_pdist_forward_tf
  :: Ptr Tensor
  -> CFloat
  -> IO (Ptr Tensor)
_pdist_forward_tf _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_pdist_forward(
    *$(at::Tensor* _self)
  , $(float _p)));
  }|]

_pdist_backward_ttft
  :: Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_pdist_backward_ttft _grad _self _p _pdist =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_pdist_backward(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , $(float _p)
  , *$(at::Tensor* _pdist)));
  }|]

cosine_similarity_ttif
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CFloat
  -> IO (Ptr Tensor)
cosine_similarity_ttif _x1 _x2 _dim _eps =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cosine_similarity(
    *$(at::Tensor* _x1)
  , *$(at::Tensor* _x2)
  , $(int _dim)
  , $(float _eps)));
  }|]

permute_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
permute_tl _self _dims =
  [C.block| at::Tensor* { return new at::Tensor(at::native::permute(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dims)));
  }|]

pixel_shuffle_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
pixel_shuffle_ti _self _upscale_factor =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pixel_shuffle(
    *$(at::Tensor* _self)
  , $(int _upscale_factor)));
  }|]

pin_memory_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
pin_memory_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pin_memory(
    *$(at::Tensor* _self)));
  }|]

pinverse_tf
  :: Ptr Tensor
  -> CFloat
  -> IO (Ptr Tensor)
pinverse_tf _self _rcond =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pinverse(
    *$(at::Tensor* _self)
  , $(float _rcond)));
  }|]

scalar_tensor_so
  :: Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
scalar_tensor_so _s _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::scalar_tensor(
    *$(at::Scalar* _s)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lo
  :: Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rand(
    *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

rand_lpo
  :: Ptr IntList
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_lpo _size _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rand(
    *$(at::IntArrayRef* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

rand_out_Tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
rand_out_Tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rand_out(
    *$(at::Tensor* _out)
  , *$(at::IntArrayRef* _size)));
  }|]

rand_out_Tlp
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr Generator
  -> IO (Ptr Tensor)
rand_out_Tlp _out _size _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rand_out(
    *$(at::Tensor* _out)
  , *$(at::IntArrayRef* _size)
  , $(at::Generator * _generator)));
  }|]

rand_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rand_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rand_like(
    *$(at::Tensor* _self)));
  }|]

rand_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
rand_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rand_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

randint_ilo
  :: CInt
  -> Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_ilo _high _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint(
    $(int _high)
  , *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_ilpo
  :: CInt
  -> Ptr IntList
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_ilpo _high _size _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint(
    $(int _high)
  , *$(at::IntArrayRef* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_iilo
  :: CInt
  -> CInt
  -> Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_iilo _low _high _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint(
    $(int _low)
  , $(int _high)
  , *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randint_iilpo
  :: CInt
  -> CInt
  -> Ptr IntList
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_iilpo _low _high _size _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint(
    $(int _low)
  , $(int _high)
  , *$(at::IntArrayRef* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randint_out_Til
  :: Ptr Tensor
  -> CInt
  -> Ptr IntList
  -> IO (Ptr Tensor)
randint_out_Til _out _high _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint_out(
    *$(at::Tensor* _out)
  , $(int _high)
  , *$(at::IntArrayRef* _size)));
  }|]

randint_out_Tilp
  :: Ptr Tensor
  -> CInt
  -> Ptr IntList
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_out_Tilp _out _high _size _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint_out(
    *$(at::Tensor* _out)
  , $(int _high)
  , *$(at::IntArrayRef* _size)
  , $(at::Generator * _generator)));
  }|]

randint_out_Tiil
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> Ptr IntList
  -> IO (Ptr Tensor)
randint_out_Tiil _out _low _high _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint_out(
    *$(at::Tensor* _out)
  , $(int _low)
  , $(int _high)
  , *$(at::IntArrayRef* _size)));
  }|]

randint_out_Tiilp
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> Ptr IntList
  -> Ptr Generator
  -> IO (Ptr Tensor)
randint_out_Tiilp _out _low _high _size _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint_out(
    *$(at::Tensor* _out)
  , $(int _low)
  , $(int _high)
  , *$(at::IntArrayRef* _size)
  , $(at::Generator * _generator)));
  }|]

randint_like_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
randint_like_ti _self _high =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint_like(
    *$(at::Tensor* _self)
  , $(int _high)));
  }|]

randint_like_tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
randint_like_tii _self _low _high =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint_like(
    *$(at::Tensor* _self)
  , $(int _low)
  , $(int _high)));
  }|]

randint_like_tio
  :: Ptr Tensor
  -> CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tio _self _high _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint_like(
    *$(at::Tensor* _self)
  , $(int _high)
  , *$(at::TensorOptions* _options)));
  }|]

randint_like_tiio
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randint_like_tiio _self _low _high _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randint_like(
    *$(at::Tensor* _self)
  , $(int _low)
  , $(int _high)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lo
  :: Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randn(
    *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

randn_lpo
  :: Ptr IntList
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_lpo _size _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randn(
    *$(at::IntArrayRef* _size)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randn_out_Tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
randn_out_Tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randn_out(
    *$(at::Tensor* _out)
  , *$(at::IntArrayRef* _size)));
  }|]

randn_out_Tlp
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr Generator
  -> IO (Ptr Tensor)
randn_out_Tlp _out _size _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randn_out(
    *$(at::Tensor* _out)
  , *$(at::IntArrayRef* _size)
  , $(at::Generator * _generator)));
  }|]

randn_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
randn_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randn_like(
    *$(at::Tensor* _self)));
  }|]

randn_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randn_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randn_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_io
  :: CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_io _n _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randperm(
    $(int _n)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_ipo
  :: CInt
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
randperm_ipo _n _generator _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randperm(
    $(int _n)
  , $(at::Generator * _generator)
  , *$(at::TensorOptions* _options)));
  }|]

randperm_out_Ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
randperm_out_Ti _out _n =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randperm_out(
    *$(at::Tensor* _out)
  , $(int _n)));
  }|]

range_ssso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
range_ssso _start _end _step _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)
  , *$(at::TensorOptions* _options)));
  }|]

range_sso
  :: Ptr Scalar
  -> Ptr Scalar
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
range_sso _start _end _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::range(
    *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::TensorOptions* _options)));
  }|]

repeat_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
repeat_tl _self _repeats =
  [C.block| at::Tensor* { return new at::Tensor(at::native::repeat(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _repeats)));
  }|]

reshape_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reshape_tl _self _shape =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reshape(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _shape)));
  }|]

reshape_as_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
reshape_as_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reshape_as(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

round_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
round_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::round(
    *$(at::Tensor* _self)));
  }|]

rrelu_tssbp
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_tssbp _self _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu__Tssbp
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu__Tssbp _self _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

relu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
relu_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::relu(
    *$(at::Tensor* _self)));
  }|]

relu__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
relu__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::relu_(
    *$(at::Tensor* _self)));
  }|]

rsqrt_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
rsqrt_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rsqrt(
    *$(at::Tensor* _self)));
  }|]

select_tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
select_tii _self _dim _index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::select(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(int _index)));
  }|]

selu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
selu_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::selu(
    *$(at::Tensor* _self)));
  }|]

selu__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
selu__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::selu_(
    *$(at::Tensor* _self)));
  }|]

celu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
celu_ts _self _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::celu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

celu__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
celu__Ts _self _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::celu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

sigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sigmoid(
    *$(at::Tensor* _self)));
  }|]

sin_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sin_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sin(
    *$(at::Tensor* _self)));
  }|]

sinh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sinh_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sinh(
    *$(at::Tensor* _self)));
  }|]

detach_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
detach_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::detach(
    *$(at::Tensor* _self)));
  }|]

detach__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
detach__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::detach_(
    *$(at::Tensor* _self)));
  }|]

size_ti
  :: Ptr Tensor
  -> CInt
  -> IO (CInt)
size_ti _self _dim =
  [C.block| int { return (at::native::size(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

slice_tiiii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
slice_tiiii _self _dim _start _end _step =
  [C.block| at::Tensor* { return new at::Tensor(at::native::slice(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(int _start)
  , $(int _end)
  , $(int _step)));
  }|]

slogdet_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
slogdet_t _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::slogdet(
    *$(at::Tensor* _self)));
  }|]

smm_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
smm_tt _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::smm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

softmax_tis
  :: Ptr Tensor
  -> CInt
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
softmax_tis _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softmax(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

softmax_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
softmax_ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softmax(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

split_tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
split_tii _self _split_size _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::split(
    *$(at::Tensor* _self)
  , $(int _split_size)
  , $(int _dim)));
  }|]

split_with_sizes_tli
  :: Ptr Tensor
  -> Ptr IntList
  -> CInt
  -> IO (Ptr TensorList)
split_with_sizes_tli _self _split_sizes _dim =
  [C.block| at::TensorList* { return new at::TensorList(at::native::split_with_sizes(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _split_sizes)
  , $(int _dim)));
  }|]

squeeze_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
squeeze_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::squeeze(
    *$(at::Tensor* _self)));
  }|]

squeeze_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
squeeze_ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::squeeze(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

squeeze__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
squeeze__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::squeeze_(
    *$(at::Tensor* _self)));
  }|]

squeeze__Ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
squeeze__Ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::squeeze_(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

sspaddmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sspaddmm_tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sspaddmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

stack_li
  :: Ptr TensorList
  -> CInt
  -> IO (Ptr Tensor)
stack_li _tensors _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::stack(
    *$(at::TensorList* _tensors)
  , $(int _dim)));
  }|]

stack_out_Tli
  :: Ptr Tensor
  -> Ptr TensorList
  -> CInt
  -> IO (Ptr Tensor)
stack_out_Tli _out _tensors _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::stack_out(
    *$(at::Tensor* _out)
  , *$(at::TensorList* _tensors)
  , $(int _dim)));
  }|]

stft_tiiitbb
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CInt
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
stft_tiiitbb _self _n_fft _hop_length _win_length _window _normalized _onesided =
  [C.block| at::Tensor* { return new at::Tensor(at::native::stft(
    *$(at::Tensor* _self)
  , $(int _n_fft)
  , $(int _hop_length)
  , $(int _win_length)
  , *$(at::Tensor* _window)
  , $(bool _normalized)
  , $(bool _onesided)));
  }|]

stride_ti
  :: Ptr Tensor
  -> CInt
  -> IO (CInt)
stride_ti _self _dim =
  [C.block| int { return (at::native::stride(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

sum_ts
  :: Ptr Tensor
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
sum_ts _self _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum(
    *$(at::Tensor* _self)
  , *$(at::ScalarType* _dtype)));
  }|]

sum_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sum_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum(
    *$(at::Tensor* _self)));
  }|]

sum_tlbs
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
sum_tlbs _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)
  , *$(at::ScalarType* _dtype)));
  }|]

sum_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
sum_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

sum_tls
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
sum_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

sum_out_Ttlbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
sum_out_Ttlbs _out _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)
  , *$(at::ScalarType* _dtype)));
  }|]

sum_out_Ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
sum_out_Ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

sum_out_Ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
sum_out_Ttls _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

sum_to_size_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
sum_to_size_tl _self _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sum_to_size(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)));
  }|]

sqrt_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sqrt_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sqrt(
    *$(at::Tensor* _self)));
  }|]

std_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
std_tb _self _unbiased =
  [C.block| at::Tensor* { return new at::Tensor(at::native::std(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

std_tlbb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
std_tlbb _self _dim _unbiased _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::std(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

std_out_Ttlbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
std_out_Ttlbb _out _self _dim _unbiased _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::std_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

prod_ts
  :: Ptr Tensor
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
prod_ts _self _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prod(
    *$(at::Tensor* _self)
  , *$(at::ScalarType* _dtype)));
  }|]

prod_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
prod_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prod(
    *$(at::Tensor* _self)));
  }|]

prod_tibs
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
prod_tibs _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prod(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)
  , *$(at::ScalarType* _dtype)));
  }|]

prod_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
prod_tib _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prod(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

prod_tis
  :: Ptr Tensor
  -> CInt
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
prod_tis _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prod(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

prod_out_Ttibs
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
prod_out_Ttibs _out _self _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)
  , *$(at::ScalarType* _dtype)));
  }|]

prod_out_Ttib
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
prod_out_Ttib _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _keepdim)));
  }|]

prod_out_Ttis
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
prod_out_Ttis _out _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

t_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
t_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::t(
    *$(at::Tensor* _self)));
  }|]

t__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
t__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::t_(
    *$(at::Tensor* _self)));
  }|]

tan_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tan_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tan(
    *$(at::Tensor* _self)));
  }|]

tanh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
tanh_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tanh(
    *$(at::Tensor* _self)));
  }|]

tensordot_ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
tensordot_ttll _self _other _dims_self _dims_other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tensordot(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::IntArrayRef* _dims_self)
  , *$(at::IntArrayRef* _dims_other)));
  }|]

threshold_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_tss _self _threshold _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::threshold(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold__Tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold__Tss _self _threshold _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::threshold_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold_out_Ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_out_Ttss _out _self _threshold _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::threshold_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)
  , *$(at::Scalar* _value)));
  }|]

threshold_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
threshold_backward_tts _grad_output _self _threshold =
  [C.block| at::Tensor* { return new at::Tensor(at::native::threshold_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _threshold)));
  }|]

transpose_tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
transpose_tii _self _dim0 _dim1 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::transpose(
    *$(at::Tensor* _self)
  , $(int _dim0)
  , $(int _dim1)));
  }|]

transpose__Tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
transpose__Tii _self _dim0 _dim1 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::transpose_(
    *$(at::Tensor* _self)
  , $(int _dim0)
  , $(int _dim1)));
  }|]

one_hot_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
one_hot_ti _self _num_classes =
  [C.block| at::Tensor* { return new at::Tensor(at::native::one_hot(
    *$(at::Tensor* _self)
  , $(int _num_classes)));
  }|]

rot90_til
  :: Ptr Tensor
  -> CInt
  -> Ptr IntList
  -> IO (Ptr Tensor)
rot90_til _self _k _dims =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rot90(
    *$(at::Tensor* _self)
  , $(int _k)
  , *$(at::IntArrayRef* _dims)));
  }|]

_trilinear_tttlllli
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> IO (Ptr Tensor)
_trilinear_tttlllli _i1 _i2 _i3 _expand1 _expand2 _expand3 _sumdim _unroll_dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_trilinear(
    *$(at::Tensor* _i1)
  , *$(at::Tensor* _i2)
  , *$(at::Tensor* _i3)
  , *$(at::IntArrayRef* _expand1)
  , *$(at::IntArrayRef* _expand2)
  , *$(at::IntArrayRef* _expand3)
  , *$(at::IntArrayRef* _sumdim)
  , $(int _unroll_dim)));
  }|]

triplet_margin_loss_tttfffbi
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CFloat
  -> CFloat
  -> CBool
  -> CInt
  -> IO (Ptr Tensor)
triplet_margin_loss_tttfffbi _anchor _positive _negative _margin _p _eps _swap _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::triplet_margin_loss(
    *$(at::Tensor* _anchor)
  , *$(at::Tensor* _positive)
  , *$(at::Tensor* _negative)
  , $(float _margin)
  , $(float _p)
  , $(float _eps)
  , $(bool _swap)
  , $(int _reduction)));
  }|]

trunc_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trunc_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::trunc(
    *$(at::Tensor* _self)));
  }|]

type_as_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
type_as_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::type_as(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

_unsafe_view_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
_unsafe_view_tl _self _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_unsafe_view(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)));
  }|]

unsqueeze_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
unsqueeze_ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::unsqueeze(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

unsqueeze__Ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
unsqueeze__Ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::unsqueeze_(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

var_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
var_tb _self _unbiased =
  [C.block| at::Tensor* { return new at::Tensor(at::native::var(
    *$(at::Tensor* _self)
  , $(bool _unbiased)));
  }|]

var_tlbb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
var_tlbb _self _dim _unbiased _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::var(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

var_out_Ttlbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
var_out_Ttlbb _out _self _dim _unbiased _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::var_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _unbiased)
  , $(bool _keepdim)));
  }|]

view_as_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
view_as_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::view_as(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

where_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
where_ttt _condition _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::where(
    *$(at::Tensor* _condition)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

norm_except_dim_tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
norm_except_dim_tii _v _pow _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::norm_except_dim(
    *$(at::Tensor* _v)
  , $(int _pow)
  , $(int _dim)));
  }|]

_weight_norm_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
_weight_norm_tti _v _g _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_weight_norm(
    *$(at::Tensor* _v)
  , *$(at::Tensor* _g)
  , $(int _dim)));
  }|]

_weight_norm_differentiable_backward_tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
_weight_norm_differentiable_backward_tttti _grad_w _saved_v _saved_g _saved_norms _dim =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_weight_norm_differentiable_backward(
    *$(at::Tensor* _grad_w)
  , *$(at::Tensor* _saved_v)
  , *$(at::Tensor* _saved_g)
  , *$(at::Tensor* _saved_norms)
  , $(int _dim)));
  }|]

zeros_lo
  :: Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::zeros(
    *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

zeros_out_Tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
zeros_out_Tl _out _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::zeros_out(
    *$(at::Tensor* _out)
  , *$(at::IntArrayRef* _size)));
  }|]

zeros_like_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
zeros_like_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::zeros_like(
    *$(at::Tensor* _self)));
  }|]

zeros_like_to
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
zeros_like_to _self _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::zeros_like(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_sum_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_sparse_sum_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum(
    *$(at::Tensor* _self)));
  }|]

_sparse_sum_ts
  :: Ptr Tensor
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
_sparse_sum_ts _self _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum(
    *$(at::Tensor* _self)
  , *$(at::ScalarType* _dtype)));
  }|]

_sparse_sum_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
_sparse_sum_tl _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)));
  }|]

_sparse_sum_tls
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
_sparse_sum_tls _self _dim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , *$(at::ScalarType* _dtype)));
  }|]

norm_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
norm_tss _self _p _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(at::ScalarType* _dtype)));
  }|]

norm_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
norm_ts _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)));
  }|]

norm_tslbs
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntList
  -> CBool
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
norm_tslbs _self _p _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)
  , *$(at::ScalarType* _dtype)));
  }|]

norm_tslb
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
norm_tslb _self _p _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::norm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

norm_out_Ttslbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntList
  -> CBool
  -> Ptr ScalarType
  -> IO (Ptr Tensor)
norm_out_Ttslbs _out _self _p _dim _keepdim _dtype =
  [C.block| at::Tensor* { return new at::Tensor(at::native::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)
  , *$(at::ScalarType* _dtype)));
  }|]

norm_out_Ttslb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
norm_out_Ttslb _out _self _p _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

frobenius_norm_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
frobenius_norm_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::frobenius_norm(
    *$(at::Tensor* _self)));
  }|]

frobenius_norm_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
frobenius_norm_tlb _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::frobenius_norm(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

frobenius_norm_out_Ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
frobenius_norm_out_Ttlb _out _self _dim _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::frobenius_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)
  , $(bool _keepdim)));
  }|]

nuclear_norm_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
nuclear_norm_tb _self _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nuclear_norm(
    *$(at::Tensor* _self)
  , $(bool _keepdim)));
  }|]

nuclear_norm_out_Ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
nuclear_norm_out_Ttb _out _self _keepdim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nuclear_norm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _keepdim)));
  }|]

clone_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clone_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::clone(
    *$(at::Tensor* _self)));
  }|]

resize_as__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
resize_as__Tt _self _the_template =
  [C.block| at::Tensor* { return new at::Tensor(at::native::resize_as_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _the_template)));
  }|]

pow_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_out_Tts _out _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

pow_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_ts _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

zero__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
zero__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::zero_(
    *$(at::Tensor* _self)));
  }|]

sub_out_Ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_out_Ttts _out _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sub_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_tts _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub__Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub__Tts _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sub_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub_tss _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

sub__Tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
sub__Tss _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sub_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

rsub_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_tts _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rsub(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

rsub_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rsub_tss _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rsub(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)
  , *$(at::Scalar* _alpha)));
  }|]

_sparse_addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sparse_addmm_tttss _self _sparse _dense _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _sparse)
  , *$(at::Tensor* _dense)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm_out_Ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_out_Ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm_tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addmm__Tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addmm__Tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addmm_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

sparse_coo_tensor_lo
  :: Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_coo_tensor(
    *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_tto
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_tto _indices _values _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_coo_tensor_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
sparse_coo_tensor_ttlo _indices _values _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_coo_tensor(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

_sparse_coo_tensor_unsafe_ttlo
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
_sparse_coo_tensor_unsafe_ttlo _indices _values _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_coo_tensor_unsafe(
    *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

numel_t
  :: Ptr Tensor
  -> IO (CInt)
numel_t _self =
  [C.block| int { return (at::native::numel(
    *$(at::Tensor* _self)));
  }|]

unbind_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
unbind_ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::unbind(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

to_tobb
  :: Ptr Tensor
  -> Ptr TensorOptions
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
to_tobb _self _options _non_blocking _copy =
  [C.block| at::Tensor* { return new at::Tensor(at::native::to(
    *$(at::Tensor* _self)
  , *$(at::TensorOptions* _options)
  , $(bool _non_blocking)
  , $(bool _copy)));
  }|]

to_tdevicesbb
  :: Ptr Tensor
  -> Ptr Device
  -> Ptr ScalarType
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
to_tdevicesbb _self _device _dtype _non_blocking _copy =
  [C.block| at::Tensor* { return new at::Tensor(at::native::to(
    *$(at::Tensor* _self)
  , *$(at::Device* _device)
  , *$(at::ScalarType* _dtype)
  , $(bool _non_blocking)
  , $(bool _copy)));
  }|]

to_tsbb
  :: Ptr Tensor
  -> Ptr ScalarType
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
to_tsbb _self _dtype _non_blocking _copy =
  [C.block| at::Tensor* { return new at::Tensor(at::native::to(
    *$(at::Tensor* _self)
  , *$(at::ScalarType* _dtype)
  , $(bool _non_blocking)
  , $(bool _copy)));
  }|]

to_ttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
to_ttbb _self _other _non_blocking _copy =
  [C.block| at::Tensor* { return new at::Tensor(at::native::to(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(bool _non_blocking)
  , $(bool _copy)));
  }|]

meshgrid_l
  :: Ptr TensorList
  -> IO (Ptr TensorList)
meshgrid_l _tensors =
  [C.block| at::TensorList* { return new at::TensorList(at::native::meshgrid(
    *$(at::TensorList* _tensors)));
  }|]

cartesian_prod_l
  :: Ptr TensorList
  -> IO (Ptr Tensor)
cartesian_prod_l _tensors =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cartesian_prod(
    *$(at::TensorList* _tensors)));
  }|]

combinations_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
combinations_tib _self _r _with_replacement =
  [C.block| at::Tensor* { return new at::Tensor(at::native::combinations(
    *$(at::Tensor* _self)
  , $(int _r)
  , $(bool _with_replacement)));
  }|]

item_t
  :: Ptr Tensor
  -> IO (Ptr Scalar)
item_t _self =
  [C.block| at::Scalar* { return new at::Scalar(at::native::item(
    *$(at::Tensor* _self)));
  }|]

lstm_tllbifbbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
lstm_tllbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::lstm(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

lstm_ttllbifbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
lstm_ttllbifbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::lstm(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::TensorList* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

gru_ttlbifbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
gru_ttlbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gru(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

gru_tttlbifbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
gru_tttlbifbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gru(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

rnn_tanh_ttlbifbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
rnn_tanh_ttlbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::rnn_tanh(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

rnn_tanh_tttlbifbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
rnn_tanh_tttlbifbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::rnn_tanh(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

rnn_relu_ttlbifbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
rnn_relu_ttlbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::rnn_relu(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

rnn_relu_tttlbifbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
rnn_relu_tttlbifbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::rnn_relu(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , *$(at::Tensor* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)));
  }|]

lstm_cell_tltttt
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
lstm_cell_tltttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::lstm_cell(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

gru_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gru_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

rnn_tanh_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_tanh_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

rnn_relu_cell_tttttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rnn_relu_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)));
  }|]

quantized_lstm_tllbifbbb
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr TensorList
  -> CBool
  -> CInt
  -> CFloat
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
quantized_lstm_tllbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::quantized_lstm(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _hx)
  , *$(at::TensorList* _params)
  , $(bool _has_biases)
  , $(int _num_layers)
  , $(float _dropout)
  , $(bool _train)
  , $(bool _bidirectional)
  , $(bool _batch_first)));
  }|]

quantized_lstm_cell_tlttttttttssss
  :: Ptr Tensor
  -> Ptr TensorList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr (Tensor,Tensor))
quantized_lstm_cell_tlttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::quantized_lstm_cell(
    *$(at::Tensor* _input)
  , *$(at::TensorList* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_gru_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_gru_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::native::quantized_gru_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_rnn_relu_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_rnn_relu_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::native::quantized_rnn_relu_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

quantized_rnn_tanh_cell_ttttttttttssss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
quantized_rnn_tanh_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh =
  [C.block| at::Tensor* { return new at::Tensor(at::native::quantized_rnn_tanh_cell(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _hx)
  , *$(at::Tensor* _w_ih)
  , *$(at::Tensor* _w_hh)
  , *$(at::Tensor* _b_ih)
  , *$(at::Tensor* _b_hh)
  , *$(at::Tensor* _packed_ih)
  , *$(at::Tensor* _packed_hh)
  , *$(at::Tensor* _col_offsets_ih)
  , *$(at::Tensor* _col_offsets_hh)
  , *$(at::Scalar* _scale_ih)
  , *$(at::Scalar* _scale_hh)
  , *$(at::Scalar* _zero_point_ih)
  , *$(at::Scalar* _zero_point_hh)));
  }|]

_pack_padded_sequence_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
_pack_padded_sequence_ttb _input _lengths _batch_first =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_pack_padded_sequence(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _lengths)
  , $(bool _batch_first)));
  }|]

_pack_padded_sequence_backward_tltb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_pack_padded_sequence_backward_tltb _grad _input_size _batch_sizes _batch_first =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_pack_padded_sequence_backward(
    *$(at::Tensor* _grad)
  , *$(at::IntArrayRef* _input_size)
  , *$(at::Tensor* _batch_sizes)
  , $(bool _batch_first)));
  }|]

_pad_packed_sequence_ttbsi
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Ptr Scalar
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
_pad_packed_sequence_ttbsi _data _batch_sizes _batch_first _padding_value _total_length =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_pad_packed_sequence(
    *$(at::Tensor* _data)
  , *$(at::Tensor* _batch_sizes)
  , $(bool _batch_first)
  , *$(at::Scalar* _padding_value)
  , $(int _total_length)));
  }|]

data_ptr_t
  :: Ptr Tensor
  -> IO ()
data_ptr_t _self =
  [C.block| void {  (at::native::data_ptr(
    *$(at::Tensor* _self)));
  }|]

set__Tstorage
  :: Ptr Tensor
  -> Ptr Storage
  -> IO (Ptr Tensor)
set__Tstorage _self _source =
  [C.block| at::Tensor* { return new at::Tensor(at::native::set_(
    *$(at::Tensor* _self)
  , *$(at::Storage* _source)));
  }|]

set__Tstorageill
  :: Ptr Tensor
  -> Ptr Storage
  -> CInt
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
set__Tstorageill _self _source _storage_offset _size _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::native::set_(
    *$(at::Tensor* _self)
  , *$(at::Storage* _source)
  , $(int _storage_offset)
  , *$(at::IntArrayRef* _size)
  , *$(at::IntArrayRef* _stride)));
  }|]

set__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
set__Tt _self _source =
  [C.block| at::Tensor* { return new at::Tensor(at::native::set_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _source)));
  }|]

set__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
set__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::set_(
    *$(at::Tensor* _self)));
  }|]

is_set_to_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
is_set_to_tt _self _tensor =
  [C.block| bool { return (at::native::is_set_to(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor)));
  }|]

masked_fill__Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
masked_fill__Tts _self _mask _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::masked_fill_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Scalar* _value)));
  }|]

masked_fill_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
masked_fill_tts _self _mask _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::masked_fill(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Scalar* _value)));
  }|]

masked_fill__Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_fill__Ttt _self _mask _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::masked_fill_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _value)));
  }|]

masked_fill_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_fill_ttt _self _mask _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::masked_fill(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _value)));
  }|]

masked_scatter__Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_scatter__Ttt _self _mask _source =
  [C.block| at::Tensor* { return new at::Tensor(at::native::masked_scatter_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _source)));
  }|]

masked_scatter_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_scatter_ttt _self _mask _source =
  [C.block| at::Tensor* { return new at::Tensor(at::native::masked_scatter(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)
  , *$(at::Tensor* _source)));
  }|]

view_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
view_tl _self _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::view(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)));
  }|]

put__Tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
put__Tttb _self _index _source _accumulate =
  [C.block| at::Tensor* { return new at::Tensor(at::native::put_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)
  , $(bool _accumulate)));
  }|]

index_add__Titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_add__Titt _self _dim _index _source =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_add_(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_add_titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_add_titt _self _dim _index _source =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_add(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

index_fill__Tits
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
index_fill__Tits _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_fill_(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

index_fill_tits
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
index_fill_tits _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_fill(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

index_fill__Titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_fill__Titt _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_fill_(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _value)));
  }|]

index_fill_titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_fill_titt _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_fill(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _value)));
  }|]

scatter__Titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter__Titt _self _dim _index _src =
  [C.block| at::Tensor* { return new at::Tensor(at::native::scatter_(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

scatter_titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_titt _self _dim _index _src =
  [C.block| at::Tensor* { return new at::Tensor(at::native::scatter(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

scatter__Tits
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
scatter__Tits _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::scatter_(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

scatter_tits
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
scatter_tits _self _dim _index _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::scatter(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Scalar* _value)));
  }|]

scatter_add__Titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_add__Titt _self _dim _index _src =
  [C.block| at::Tensor* { return new at::Tensor(at::native::scatter_add_(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

scatter_add_titt
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
scatter_add_titt _self _dim _index _src =
  [C.block| at::Tensor* { return new at::Tensor(at::native::scatter_add(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _src)));
  }|]

lt__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lt__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lt_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

lt__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lt__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lt_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

gt__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
gt__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gt_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

gt__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gt__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gt_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

le__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
le__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::le_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

le__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
le__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::le_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ge__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ge__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ge_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ge__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ge__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ge_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

eq__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
eq__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eq_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

eq__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
eq__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eq_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ne__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ne__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ne_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ne__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ne__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ne_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__and___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__and___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__and__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__and___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__and___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__and__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__iand___Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__iand___Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__iand__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__iand___Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__iand___Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__iand__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__or___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__or___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__or__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__or___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__or___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__or__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__ior___Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__ior___Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__ior__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__ior___Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__ior___Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__ior__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__xor___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__xor___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__xor__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__xor___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__xor___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__xor__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__ixor___Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__ixor___Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__ixor__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__ixor___Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__ixor___Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__ixor__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__lshift___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__lshift___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__lshift__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__lshift___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__lshift___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__lshift__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__ilshift___Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__ilshift___Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__ilshift__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__ilshift___Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__ilshift___Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__ilshift__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__rshift___ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__rshift___ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__rshift__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__rshift___tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__rshift___tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__rshift__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

__irshift___Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
__irshift___Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__irshift__(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

__irshift___Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
__irshift___Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::__irshift__(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lgamma__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
lgamma__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lgamma_(
    *$(at::Tensor* _self)));
  }|]

atan2__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::atan2_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

digamma__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
digamma__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::digamma_(
    *$(at::Tensor* _self)));
  }|]

polygamma__Ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
polygamma__Ti _self _n =
  [C.block| at::Tensor* { return new at::Tensor(at::native::polygamma_(
    *$(at::Tensor* _self)
  , $(int _n)));
  }|]

erfinv__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfinv__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::erfinv_(
    *$(at::Tensor* _self)));
  }|]

frac__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
frac__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::frac_(
    *$(at::Tensor* _self)));
  }|]

renorm__Tsis
  :: Ptr Tensor
  -> Ptr Scalar
  -> CInt
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm__Tsis _self _p _dim _maxnorm =
  [C.block| at::Tensor* { return new at::Tensor(at::native::renorm_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

reciprocal__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reciprocal_(
    *$(at::Tensor* _self)));
  }|]

neg__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
neg__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::neg_(
    *$(at::Tensor* _self)));
  }|]

pow__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow__Ts _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

pow__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow__Tt _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

lerp__Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp__Tts _self _end _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lerp_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

sign__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sign__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sign_(
    *$(at::Tensor* _self)));
  }|]

fmod__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fmod_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fmod_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder__Ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::remainder_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder__Tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::remainder_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

addbmm__Tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm__Tttss _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addbmm_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addbmm_out_Ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm_out_Ttttss _out _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addbmm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addbmm_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addbmm_tttss _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addbmm(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

addcmul__Ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcmul__Ttts _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addcmul_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcdiv__Ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcdiv__Ttts _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addcdiv_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

random__Tiip
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> Ptr Generator
  -> IO (Ptr Tensor)
random__Tiip _self _from _to _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::random_(
    *$(at::Tensor* _self)
  , $(int _from)
  , $(int _to)
  , $(at::Generator * _generator)));
  }|]

random__Tip
  :: Ptr Tensor
  -> CInt
  -> Ptr Generator
  -> IO (Ptr Tensor)
random__Tip _self _to _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::random_(
    *$(at::Tensor* _self)
  , $(int _to)
  , $(at::Generator * _generator)));
  }|]

random__Tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
random__Tp _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::random_(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

uniform__Tffp
  :: Ptr Tensor
  -> CFloat
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
uniform__Tffp _self _from _to _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::uniform_(
    *$(at::Tensor* _self)
  , $(float _from)
  , $(float _to)
  , $(at::Generator * _generator)));
  }|]

normal__Tffp
  :: Ptr Tensor
  -> CFloat
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal__Tffp _self _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::normal_(
    *$(at::Tensor* _self)
  , $(float _mean)
  , $(float _std)
  , $(at::Generator * _generator)));
  }|]

cauchy__Tffp
  :: Ptr Tensor
  -> CFloat
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
cauchy__Tffp _self _median _sigma _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cauchy_(
    *$(at::Tensor* _self)
  , $(float _median)
  , $(float _sigma)
  , $(at::Generator * _generator)));
  }|]

log_normal__Tffp
  :: Ptr Tensor
  -> CFloat
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
log_normal__Tffp _self _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_normal_(
    *$(at::Tensor* _self)
  , $(float _mean)
  , $(float _std)
  , $(at::Generator * _generator)));
  }|]

exponential__Tfp
  :: Ptr Tensor
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
exponential__Tfp _self _lambd _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::exponential_(
    *$(at::Tensor* _self)
  , $(float _lambd)
  , $(at::Generator * _generator)));
  }|]

geometric__Tfp
  :: Ptr Tensor
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
geometric__Tfp _self _p _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::geometric_(
    *$(at::Tensor* _self)
  , $(float _p)
  , $(at::Generator * _generator)));
  }|]

diag_out_Tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
diag_out_Tti _out _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::native::diag_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _diagonal)));
  }|]

diag_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
diag_ti _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::native::diag(
    *$(at::Tensor* _self)
  , $(int _diagonal)));
  }|]

cross_out_Ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
cross_out_Ttti _out _self _other _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cross_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(int _dim)));
  }|]

cross_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
cross_tti _self _other _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cross(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , $(int _dim)));
  }|]

triu_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
triu_ti _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::native::triu(
    *$(at::Tensor* _self)
  , $(int _diagonal)));
  }|]

tril_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
tril_ti _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tril(
    *$(at::Tensor* _self)
  , $(int _diagonal)));
  }|]

trace_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
trace_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::trace(
    *$(at::Tensor* _self)));
  }|]

ne_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ne_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ne_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ne_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ne_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ne(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ne_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ne_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ne_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ne_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ne_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ne(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

eq_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
eq_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eq_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

eq_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
eq_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eq(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

eq_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
eq_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eq_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

eq_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
eq_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eq(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ge_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ge_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ge_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ge_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
ge_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ge(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

ge_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ge_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ge_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

ge_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ge_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ge(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

le_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
le_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::le_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

le_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
le_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::le(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

le_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
le_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::le_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

le_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
le_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::le(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

gt_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
gt_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

gt_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
gt_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gt(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

gt_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gt_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

gt_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gt_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gt(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lt_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lt_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

lt_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lt_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lt(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

lt_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lt_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lt_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lt_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lt_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lt(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

take_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
take_out_Ttt _out _self _index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::take_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _index)));
  }|]

take_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
take_tt _self _index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::take(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _index)));
  }|]

index_select_out_Ttit
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_select_out_Ttit _out _self _dim _index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_select_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)));
  }|]

index_select_tit
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
index_select_tit _self _dim _index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::index_select(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)));
  }|]

masked_select_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_select_out_Ttt _out _self _mask =
  [C.block| at::Tensor* { return new at::Tensor(at::native::masked_select_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)));
  }|]

masked_select_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
masked_select_tt _self _mask =
  [C.block| at::Tensor* { return new at::Tensor(at::native::masked_select(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mask)));
  }|]

nonzero_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nonzero_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nonzero_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

nonzero_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
nonzero_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nonzero(
    *$(at::Tensor* _self)));
  }|]

gather_out_Ttit
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gather_out_Ttit _out _self _dim _index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gather_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)));
  }|]

gather_tit
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
gather_tit _self _dim _index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::gather(
    *$(at::Tensor* _self)
  , $(int _dim)
  , *$(at::Tensor* _index)));
  }|]

addcmul_out_Tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcmul_out_Tttts _out _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addcmul_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcmul_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcmul_ttts _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addcmul(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcdiv_out_Tttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcdiv_out_Tttts _out _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addcdiv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

addcdiv_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
addcdiv_ttts _self _tensor1 _tensor2 _value =
  [C.block| at::Tensor* { return new at::Tensor(at::native::addcdiv(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _tensor1)
  , *$(at::Tensor* _tensor2)
  , *$(at::Scalar* _value)));
  }|]

gels_out_TTtt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
gels_out_TTtt _X _qr _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gels_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _qr)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

gels_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
gels_tt _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gels(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

trtrs_out_TTttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
trtrs_out_TTttbbb _X _M _self _A _upper _transpose _unitriangular =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::trtrs_out(
    *$(at::Tensor* _X)
  , *$(at::Tensor* _M)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)
  , $(bool _unitriangular)));
  }|]

trtrs_ttbbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
trtrs_ttbbb _self _A _upper _transpose _unitriangular =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::trtrs(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)
  , $(bool _transpose)
  , $(bool _unitriangular)));
  }|]

symeig_out_TTtbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
symeig_out_TTtbb _e _V _self _eigenvectors _upper =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::symeig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)
  , $(bool _eigenvectors)
  , $(bool _upper)));
  }|]

symeig_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
symeig_tbb _self _eigenvectors _upper =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::symeig(
    *$(at::Tensor* _self)
  , $(bool _eigenvectors)
  , $(bool _upper)));
  }|]

eig_out_TTtb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
eig_out_TTtb _e _v _self _eigenvectors =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::eig_out(
    *$(at::Tensor* _e)
  , *$(at::Tensor* _v)
  , *$(at::Tensor* _self)
  , $(bool _eigenvectors)));
  }|]

eig_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
eig_tb _self _eigenvectors =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::eig(
    *$(at::Tensor* _self)
  , $(bool _eigenvectors)));
  }|]

svd_out_TTTtbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
svd_out_TTTtbb _U _S _V _self _some _compute_uv =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::svd_out(
    *$(at::Tensor* _U)
  , *$(at::Tensor* _S)
  , *$(at::Tensor* _V)
  , *$(at::Tensor* _self)
  , $(bool _some)
  , $(bool _compute_uv)));
  }|]

svd_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
svd_tbb _self _some _compute_uv =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::svd(
    *$(at::Tensor* _self)
  , $(bool _some)
  , $(bool _compute_uv)));
  }|]

cholesky_out_Ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_out_Ttb _out _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cholesky_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_tb _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cholesky(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

cholesky_solve_out_Tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_solve_out_Tttb _out _self _input2 _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cholesky_solve_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , $(bool _upper)));
  }|]

cholesky_solve_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
cholesky_solve_ttb _self _input2 _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::native::cholesky_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , $(bool _upper)));
  }|]

potri_out_Ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
potri_out_Ttb _out _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::native::potri_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

potri_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
potri_tb _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::native::potri(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

pstrf_out_TTtbs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> Ptr Scalar
  -> IO (Ptr (Tensor,Tensor))
pstrf_out_TTtbs _u _pivot _self _upper _tol =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::pstrf_out(
    *$(at::Tensor* _u)
  , *$(at::Tensor* _pivot)
  , *$(at::Tensor* _self)
  , $(bool _upper)
  , *$(at::Scalar* _tol)));
  }|]

pstrf_tbs
  :: Ptr Tensor
  -> CBool
  -> Ptr Scalar
  -> IO (Ptr (Tensor,Tensor))
pstrf_tbs _self _upper _tol =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::pstrf(
    *$(at::Tensor* _self)
  , $(bool _upper)
  , *$(at::Scalar* _tol)));
  }|]

qr_out_TTt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
qr_out_TTt _Q _R _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::qr_out(
    *$(at::Tensor* _Q)
  , *$(at::Tensor* _R)
  , *$(at::Tensor* _self)));
  }|]

qr_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
qr_t _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::qr(
    *$(at::Tensor* _self)));
  }|]

geqrf_out_TTt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
geqrf_out_TTt _a _tau _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::geqrf_out(
    *$(at::Tensor* _a)
  , *$(at::Tensor* _tau)
  , *$(at::Tensor* _self)));
  }|]

geqrf_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
geqrf_t _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::geqrf(
    *$(at::Tensor* _self)));
  }|]

orgqr_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
orgqr_out_Ttt _out _self _input2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::orgqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)));
  }|]

orgqr_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
orgqr_tt _self _input2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::orgqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)));
  }|]

ormqr_out_Ttttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
ormqr_out_Ttttbb _out _self _input2 _input3 _left _transpose =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ormqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)
  , $(bool _transpose)));
  }|]

ormqr_tttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
ormqr_tttbb _self _input2 _input3 _left _transpose =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ormqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)
  , $(bool _transpose)));
  }|]

btrifact_out_TTtb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
btrifact_out_TTtb _A_LU _pivots _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::btrifact_out(
    *$(at::Tensor* _A_LU)
  , *$(at::Tensor* _pivots)
  , *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

btrifact_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
btrifact_tb _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::btrifact(
    *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

btrifact_with_info_out_TTTtb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
btrifact_with_info_out_TTTtb _A_LU _pivots _info _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::btrifact_with_info_out(
    *$(at::Tensor* _A_LU)
  , *$(at::Tensor* _pivots)
  , *$(at::Tensor* _info)
  , *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

btrifact_with_info_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor))
btrifact_with_info_tb _self _pivot =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::btrifact_with_info(
    *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

btrisolve_out_Tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
btrisolve_out_Tttt _out _self _LU_data _LU_pivots =
  [C.block| at::Tensor* { return new at::Tensor(at::native::btrisolve_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

btrisolve_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
btrisolve_ttt _self _LU_data _LU_pivots =
  [C.block| at::Tensor* { return new at::Tensor(at::native::btrisolve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

multinomial_out_Ttibp
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
multinomial_out_Ttibp _out _self _num_samples _replacement _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multinomial_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _num_samples)
  , $(bool _replacement)
  , $(at::Generator * _generator)));
  }|]

multinomial_tibp
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
multinomial_tibp _self _num_samples _replacement _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multinomial(
    *$(at::Tensor* _self)
  , $(int _num_samples)
  , $(bool _replacement)
  , $(at::Generator * _generator)));
  }|]

lgamma_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lgamma_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lgamma_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

lgamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
lgamma_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lgamma(
    *$(at::Tensor* _self)));
  }|]

digamma_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
digamma_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::digamma_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

digamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
digamma_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::digamma(
    *$(at::Tensor* _self)));
  }|]

polygamma_out_Tit
  :: Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polygamma_out_Tit _out _n _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::polygamma_out(
    *$(at::Tensor* _out)
  , $(int _n)
  , *$(at::Tensor* _self)));
  }|]

polygamma_it
  :: CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polygamma_it _n _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::polygamma(
    $(int _n)
  , *$(at::Tensor* _self)));
  }|]

erfinv_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
erfinv_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::erfinv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

erfinv_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfinv_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::erfinv(
    *$(at::Tensor* _self)));
  }|]

frac_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
frac_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::frac_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

frac_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
frac_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::frac(
    *$(at::Tensor* _self)));
  }|]

dist_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
dist_tts _self _other _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native::dist(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _p)));
  }|]

reciprocal_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reciprocal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

reciprocal_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
reciprocal_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reciprocal(
    *$(at::Tensor* _self)));
  }|]

neg_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
neg_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::neg_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

neg_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
neg_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::neg(
    *$(at::Tensor* _self)));
  }|]

atan2_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::atan2_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

atan2_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::atan2(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lerp_out_Ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp_out_Ttts _out _self _end _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lerp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

lerp_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp_tts _self _end _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::native::lerp(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

sign_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sign_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sign_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sign_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sign_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sign(
    *$(at::Tensor* _self)));
  }|]

fmod_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fmod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fmod(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fmod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

fmod_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fmod(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::remainder_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder_ts _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::remainder(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::remainder_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::remainder(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
min_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::min_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
min_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::min(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
min_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::min(
    *$(at::Tensor* _self)));
  }|]

max_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

max_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_tt _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

max_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
max_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max(
    *$(at::Tensor* _self)));
  }|]

median_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
median_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::median(
    *$(at::Tensor* _self)));
  }|]

sort_out_TTtib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
sort_out_TTtib _values _indices _self _dim _descending =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _descending)));
  }|]

sort_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
sort_tib _self _dim _descending =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::sort(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _descending)));
  }|]

argsort_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
argsort_tib _self _dim _descending =
  [C.block| at::Tensor* { return new at::Tensor(at::native::argsort(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _descending)));
  }|]

topk_out_TTtiibb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
topk_out_TTtiibb _values _indices _self _k _dim _largest _sorted =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int _k)
  , $(int _dim)
  , $(bool _largest)
  , $(bool _sorted)));
  }|]

topk_tiibb
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
topk_tiibb _self _k _dim _largest _sorted =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::topk(
    *$(at::Tensor* _self)
  , $(int _k)
  , $(int _dim)
  , $(bool _largest)
  , $(bool _sorted)));
  }|]

all_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
all_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::all(
    *$(at::Tensor* _self)));
  }|]

any_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
any_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::any(
    *$(at::Tensor* _self)));
  }|]

renorm_out_Ttsis
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> CInt
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm_out_Ttsis _out _self _p _dim _maxnorm =
  [C.block| at::Tensor* { return new at::Tensor(at::native::renorm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

renorm_tsis
  :: Ptr Tensor
  -> Ptr Scalar
  -> CInt
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm_tsis _self _p _dim _maxnorm =
  [C.block| at::Tensor* { return new at::Tensor(at::native::renorm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

unfold_tiii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
unfold_tiii _self _dimension _size _step =
  [C.block| at::Tensor* { return new at::Tensor(at::native::unfold(
    *$(at::Tensor* _self)
  , $(int _dimension)
  , $(int _size)
  , $(int _step)));
  }|]

equal_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
equal_tt _self _other =
  [C.block| bool { return (at::native::equal(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

pow_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_out_Ttt _out _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_tt _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_out_Tst
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_out_Tst _out _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_st
  :: Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_st _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow(
    *$(at::Scalar* _self)
  , *$(at::Tensor* _exponent)));
  }|]

normal_out_Ttfp
  :: Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_Ttfp _output _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::normal_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _mean)
  , $(float _std)
  , $(at::Generator * _generator)));
  }|]

normal_tfp
  :: Ptr Tensor
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_tfp _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::normal(
    *$(at::Tensor* _mean)
  , $(float _std)
  , $(at::Generator * _generator)));
  }|]

normal_out_Tftp
  :: Ptr Tensor
  -> CFloat
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_Tftp _output _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::normal_out(
    *$(at::Tensor* _output)
  , $(float _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_ftp
  :: CFloat
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_ftp _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::normal(
    $(float _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_out_Tttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_Tttp _output _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::normal_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

normal_ttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_ttp _mean _std _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::normal(
    *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)
  , $(at::Generator * _generator)));
  }|]

alias_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
alias_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::alias(
    *$(at::Tensor* _self)));
  }|]

_dirichlet_grad_out_Tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_dirichlet_grad_out_Tttt _output _x _alpha _total =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_dirichlet_grad_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _x)
  , *$(at::Tensor* _alpha)
  , *$(at::Tensor* _total)));
  }|]

_dirichlet_grad_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_dirichlet_grad_ttt _x _alpha _total =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_dirichlet_grad(
    *$(at::Tensor* _x)
  , *$(at::Tensor* _alpha)
  , *$(at::Tensor* _total)));
  }|]

binary_cross_entropy_out_Tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
binary_cross_entropy_out_Tttti _output _self _target _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)));
  }|]

binary_cross_entropy_ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
binary_cross_entropy_ttti _self _target _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)));
  }|]

binary_cross_entropy_backward_out_Ttttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_out_Ttttti _grad_input _grad_output _self _target _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)));
  }|]

binary_cross_entropy_backward_tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
binary_cross_entropy_backward_tttti _grad_output _self _target _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)));
  }|]

mse_loss_out_Ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
mse_loss_out_Ttti _output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mse_loss_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

mse_loss_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
mse_loss_tti _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mse_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

mse_loss_backward_out_Tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
mse_loss_backward_out_Tttti _grad_input _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mse_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

mse_loss_backward_ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
mse_loss_backward_ttti _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mse_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

l1_loss_out_Ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
l1_loss_out_Ttti _output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::l1_loss_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

l1_loss_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
l1_loss_tti _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

l1_loss_backward_out_Tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
l1_loss_backward_out_Tttti _grad_input _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::l1_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

l1_loss_backward_ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
l1_loss_backward_ttti _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::l1_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

multi_margin_loss_out_Tttssti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
multi_margin_loss_out_Tttssti _output _self _target _p _margin _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multi_margin_loss_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int _reduction)));
  }|]

multi_margin_loss_ttssti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
multi_margin_loss_ttssti _self _target _p _margin _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int _reduction)));
  }|]

multi_margin_loss_backward_out_Ttttssti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
multi_margin_loss_backward_out_Ttttssti _grad_input _grad_output _self _target _p _margin _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multi_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int _reduction)));
  }|]

multi_margin_loss_backward_tttssti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
multi_margin_loss_backward_tttssti _grad_output _self _target _p _margin _weight _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multi_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int _reduction)));
  }|]

multilabel_margin_loss_out_Ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
multilabel_margin_loss_out_Ttti _output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multilabel_margin_loss_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

multilabel_margin_loss_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
multilabel_margin_loss_tti _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multilabel_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

multilabel_margin_loss_forward_out_TTtti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
multilabel_margin_loss_forward_out_TTtti _output _is_target _self _target _reduction =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::multilabel_margin_loss_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _is_target)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

multilabel_margin_loss_forward_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
multilabel_margin_loss_forward_tti _self _target _reduction =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::multilabel_margin_loss_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

multilabel_margin_loss_backward_out_Ttttit
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_backward_out_Ttttit _grad_input _grad_output _self _target _reduction _is_target =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multilabel_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)
  , *$(at::Tensor* _is_target)));
  }|]

multilabel_margin_loss_backward_tttit
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_backward_tttit _grad_output _self _target _reduction _is_target =
  [C.block| at::Tensor* { return new at::Tensor(at::native::multilabel_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)
  , *$(at::Tensor* _is_target)));
  }|]

nll_loss_out_Ttttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
nll_loss_out_Ttttii _output _self _target _weight _reduction _ignore_index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)));
  }|]

nll_loss_tttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
nll_loss_tttii _self _target _weight _reduction _ignore_index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)));
  }|]

nll_loss_forward_out_TTtttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
nll_loss_forward_out_TTtttii _output _total_weight _self _target _weight _reduction _ignore_index =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::nll_loss_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _total_weight)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)));
  }|]

nll_loss_forward_tttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
nll_loss_forward_tttii _self _target _weight _reduction _ignore_index =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::nll_loss_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)));
  }|]

nll_loss_backward_out_Tttttiit
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_backward_out_Tttttiit _grad_input _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss_backward_ttttiit
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_backward_ttttiit _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss2d_out_Ttttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
nll_loss2d_out_Ttttii _output _self _target _weight _reduction _ignore_index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)));
  }|]

nll_loss2d_tttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
nll_loss2d_tttii _self _target _weight _reduction _ignore_index =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)));
  }|]

nll_loss2d_forward_out_TTtttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
nll_loss2d_forward_out_TTtttii _output _total_weight _self _target _weight _reduction _ignore_index =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::nll_loss2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _total_weight)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)));
  }|]

nll_loss2d_forward_tttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
nll_loss2d_forward_tttii _self _target _weight _reduction _ignore_index =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::nll_loss2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)));
  }|]

nll_loss2d_backward_out_Tttttiit
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_backward_out_Tttttiit _grad_input _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss2d_backward_ttttiit
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_backward_ttttiit _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int _reduction)
  , $(int _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

smooth_l1_loss_out_Ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
smooth_l1_loss_out_Ttti _output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::smooth_l1_loss_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

smooth_l1_loss_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
smooth_l1_loss_tti _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::smooth_l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

smooth_l1_loss_backward_out_Tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
smooth_l1_loss_backward_out_Tttti _grad_input _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::smooth_l1_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

smooth_l1_loss_backward_ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
smooth_l1_loss_backward_ttti _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::smooth_l1_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

soft_margin_loss_out_Ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
soft_margin_loss_out_Ttti _output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::soft_margin_loss_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

soft_margin_loss_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
soft_margin_loss_tti _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::soft_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

soft_margin_loss_backward_out_Tttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
soft_margin_loss_backward_out_Tttti _grad_input _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::soft_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

soft_margin_loss_backward_ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
soft_margin_loss_backward_ttti _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::soft_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

elu_out_Ttsss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_out_Ttsss _output _self _alpha _scale _input_scale =
  [C.block| at::Tensor* { return new at::Tensor(at::native::elu_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_tsss _self _alpha _scale _input_scale =
  [C.block| at::Tensor* { return new at::Tensor(at::native::elu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu_backward_out_Ttssst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_backward_out_Ttssst _grad_input _grad_output _alpha _scale _input_scale _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::elu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)
  , *$(at::Tensor* _output)));
  }|]

elu_backward_tssst
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_backward_tssst _grad_output _alpha _scale _input_scale _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::elu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)
  , *$(at::Tensor* _output)));
  }|]

elu__Tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu__Tsss _self _alpha _scale _input_scale =
  [C.block| at::Tensor* { return new at::Tensor(at::native::elu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

glu_out_Tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
glu_out_Tti _output _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::glu_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

glu_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
glu_ti _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::glu(
    *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

glu_backward_out_Ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
glu_backward_out_Ttti _grad_input _grad_output _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::glu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

glu_backward_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
glu_backward_tti _grad_output _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::glu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , $(int _dim)));
  }|]

hardtanh_out_Ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_out_Ttss _output _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_tss _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_backward_out_Tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_backward_out_Tttss _grad_input _grad_output _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_backward_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_backward_ttss _grad_output _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh__Tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh__Tss _self _min_val _max_val =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

leaky_relu_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_out_Tts _output _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_ts _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_backward_out_Ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_backward_out_Ttts _grad_input _grad_output _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_backward_tts _grad_output _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu__Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu__Ts _self _negative_slope =
  [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

log_sigmoid_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_out_Tt _output _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_sigmoid_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)));
  }|]

log_sigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_sigmoid(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_forward_out_TTt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
log_sigmoid_forward_out_TTt _output _buffer _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::log_sigmoid_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _buffer)
  , *$(at::Tensor* _self)));
  }|]

log_sigmoid_forward_t
  :: Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
log_sigmoid_forward_t _self =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::log_sigmoid_forward(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_backward_out_Tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_backward_out_Tttt _grad_input _grad_output _self _buffer =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_sigmoid_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _buffer)));
  }|]

log_sigmoid_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_backward_ttt _grad_output _self _buffer =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_sigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _buffer)));
  }|]

rrelu_with_noise_out_Tttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise_out_Tttssbp _output _self _noise _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_with_noise_ttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise_ttssbp _self _noise _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

rrelu_with_noise_backward_out_Ttttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_backward_out_Ttttssb _grad_input _grad_output _self _noise _lower _upper _training =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise_backward_tttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_backward_tttssb _grad_output _self _noise _lower _upper _training =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise__Ttssbp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise__Ttssbp _self _noise _lower _upper _training _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(at::Generator * _generator)));
  }|]

softplus_out_Ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_out_Ttss _output _self _beta _threshold =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softplus_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)));
  }|]

softplus_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_tss _self _beta _threshold =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softplus(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)));
  }|]

softplus_backward_out_Tttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_backward_out_Tttsst _grad_input _grad_output _self _beta _threshold _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softplus_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)
  , *$(at::Tensor* _output)));
  }|]

softplus_backward_ttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_backward_ttsst _grad_output _self _beta _threshold _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softplus_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)
  , *$(at::Tensor* _output)));
  }|]

softshrink_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_out_Tts _output _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softshrink_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_ts _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softshrink(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_backward_out_Ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_backward_out_Ttts _grad_input _grad_output _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softshrink_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_backward_tts _grad_output _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softshrink_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_avg_pool3d_out_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_out_Ttl _output _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_avg_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool3d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_avg_pool3d_backward_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_out_Ttt _grad_input _grad_output _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_avg_pool3d_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_tt _grad_output _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_max_pool2d_out_TTtl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool2d_out_TTtl _output _indices _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_max_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool2d_tl _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool2d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_max_pool2d_backward_out_Tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_out_Tttt _grad_input _grad_output _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_max_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool2d_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_ttt _grad_output _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_max_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool3d_out_TTtl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool3d_out_TTtl _output _indices _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_max_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool3d_tl _self _output_size =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool3d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_max_pool3d_backward_out_Tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool3d_backward_out_Tttt _grad_input _grad_output _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_max_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool3d_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool3d_backward_ttt _grad_output _self _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_max_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

avg_pool2d_out_Ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_out_Ttlllbb _output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool2d_tlllbb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool2d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool2d_backward_out_Tttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_backward_out_Tttlllbb _grad_input _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool2d_backward_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool2d_backward_ttlllbb _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_out_Ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_out_Ttlllbb _output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_tlllbb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool3d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_backward_out_Tttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_backward_out_Tttlllbb _grad_input _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

avg_pool3d_backward_ttlllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
avg_pool3d_backward_ttlllbb _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad =
  [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , $(bool _ceil_mode)
  , $(bool _count_include_pad)));
  }|]

max_pool2d_with_indices_out_TTtllllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool2d_with_indices_out_TTtllllb _output _indices _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool2d_with_indices_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool2d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool2d_with_indices(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool2d_with_indices_backward_out_Tttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool2d_with_indices_backward_out_Tttllllbt _grad_input _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool2d_with_indices_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool2d_with_indices_backward_ttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool2d_with_indices_backward_ttllllbt _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool2d_with_indices_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool3d_with_indices_out_TTtllllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool3d_with_indices_out_TTtllllb _output _indices _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool3d_with_indices_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_with_indices_tllllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
max_pool3d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool3d_with_indices(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)));
  }|]

max_pool3d_with_indices_backward_out_Tttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool3d_with_indices_backward_out_Tttllllbt _grad_input _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool3d_with_indices_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_pool3d_with_indices_backward_ttllllbt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_pool3d_with_indices_backward_ttllllbt _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool3d_with_indices_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , $(bool _ceil_mode)
  , *$(at::Tensor* _indices)));
  }|]

max_unpool2d_out_Tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
max_unpool2d_out_Tttl _output _self _indices _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(at::IntArrayRef* _output_size)));
  }|]

max_unpool2d_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
max_unpool2d_ttl _self _indices _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(at::IntArrayRef* _output_size)));
  }|]

max_unpool2d_backward_out_Ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
max_unpool2d_backward_out_Ttttl _grad_input _grad_output _self _indices _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(at::IntArrayRef* _output_size)));
  }|]

max_unpool2d_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
max_unpool2d_backward_tttl _grad_output _self _indices _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(at::IntArrayRef* _output_size)));
  }|]

max_unpool3d_out_Tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
max_unpool3d_out_Tttlll _output _self _indices _output_size _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

max_unpool3d_ttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
max_unpool3d_ttlll _self _indices _output_size _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

max_unpool3d_backward_out_Ttttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
max_unpool3d_backward_out_Ttttlll _grad_input _grad_output _self _indices _output_size _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

max_unpool3d_backward_tttlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
max_unpool3d_backward_tttlll _grad_output _self _indices _output_size _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

upsample_linear1d_out_Ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_out_Ttlb _output _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_linear1d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_tlb _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_linear1d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_backward_out_Ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_backward_out_Ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_linear1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_linear1d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_linear1d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_linear1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_out_Ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_out_Ttlb _output _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bilinear2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_tlb _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bilinear2d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_backward_out_Ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_out_Ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bilinear2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bilinear2d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_bilinear2d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bilinear2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_out_Ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_out_Ttlb _output _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bicubic2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_tlb _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bicubic2d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_backward_out_Ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_out_Ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bicubic2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_bicubic2d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_bicubic2d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bicubic2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_out_Ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_out_Ttlb _output _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_trilinear3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_tlb
  :: Ptr Tensor
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_tlb _self _output_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_trilinear3d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_backward_out_Ttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_out_Ttllb _grad_input _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_trilinear3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_trilinear3d_backward_tllb
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CBool
  -> IO (Ptr Tensor)
upsample_trilinear3d_backward_tllb _grad_output _output_size _input_size _align_corners =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_trilinear3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)
  , $(bool _align_corners)));
  }|]

upsample_nearest1d_out_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest1d_out_Ttl _output _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest1d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

upsample_nearest1d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest1d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest1d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

upsample_nearest1d_backward_out_Ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest1d_backward_out_Ttll _grad_input _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest1d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)));
  }|]

upsample_nearest1d_backward_tll
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest1d_backward_tll _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest1d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)));
  }|]

upsample_nearest2d_out_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest2d_out_Ttl _output _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

upsample_nearest2d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest2d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest2d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

upsample_nearest2d_backward_out_Ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_out_Ttll _grad_input _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)));
  }|]

upsample_nearest2d_backward_tll
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest2d_backward_tll _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)));
  }|]

upsample_nearest3d_out_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest3d_out_Ttl _output _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

upsample_nearest3d_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest3d_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest3d(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

upsample_nearest3d_backward_out_Ttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_out_Ttll _grad_input _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)));
  }|]

upsample_nearest3d_backward_tll
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
upsample_nearest3d_backward_tll _grad_output _output_size _input_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _input_size)));
  }|]

sigmoid_backward_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_backward_out_Ttt _grad_input _grad_output _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sigmoid_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

sigmoid_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sigmoid_backward_tt _grad_output _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

tanh_backward_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tanh_backward_out_Ttt _grad_input _grad_output _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tanh_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

tanh_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
tanh_backward_tt _grad_output _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tanh_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)));
  }|]

thnn_conv_transpose2d_out_Tttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_transpose2d_out_Tttltllll _output _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_transpose2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_transpose2d_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_transpose2d_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_transpose2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_transpose2d_forward_out_TTTttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_forward_out_TTTttltllll _output _columns _ones _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_transpose2d_forward_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_forward_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_transpose2d_backward_tttlllllttTTT
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_backward_tttlllllttTTT _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _columns _ones _grad_input _grad_weight _grad_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)));
  }|]

thnn_conv_transpose2d_backward_tttllllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_backward_tttllllltta _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _columns _ones _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_transpose3d_out_Tttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_transpose3d_out_Tttltllll _output _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_transpose3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_transpose3d_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_transpose3d_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_transpose3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_transpose3d_forward_out_TTTttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_forward_out_TTTttltllll _output _finput _fgrad_input _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose3d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_transpose3d_forward_ttltllll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_forward_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose3d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_transpose3d_backward_tttlllllttTTT
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_backward_tttlllllttTTT _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _finput _fgrad_input _grad_input _grad_weight _grad_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)));
  }|]

thnn_conv_transpose3d_backward_tttllllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_backward_tttllllltta _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _finput _fgrad_input _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _output_padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv2d_out_Tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv2d_out_Tttltll _output _self _weight _kernel_size _bias _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

thnn_conv2d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv2d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

thnn_conv2d_forward_out_TTTttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_forward_out_TTTttltll _output _finput _fgrad_input _self _weight _kernel_size _bias _stride _padding =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

thnn_conv2d_forward_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_forward_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

thnn_conv2d_backward_tttlllttTTT
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_backward_tttlllttTTT _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _grad_input _grad_weight _grad_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)));
  }|]

thnn_conv2d_backward_tttllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_backward_tttllltta _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_depthwise2d_out_Tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_out_Tttltlll _output _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_depthwise2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_depthwise2d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_depthwise2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_depthwise2d_forward_out_Tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_forward_out_Tttltlll _output _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_depthwise2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_depthwise2d_forward_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_depthwise2d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_depthwise2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_depthwise2d_backward_tttllllTT
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
thnn_conv_depthwise2d_backward_tttllllTT _grad_output _self _weight _kernel_size _stride _padding _dilation _grad_input _grad_weight =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::thnn_conv_depthwise2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)));
  }|]

thnn_conv_depthwise2d_backward_tttlllla
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr (StdArray CBool 2)
  -> IO (Ptr (Tensor,Tensor))
thnn_conv_depthwise2d_backward_tttlllla _grad_output _self _weight _kernel_size _stride _padding _dilation _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::thnn_conv_depthwise2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(std::array<bool,2>* _output_mask)));
  }|]

thnn_conv3d_out_Tttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv3d_out_Tttltll _output _self _weight _kernel_size _bias _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

thnn_conv3d_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv3d_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

thnn_conv3d_forward_out_TTTttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_forward_out_TTTttltll _output _finput _fgrad_input _self _weight _kernel_size _bias _stride _padding =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv3d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

thnn_conv3d_forward_ttltll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_forward_ttltll _self _weight _kernel_size _bias _stride _padding =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv3d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)));
  }|]

thnn_conv3d_backward_tttlllttTTT
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_backward_tttlllttTTT _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _grad_input _grad_weight _grad_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)));
  }|]

thnn_conv3d_backward_tttllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_backward_tttllltta _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::Tensor* _finput)
  , *$(at::Tensor* _fgrad_input)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_dilated2d_out_Tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_dilated2d_out_Tttltlll _output _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_dilated2d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_dilated2d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_dilated2d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_dilated2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_dilated2d_forward_out_TTTttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_forward_out_TTTttltlll _output _columns _ones _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_dilated2d_forward_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_dilated2d_backward_tttllllttTTT
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_backward_tttllllttTTT _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _grad_input _grad_weight _grad_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)));
  }|]

thnn_conv_dilated2d_backward_tttlllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_backward_tttlllltta _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_conv_dilated3d_out_Tttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_dilated3d_out_Tttltlll _output _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_dilated3d_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_dilated3d_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_conv_dilated3d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_dilated3d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_dilated3d_forward_out_TTTttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_forward_out_TTTttltlll _output _columns _ones _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated3d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_dilated3d_forward_ttltlll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated3d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::Tensor* _bias)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)));
  }|]

thnn_conv_dilated3d_backward_tttllllttTTT
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_backward_tttllllttTTT _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _grad_input _grad_weight _grad_bias =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_weight)
  , *$(at::Tensor* _grad_bias)));
  }|]

thnn_conv_dilated3d_backward_tttlllltta
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_backward_tttlllltta _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::Tensor* _columns)
  , *$(at::Tensor* _ones)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

thnn_col2im_tlllll
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_col2im_tlllll _self _output_size _kernel_size _dilation _padding _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_col2im(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _stride)));
  }|]

thnn_col2im_backward_tllll
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_col2im_backward_tllll _grad_output _kernel_size _dilation _padding _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_col2im_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _stride)));
  }|]

thnn_im2col_tllll
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_im2col_tllll _self _kernel_size _dilation _padding _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_im2col(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _stride)));
  }|]

thnn_im2col_backward_tlllll
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
thnn_im2col_backward_tlllll _grad_output _input_size _kernel_size _dilation _padding _stride =
  [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_im2col_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::IntArrayRef* _input_size)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _dilation)
  , *$(at::IntArrayRef* _padding)
  , *$(at::IntArrayRef* _stride)));
  }|]

