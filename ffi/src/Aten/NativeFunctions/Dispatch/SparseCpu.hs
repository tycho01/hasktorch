
-- generated by using spec/native_functions_modified.yaml and deps/libtorch/include/ATen/NativeFunctions.h

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Aten.NativeFunctions.Dispatch.SparseCpu where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.NativeFunctions.Type

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"


empty_sparse_lo
  :: Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_sparse_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::empty_sparse(
    *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

log1p_sparse__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log1p_sparse__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log1p_sparse_(
    *$(at::Tensor* _self)));
  }|]

log1p_out_sparse_out_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log1p_out_sparse_out_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log1p_out_sparse_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

narrow_copy_sparse_tiii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
narrow_copy_sparse_tiii _self _dim _start _length =
  [C.block| at::Tensor* { return new at::Tensor(at::native::narrow_copy_sparse(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(int _start)
  , $(int _length)));
  }|]

add_out_sparse_cpu_out_Ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_out_sparse_cpu_out_Ttts _out _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::add_out_sparse_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _alpha)));
  }|]

div_out_sparse_zerodim_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
div_out_sparse_zerodim_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::div_out_sparse_zerodim_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

div_out_sparse_scalar_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
div_out_sparse_scalar_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::div_out_sparse_scalar_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

mul_out_sparse_cpu_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul_out_sparse_cpu_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mul_out_sparse_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul_out_sparse_zerodim_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mul_out_sparse_zerodim_out_Ttt _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mul_out_sparse_zerodim_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

mul_out_sparse_scalar_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
mul_out_sparse_scalar_out_Tts _out _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::mul_out_sparse_scalar_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

_sspaddmm_out_cpu_out_Ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sspaddmm_out_cpu_out_Ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sspaddmm_out_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

norm_sparse_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
norm_sparse_ts _self _p =
  [C.block| at::Tensor* { return new at::Tensor(at::native::norm_sparse(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)));
  }|]

_sparse_sum_backward_cpu_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
_sparse_sum_backward_cpu_ttl _grad _self _dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum_backward_cpu(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dim)));
  }|]

clone_sparse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
clone_sparse_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::clone_sparse(
    *$(at::Tensor* _self)));
  }|]

resize_as_sparse__Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
resize_as_sparse__Tt _self _the_template =
  [C.block| at::Tensor* { return new at::Tensor(at::native::resize_as_sparse_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _the_template)));
  }|]

pow_out_sparse_scalar_out_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_out_sparse_scalar_out_Tts _out _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow_out_sparse_scalar_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

pow_sparse_scalar_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_sparse_scalar_ts _self _exponent =
  [C.block| at::Tensor* { return new at::Tensor(at::native::pow_sparse_scalar(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

zero_sparse__T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
zero_sparse__T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::zero_sparse_(
    *$(at::Tensor* _self)));
  }|]

new_with_dims_sparse_iilo
  :: CInt
  -> CInt
  -> Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
new_with_dims_sparse_iilo _sparse_dim _dense_dim _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::new_with_dims_sparse(
    $(int _sparse_dim)
  , $(int _dense_dim)
  , *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

new_with_dims_and_tensor_sparse_iiltto
  :: CInt
  -> CInt
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
new_with_dims_and_tensor_sparse_iiltto _sparse_dim _dense_dim _size _indices _values _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::new_with_dims_and_tensor_sparse(
    $(int _sparse_dim)
  , $(int _dense_dim)
  , *$(at::IntArrayRef* _size)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _values)
  , *$(at::TensorOptions* _options)));
  }|]

sparse_resize__Tlii
  :: Ptr Tensor
  -> Ptr IntList
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
sparse_resize__Tlii _self _size _sparse_dim _dense_dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_resize_(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)
  , $(int _sparse_dim)
  , $(int _dense_dim)));
  }|]

sparse_resize_and_clear__Tlii
  :: Ptr Tensor
  -> Ptr IntList
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
sparse_resize_and_clear__Tlii _self _size _sparse_dim _dense_dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_resize_and_clear_(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)
  , $(int _sparse_dim)
  , $(int _dense_dim)));
  }|]

sparse_to_dense_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sparse_to_dense_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_to_dense(
    *$(at::Tensor* _self)));
  }|]

sparse_dim_sparse_t
  :: Ptr Tensor
  -> IO (CInt)
sparse_dim_sparse_t _self =
  [C.block| int { return (at::native::sparse_dim_sparse(
    *$(at::Tensor* _self)));
  }|]

dense_dim_sparse_t
  :: Ptr Tensor
  -> IO (CInt)
dense_dim_sparse_t _self =
  [C.block| int { return (at::native::dense_dim_sparse(
    *$(at::Tensor* _self)));
  }|]

_nnz_sparse_t
  :: Ptr Tensor
  -> IO (CInt)
_nnz_sparse_t _self =
  [C.block| int { return (at::native::_nnz_sparse(
    *$(at::Tensor* _self)));
  }|]

coalesce_sparse_cpu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
coalesce_sparse_cpu_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::coalesce_sparse_cpu(
    *$(at::Tensor* _self)));
  }|]

is_coalesced_sparse_t
  :: Ptr Tensor
  -> IO (CBool)
is_coalesced_sparse_t _self =
  [C.block| bool { return (at::native::is_coalesced_sparse(
    *$(at::Tensor* _self)));
  }|]

_indices_sparse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_indices_sparse_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_indices_sparse(
    *$(at::Tensor* _self)));
  }|]

_values_sparse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_values_sparse_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_values_sparse(
    *$(at::Tensor* _self)));
  }|]

_coalesced_sparse__Tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_coalesced_sparse__Tb _self _coalesced =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_coalesced_sparse_(
    *$(at::Tensor* _self)
  , $(bool _coalesced)));
  }|]

indices_sparse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
indices_sparse_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::indices_sparse(
    *$(at::Tensor* _self)));
  }|]

values_sparse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
values_sparse_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::values_sparse(
    *$(at::Tensor* _self)));
  }|]

hspmm_out_sparse_cpu_out_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hspmm_out_sparse_cpu_out_Ttt _out _mat1 _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hspmm_out_sparse_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

hspmm_sparse_cpu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hspmm_sparse_cpu_tt _mat1 _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hspmm_sparse_cpu(
    *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)));
  }|]

copy_sparse__Ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
copy_sparse__Ttb _self _src _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::copy_sparse_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)
  , $(bool _non_blocking)));
  }|]

