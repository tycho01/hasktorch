
-- generated by using spec/native_functions_modified.yaml and deps/libtorch/include/ATen/NativeFunctions.h

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Aten.NativeFunctions.Dispatch.Cpu where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.NativeFunctions.Type

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"


_abs__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_abs__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_abs__cpu(
    *$(at::Tensor* _self)));
  }|]

_acos__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_acos__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_acos__cpu(
    *$(at::Tensor* _self)));
  }|]

arange_cpu_out_Tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
arange_cpu_out_Tsss _out _start _end _step =
  [C.block| at::Tensor* { return new at::Tensor(at::native::arange_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

_asin__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_asin__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_asin__cpu(
    *$(at::Tensor* _self)));
  }|]

_asin_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_asin_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_asin_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_atan__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_atan__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_atan__cpu(
    *$(at::Tensor* _self)));
  }|]

_atan_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_atan_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_atan_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

baddbmm_cpu_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_cpu_tttss _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm_cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

baddbmm__cpu_Tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm__cpu_Tttss _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm__cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

baddbmm_out_cpu_Ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
baddbmm_out_cpu_Ttttss _out _self _batch1 _batch2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _batch1)
  , *$(at::Tensor* _batch2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

bernoulli_tensor_cpu__Ttp
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_tensor_cpu__Ttp _self _p _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli_tensor_cpu_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _p)
  , $(at::Generator * _generator)));
  }|]

bernoulli_scalar_cpu__Tfp
  :: Ptr Tensor
  -> CFloat
  -> Ptr Generator
  -> IO (Ptr Tensor)
bernoulli_scalar_cpu__Tfp _self _p _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli_scalar_cpu_(
    *$(at::Tensor* _self)
  , $(float _p)
  , $(at::Generator * _generator)));
  }|]

_bincount_cpu_tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
_bincount_cpu_tti _self _weights _minlength =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_bincount_cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weights)
  , $(int _minlength)));
  }|]

bmm_cpu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bmm_cpu_tt _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bmm_cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

bmm_out_cpu_Ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
bmm_out_cpu_Ttt _out _self _mat2 =
  [C.block| at::Tensor* { return new at::Tensor(at::native::bmm_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat2)));
  }|]

_ceil__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_ceil__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_ceil__cpu(
    *$(at::Tensor* _self)));
  }|]

_ceil_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_ceil_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_ceil_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_clamp__cpu_Tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_clamp__cpu_Tss _self _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp__cpu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

_clamp_out_cpu_Ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_clamp_out_cpu_Ttss _out _self _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

_clamp_max__cpu_Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_clamp_max__cpu_Ts _self _max =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_max__cpu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

_clamp_max_out_cpu_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_clamp_max_out_cpu_Tts _out _self _max =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_max_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _max)));
  }|]

_clamp_min__cpu_Ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_clamp_min__cpu_Ts _self _min =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_min__cpu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

_clamp_min_out_cpu_Tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_clamp_min_out_cpu_Tts _out _self _min =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_min_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min)));
  }|]

_s_copy__cpu_Ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_s_copy__cpu_Ttb _self _src _non_blocking =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_s_copy__cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)
  , $(bool _non_blocking)));
  }|]

_copy_same_type__cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO ()
_copy_same_type__cpu_Tt _self _src =
  [C.block| void {  (at::native::_copy_same_type__cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _src)));
  }|]

_cos__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cos__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cos__cpu(
    *$(at::Tensor* _self)));
  }|]

_cos_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_cos_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cos_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_cosh__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_cosh__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cosh__cpu(
    *$(at::Tensor* _self)));
  }|]

_cosh_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_cosh_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cosh_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

ctc_loss_cpu_ttllib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
ctc_loss_cpu_ttllib _log_probs _targets _input_lengths _target_lengths _blank _zero_infinity =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::ctc_loss_cpu(
    *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::IntArrayRef* _input_lengths)
  , *$(at::IntArrayRef* _target_lengths)
  , $(int _blank)
  , $(bool _zero_infinity)));
  }|]

ctc_loss_backward_cpu_tttllttib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
ctc_loss_backward_cpu_tttllttib _grad _log_probs _targets _input_lengths _target_lengths _neg_log_likelihood _log_alpha _blank _zero_infinity =
  [C.block| at::Tensor* { return new at::Tensor(at::native::ctc_loss_backward_cpu(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _log_probs)
  , *$(at::Tensor* _targets)
  , *$(at::IntArrayRef* _input_lengths)
  , *$(at::IntArrayRef* _target_lengths)
  , *$(at::Tensor* _neg_log_likelihood)
  , *$(at::Tensor* _log_alpha)
  , $(int _blank)
  , $(bool _zero_infinity)));
  }|]

embedding_dense_backward_cpu_ttiib
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
embedding_dense_backward_cpu_ttiib _grad _indices _num_weights _padding_idx _scale_grad_by_freq =
  [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_dense_backward_cpu(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , $(int _num_weights)
  , $(int _padding_idx)
  , $(bool _scale_grad_by_freq)));
  }|]

embedding_renorm_cpu__Ttff
  :: Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> CFloat
  -> IO (Ptr Tensor)
embedding_renorm_cpu__Ttff _self _indices _max_norm _norm_type =
  [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_renorm_cpu_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)
  , $(float _max_norm)
  , $(float _norm_type)));
  }|]

_embedding_bag_cpu_tttbib
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CInt
  -> CBool
  -> IO (Ptr (Tensor,Tensor,Tensor,Tensor))
_embedding_bag_cpu_tttbib _weight _indices _offsets _scale_grad_by_freq _mode _sparse =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::native::_embedding_bag_cpu(
    *$(at::Tensor* _weight)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , $(bool _scale_grad_by_freq)
  , $(int _mode)
  , $(bool _sparse)));
  }|]

_embedding_bag_dense_backward_cpu_ttttttibi
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CBool
  -> CInt
  -> IO (Ptr Tensor)
_embedding_bag_dense_backward_cpu_ttttttibi _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_embedding_bag_dense_backward_cpu(
    *$(at::Tensor* _grad)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _offsets)
  , *$(at::Tensor* _offset2bag)
  , *$(at::Tensor* _bag_size)
  , *$(at::Tensor* _maximum_indices)
  , $(int _num_weights)
  , $(bool _scale_grad_by_freq)
  , $(int _mode)));
  }|]

empty_cpu_lo
  :: Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_cpu_lo _size _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::empty_cpu(
    *$(at::IntArrayRef* _size)
  , *$(at::TensorOptions* _options)));
  }|]

resize_cpu__Tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
resize_cpu__Tl _self _size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::resize_cpu_(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _size)));
  }|]

empty_strided_cpu_llo
  :: Ptr IntList
  -> Ptr IntList
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
empty_strided_cpu_llo _size _stride _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::empty_strided_cpu(
    *$(at::IntArrayRef* _size)
  , *$(at::IntArrayRef* _stride)
  , *$(at::TensorOptions* _options)));
  }|]

_erf__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_erf__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_erf__cpu(
    *$(at::Tensor* _self)));
  }|]

_erf_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_erf_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_erf_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_erfc__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_erfc__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_erfc__cpu(
    *$(at::Tensor* _self)));
  }|]

_erfc_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_erfc_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_erfc_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_exp__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_exp__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_exp__cpu(
    *$(at::Tensor* _self)));
  }|]

_exp_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_exp_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_exp_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_expm1__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_expm1__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_expm1__cpu(
    *$(at::Tensor* _self)));
  }|]

_expm1_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_expm1_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_expm1_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

eye_out_cpu_Ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
eye_out_cpu_Ti _out _n =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eye_out_cpu(
    *$(at::Tensor* _out)
  , $(int _n)));
  }|]

eye_out_cpu_Tii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
eye_out_cpu_Tii _out _n _m =
  [C.block| at::Tensor* { return new at::Tensor(at::native::eye_out_cpu(
    *$(at::Tensor* _out)
  , $(int _n)
  , $(int _m)));
  }|]

_floor__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_floor__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_floor__cpu(
    *$(at::Tensor* _self)));
  }|]

_floor_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_floor_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_floor_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

grid_sampler_2d_cpu_ttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
grid_sampler_2d_cpu_ttii _input _grid _interpolation_mode _padding_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::native::grid_sampler_2d_cpu(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int _interpolation_mode)
  , $(int _padding_mode)));
  }|]

grid_sampler_2d_backward_cpu_tttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
grid_sampler_2d_backward_cpu_tttii _grad_output _input _grid _interpolation_mode _padding_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::grid_sampler_2d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int _interpolation_mode)
  , $(int _padding_mode)));
  }|]

grid_sampler_3d_cpu_ttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
grid_sampler_3d_cpu_ttii _input _grid _interpolation_mode _padding_mode =
  [C.block| at::Tensor* { return new at::Tensor(at::native::grid_sampler_3d_cpu(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int _interpolation_mode)
  , $(int _padding_mode)));
  }|]

grid_sampler_3d_backward_cpu_tttii
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> CInt
  -> IO (Ptr (Tensor,Tensor))
grid_sampler_3d_backward_cpu_tttii _grad_output _input _grid _interpolation_mode _padding_mode =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::grid_sampler_3d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _grid)
  , $(int _interpolation_mode)
  , $(int _padding_mode)));
  }|]

_gesv_helper_cpu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
_gesv_helper_cpu_tt _self _A =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_gesv_helper_cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)));
  }|]

_fft_mkl_tibbblbbl
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> CBool
  -> CBool
  -> Ptr IntList
  -> CBool
  -> CBool
  -> Ptr IntList
  -> IO (Ptr Tensor)
_fft_mkl_tibbblbbl _self _signal_ndim _complex_input _complex_output _inverse _checked_signal_sizes _normalized _onesided _output_sizes =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_fft_mkl(
    *$(at::Tensor* _self)
  , $(int _signal_ndim)
  , $(bool _complex_input)
  , $(bool _complex_output)
  , $(bool _inverse)
  , *$(at::IntArrayRef* _checked_signal_sizes)
  , $(bool _normalized)
  , $(bool _onesided)
  , *$(at::IntArrayRef* _output_sizes)));
  }|]

_inverse_helper_cpu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_inverse_helper_cpu_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_inverse_helper_cpu(
    *$(at::Tensor* _self)));
  }|]

kl_div_backward_cpu_ttti
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
kl_div_backward_cpu_ttti _grad_output _self _target _reduction =
  [C.block| at::Tensor* { return new at::Tensor(at::native::kl_div_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int _reduction)));
  }|]

linspace_cpu_out_Tssi
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CInt
  -> IO (Ptr Tensor)
linspace_cpu_out_Tssi _out _start _end _steps =
  [C.block| at::Tensor* { return new at::Tensor(at::native::linspace_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int _steps)));
  }|]

_log__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_log__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_log__cpu(
    *$(at::Tensor* _self)));
  }|]

_log_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_log_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_log_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_log10__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_log10__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_log10__cpu(
    *$(at::Tensor* _self)));
  }|]

_log10_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_log10_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_log10_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_log1p__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_log1p__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_log1p__cpu(
    *$(at::Tensor* _self)));
  }|]

_log1p_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_log1p_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_log1p_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_log2__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_log2__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_log2__cpu(
    *$(at::Tensor* _self)));
  }|]

_log2_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_log2_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_log2_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

logspace_cpu_out_Tssi
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CInt
  -> IO (Ptr Tensor)
logspace_cpu_out_Tssi _out _start _end _steps =
  [C.block| at::Tensor* { return new at::Tensor(at::native::logspace_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , $(int _steps)));
  }|]

log_softmax_cpu_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
log_softmax_cpu_tib _self _dim _half_to_float =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax_cpu(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _half_to_float)));
  }|]

log_softmax_backward_cpu_ttit
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_softmax_backward_cpu_ttit _grad_output _output _dim _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)
  , $(int _dim)
  , *$(at::Tensor* _self)));
  }|]

narrow_copy_dense_tiii
  :: Ptr Tensor
  -> CInt
  -> CInt
  -> CInt
  -> IO (Ptr Tensor)
narrow_copy_dense_tiii _self _dim _start _length =
  [C.block| at::Tensor* { return new at::Tensor(at::native::narrow_copy_dense(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(int _start)
  , $(int _length)));
  }|]

batch_norm_cpu_tttttbff
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CFloat
  -> CFloat
  -> IO (Ptr (Tensor,Tensor,Tensor))
batch_norm_cpu_tttttbff _input _weight _bias _running_mean _running_var _training _momentum _eps =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::batch_norm_cpu(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _bias)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(bool _training)
  , $(float _momentum)
  , $(float _eps)));
  }|]

batch_norm_backward_cpu_tttttttbfa
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CFloat
  -> Ptr (StdArray CBool 3)
  -> IO (Ptr (Tensor,Tensor,Tensor))
batch_norm_backward_cpu_tttttttbfa _grad_out _input _weight _running_mean _running_var _save_mean _save_invstd _train _eps _output_mask =
  [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::batch_norm_backward_cpu(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _input)
  , *$(at::Tensor* _weight)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , *$(at::Tensor* _save_mean)
  , *$(at::Tensor* _save_invstd)
  , $(bool _train)
  , $(float _eps)
  , *$(std::array<bool,3>* _output_mask)));
  }|]

batch_norm_update_stats_cpu_tttf
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CFloat
  -> IO (Ptr (Tensor,Tensor))
batch_norm_update_stats_cpu_tttf _input _running_mean _running_var _momentum =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::batch_norm_update_stats_cpu(
    *$(at::Tensor* _input)
  , *$(at::Tensor* _running_mean)
  , *$(at::Tensor* _running_var)
  , $(float _momentum)));
  }|]

randperm_out_cpu_Tip
  :: Ptr Tensor
  -> CInt
  -> Ptr Generator
  -> IO (Ptr Tensor)
randperm_out_cpu_Tip _out _n _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::randperm_out_cpu(
    *$(at::Tensor* _out)
  , $(int _n)
  , $(at::Generator * _generator)));
  }|]

range_cpu_out_Tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
range_cpu_out_Tsss _out _start _end _step =
  [C.block| at::Tensor* { return new at::Tensor(at::native::range_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _start)
  , *$(at::Scalar* _end)
  , *$(at::Scalar* _step)));
  }|]

_round__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_round__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_round__cpu(
    *$(at::Tensor* _self)));
  }|]

_round_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_round_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_round_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

prelu_cpu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
prelu_cpu_tt _self _weight =
  [C.block| at::Tensor* { return new at::Tensor(at::native::prelu_cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)));
  }|]

prelu_backward_cpu_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
prelu_backward_cpu_ttt _grad_output _self _weight =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::prelu_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _weight)));
  }|]

hardshrink_cpu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardshrink_cpu_ts _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hardshrink_cpu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

hardshrink_backward_cpu_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardshrink_backward_cpu_tts _grad_out _self _lambd =
  [C.block| at::Tensor* { return new at::Tensor(at::native::hardshrink_backward_cpu(
    *$(at::Tensor* _grad_out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

_rsqrt__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_rsqrt__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_rsqrt__cpu(
    *$(at::Tensor* _self)));
  }|]

_rsqrt_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_rsqrt_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_rsqrt_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_sigmoid__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_sigmoid__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sigmoid__cpu(
    *$(at::Tensor* _self)));
  }|]

_sigmoid_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sigmoid_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sigmoid_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_sin__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_sin__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sin__cpu(
    *$(at::Tensor* _self)));
  }|]

_sin_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sin_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sin_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_sinh__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_sinh__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sinh__cpu(
    *$(at::Tensor* _self)));
  }|]

_sinh_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sinh_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sinh_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

softmax_cpu_tib
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> IO (Ptr Tensor)
softmax_cpu_tib _self _dim _half_to_float =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softmax_cpu(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _half_to_float)));
  }|]

softmax_backward_cpu_ttit
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softmax_backward_cpu_ttit _grad_output _output _dim _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::softmax_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _output)
  , $(int _dim)
  , *$(at::Tensor* _self)));
  }|]

add_out_dense_sparse_cpu_Ttrs
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr SparseTensorRef
  -> Ptr Scalar
  -> IO (Ptr Tensor)
add_out_dense_sparse_cpu_Ttrs _out _self _other _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::add_out_dense_sparse_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::SparseTensorRef* _other)
  , *$(at::Scalar* _alpha)));
  }|]

_sspaddmm_out_only_sparse_Ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_sspaddmm_out_only_sparse_Ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sspaddmm_out_only_sparse(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

_sqrt__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_sqrt__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sqrt__cpu(
    *$(at::Tensor* _self)));
  }|]

_sqrt_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_sqrt_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_sqrt_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_tan__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_tan__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_tan__cpu(
    *$(at::Tensor* _self)));
  }|]

_tan_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_tan_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_tan_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_tanh__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_tanh__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_tanh__cpu(
    *$(at::Tensor* _self)));
  }|]

_tanh_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_tanh_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_tanh_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

flip_cpu_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
flip_cpu_tl _self _dims =
  [C.block| at::Tensor* { return new at::Tensor(at::native::flip_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _dims)));
  }|]

roll_cpu_tll
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> IO (Ptr Tensor)
roll_cpu_tll _self _shifts _dims =
  [C.block| at::Tensor* { return new at::Tensor(at::native::roll_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _shifts)
  , *$(at::IntArrayRef* _dims)));
  }|]

_trunc__cpu_T
  :: Ptr Tensor
  -> IO (Ptr Tensor)
_trunc__cpu_T _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_trunc__cpu(
    *$(at::Tensor* _self)));
  }|]

_trunc_out_cpu_Tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_trunc_out_cpu_Tt _out _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_trunc_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

_unique_cpu_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
_unique_cpu_tbb _self _sorted _return_inverse =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_unique_cpu(
    *$(at::Tensor* _self)
  , $(bool _sorted)
  , $(bool _return_inverse)));
  }|]

_unique_dim_cpu_tibb
  :: Ptr Tensor
  -> CInt
  -> CBool
  -> CBool
  -> IO (Ptr (Tensor,Tensor))
_unique_dim_cpu_tibb _self _dim _sorted _return_inverse =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_unique_dim_cpu(
    *$(at::Tensor* _self)
  , $(int _dim)
  , $(bool _sorted)
  , $(bool _return_inverse)));
  }|]

_s_where_cpu_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_s_where_cpu_ttt _condition _self _other =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_s_where_cpu(
    *$(at::Tensor* _condition)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

_standard_gamma_grad_cpu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_standard_gamma_grad_cpu_tt _self _output =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_standard_gamma_grad_cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _output)));
  }|]

_s_gamma_cpu_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
_s_gamma_cpu_tp _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_s_gamma_cpu(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

_s_poisson_cpu_tp
  :: Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
_s_poisson_cpu_tp _self _generator =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_s_poisson_cpu(
    *$(at::Tensor* _self)
  , $(at::Generator * _generator)));
  }|]

s_addmm_out_sparse_dense_cpu_Ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
s_addmm_out_sparse_dense_cpu_Ttttss _out _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_out_sparse_dense_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

s_addmm_sparse_dense_cpu_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
s_addmm_sparse_dense_cpu_tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_sparse_dense_cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

s_addmm_sparse_dense_cpu__Tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
s_addmm_sparse_dense_cpu__Tttss _self _mat1 _mat2 _beta _alpha =
  [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_sparse_dense_cpu_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _mat1)
  , *$(at::Tensor* _mat2)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _alpha)));
  }|]

sparse_mask_cpu_tr
  :: Ptr Tensor
  -> Ptr SparseTensorRef
  -> IO (Ptr Tensor)
sparse_mask_cpu_tr _self _mask =
  [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_mask_cpu(
    *$(at::Tensor* _self)
  , *$(at::SparseTensorRef* _mask)));
  }|]

sparse_dim_sparse_t
  :: Ptr Tensor
  -> IO (CInt)
sparse_dim_sparse_t _self =
  [C.block| int { return (at::native::sparse_dim_sparse(
    *$(at::Tensor* _self)));
  }|]

dense_dim_sparse_t
  :: Ptr Tensor
  -> IO (CInt)
dense_dim_sparse_t _self =
  [C.block| int { return (at::native::dense_dim_sparse(
    *$(at::Tensor* _self)));
  }|]

dense_to_sparse_ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
dense_to_sparse_ti _self _sparse_dim =
  [C.block| at::Tensor* { return new at::Tensor(at::native::dense_to_sparse(
    *$(at::Tensor* _self)
  , $(int _sparse_dim)));
  }|]

dense_to_sparse_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
dense_to_sparse_t _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::dense_to_sparse(
    *$(at::Tensor* _self)));
  }|]

_local_scalar_dense_cpu_t
  :: Ptr Tensor
  -> IO (Ptr Scalar)
_local_scalar_dense_cpu_t _self =
  [C.block| at::Scalar* { return new at::Scalar(at::native::_local_scalar_dense_cpu(
    *$(at::Tensor* _self)));
  }|]

tril_cpu__Ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
tril_cpu__Ti _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tril_cpu_(
    *$(at::Tensor* _self)
  , $(int _diagonal)));
  }|]

triu_cpu__Ti
  :: Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
triu_cpu__Ti _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::native::triu_cpu_(
    *$(at::Tensor* _self)
  , $(int _diagonal)));
  }|]

triu_cpu_out_Tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
triu_cpu_out_Tti _out _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::native::triu_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _diagonal)));
  }|]

tril_cpu_out_Tti
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> IO (Ptr Tensor)
tril_cpu_out_Tti _out _self _diagonal =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tril_cpu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _diagonal)));
  }|]

tril_indices_cpu_iiio
  :: CInt
  -> CInt
  -> CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
tril_indices_cpu_iiio _row _col _offset _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::tril_indices_cpu(
    $(int _row)
  , $(int _col)
  , $(int _offset)
  , *$(at::TensorOptions* _options)));
  }|]

triu_indices_cpu_iiio
  :: CInt
  -> CInt
  -> CInt
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
triu_indices_cpu_iiio _row _col _offset _options =
  [C.block| at::Tensor* { return new at::Tensor(at::native::triu_indices_cpu(
    $(int _row)
  , $(int _col)
  , $(int _offset)
  , *$(at::TensorOptions* _options)));
  }|]

_cholesky_helper_cpu_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cholesky_helper_cpu_tb _self _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cholesky_helper_cpu(
    *$(at::Tensor* _self)
  , $(bool _upper)));
  }|]

_cholesky_solve_helper_cpu_ttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
_cholesky_solve_helper_cpu_ttb _self _A _upper =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_cholesky_solve_helper_cpu(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _A)
  , $(bool _upper)));
  }|]

_histc_out_cpu_Ttiss
  :: Ptr Tensor
  -> Ptr Tensor
  -> CInt
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_histc_out_cpu_Ttiss _out _self _bins _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_histc_out_cpu(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int _bins)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

_histc_cpu_tiss
  :: Ptr Tensor
  -> CInt
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
_histc_cpu_tiss _self _bins _min _max =
  [C.block| at::Tensor* { return new at::Tensor(at::native::_histc_cpu(
    *$(at::Tensor* _self)
  , $(int _bins)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

adaptive_avg_pool2d_out_cpu_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_out_cpu_Ttl _output _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_out_cpu(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_avg_pool2d_cpu_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_cpu_tl _self _output_size =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _output_size)));
  }|]

adaptive_avg_pool2d_backward_cpu_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_backward_cpu_tt _grad_output _self =
  [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

fractional_max_pool2d_out_cpu_TTtllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
fractional_max_pool2d_out_cpu_TTtllt _output _indices _self _kernel_size _output_size _random_samples =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool2d_out_cpu(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool2d_cpu_tllt
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
fractional_max_pool2d_cpu_tllt _self _kernel_size _output_size _random_samples =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool2d_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool2d_backward_out_cpu_Tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool2d_backward_out_cpu_Tttllt _grad_input _grad_output _self _kernel_size _output_size _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool2d_backward_out_cpu(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool2d_backward_cpu_ttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool2d_backward_cpu_ttllt _grad_output _self _kernel_size _output_size _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool2d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool3d_out_cpu_TTtllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
fractional_max_pool3d_out_cpu_TTtllt _output _indices _self _kernel_size _output_size _random_samples =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool3d_out_cpu(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool3d_cpu_tllt
  :: Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> IO (Ptr (Tensor,Tensor))
fractional_max_pool3d_cpu_tllt _self _kernel_size _output_size _random_samples =
  [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool3d_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::Tensor* _random_samples)));
  }|]

fractional_max_pool3d_backward_out_cpu_Tttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool3d_backward_out_cpu_Tttllt _grad_input _grad_output _self _kernel_size _output_size _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool3d_backward_out_cpu(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

fractional_max_pool3d_backward_cpu_ttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> Ptr IntList
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fractional_max_pool3d_backward_cpu_ttllt _grad_output _self _kernel_size _output_size _indices =
  [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool3d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _kernel_size)
  , *$(at::IntArrayRef* _output_size)
  , *$(at::Tensor* _indices)));
  }|]

reflection_pad1d_out_cpu_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reflection_pad1d_out_cpu_Ttl _output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_out_cpu(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

reflection_pad1d_cpu_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reflection_pad1d_cpu_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

reflection_pad1d_backward_out_cpu_Tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reflection_pad1d_backward_out_cpu_Tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_backward_out_cpu(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

reflection_pad1d_backward_cpu_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reflection_pad1d_backward_cpu_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

reflection_pad2d_out_cpu_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reflection_pad2d_out_cpu_Ttl _output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_out_cpu(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

reflection_pad2d_cpu_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reflection_pad2d_cpu_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

reflection_pad2d_backward_out_cpu_Tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reflection_pad2d_backward_out_cpu_Tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_backward_out_cpu(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

reflection_pad2d_backward_cpu_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
reflection_pad2d_backward_cpu_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad1d_out_cpu_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad1d_out_cpu_Ttl _output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_out_cpu(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad1d_cpu_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad1d_cpu_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad1d_backward_out_cpu_Tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad1d_backward_out_cpu_Tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_backward_out_cpu(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad1d_backward_cpu_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad1d_backward_cpu_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad2d_out_cpu_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad2d_out_cpu_Ttl _output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_out_cpu(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad2d_cpu_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad2d_cpu_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad2d_backward_out_cpu_Tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad2d_backward_out_cpu_Tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_backward_out_cpu(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad2d_backward_cpu_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad2d_backward_cpu_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad3d_out_cpu_Ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad3d_out_cpu_Ttl _output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_out_cpu(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad3d_cpu_tl
  :: Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad3d_cpu_tl _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_cpu(
    *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad3d_backward_out_cpu_Tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad3d_backward_out_cpu_Tttl _grad_input _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_backward_out_cpu(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

replication_pad3d_backward_cpu_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntList
  -> IO (Ptr Tensor)
replication_pad3d_backward_cpu_ttl _grad_output _self _padding =
  [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_backward_cpu(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::IntArrayRef* _padding)));
  }|]

