
-- generated by using spec/native_functions_modified.yaml and deps/libtorch/include/ATen/NativeFunctions.h

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module NativeFunctions where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign

data Scalar
data Tensor
data TensorOptions
data TensorList
data IndexTensor
data IntList
data StdArray a b
data ScalarType
data SparseTensorRef

data StdString
data Generator
data Device
data Storage

C.context $ C.cppCtx <> mempty {
    C.ctxTypesTable = Map.fromList [
        (C.TypeName "at::Scalar", [t|Scalar|])
      , (C.TypeName "at::Tensor", [t|Tensor|])
      , (C.TypeName "at::TensorOptions", [t|TensorOptions|])
      , (C.TypeName "at::TensorList", [t|TensorList|])
      , (C.TypeName "at::IndexTensor", [t|IndexTensor|])
      , (C.TypeName "at::IntArrayRef", [t|IntList|])
      , (C.TypeName "at::ScalarType", [t|ScalarType|])
      , (C.TypeName "at::SparseTensorRef", [t|SparseTensorRef|])
      , (C.TypeName "at::Storage", [t|Storage|])
      , (C.TypeName "at::Device", [t|Device|])
      , (C.TypeName "at::Generator", [t|Generator|])
      , (C.TypeName "std::string", [t|StdString|])
      , (C.TypeName "std::array<bool,2>", [t|StdArray CBool 2|])
      , (C.TypeName "std::array<bool,3>", [t|StdArray CBool 3|])
      , (C.TypeName "std::array<bool,4>", [t|StdArray CBool 4|])
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor>", [t|(Tensor,Tensor)|])
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor>", [t|(Tensor,Tensor,Tensor)|])
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>", [t|(Tensor,Tensor,Tensor,Tensor)|])
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>", [t|(Tensor,Tensor,Tensor,Tensor,Tensor)|])
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::TensorList>", [t|(Tensor,Tensor,Tensor,TensorList)|])
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,double,int64_t>", [t|(Tensor,Tensor,CDouble,Int64)|])
    ]
}

C.include "<ATen/ATen.h>"

_cast_Byte_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cast_Byte_tb _self _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Byte(*$(at::Tensor* _self), $(bool _non_blocking))); }|]

_cast_Char_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cast_Char_tb _self _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Char(*$(at::Tensor* _self), $(bool _non_blocking))); }|]

_cast_Double_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cast_Double_tb _self _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Double(*$(at::Tensor* _self), $(bool _non_blocking))); }|]

_cast_Float_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cast_Float_tb _self _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Float(*$(at::Tensor* _self), $(bool _non_blocking))); }|]

_cast_Int_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cast_Int_tb _self _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Int(*$(at::Tensor* _self), $(bool _non_blocking))); }|]

_cast_Long_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cast_Long_tb _self _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Long(*$(at::Tensor* _self), $(bool _non_blocking))); }|]

_cast_Short_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cast_Short_tb _self _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Short(*$(at::Tensor* _self), $(bool _non_blocking))); }|]

_cast_Half_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cast_Half_tb _self _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_cast_Half(*$(at::Tensor* _self), $(bool _non_blocking))); }|]

_cudnn_ctc_loss_ttllibb :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
_cudnn_ctc_loss_ttllibb _log_probs _targets _input_lengths _target_lengths _blank _deterministic _zero_infinity = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_cudnn_ctc_loss(*$(at::Tensor* _log_probs), *$(at::Tensor* _targets), *$(at::IntArrayRef* _input_lengths), *$(at::IntArrayRef* _target_lengths), $(int _blank), $(bool _deterministic), $(bool _zero_infinity))); }|]

_cudnn_rnn_flatten_weight_liiiiibb :: Ptr TensorList -> Int -> Int -> Int -> Int -> Int -> CBool -> CBool -> IO (Ptr Tensor)
_cudnn_rnn_flatten_weight_liiiiibb _weight_arr _weight_stride0 _input_size _mode _hidden_size _num_layers _batch_first _bidirectional = [C.block| at::Tensor* { return new at::Tensor(at::native::_cudnn_rnn_flatten_weight(*$(at::TensorList* _weight_arr), $(int _weight_stride0), $(int _input_size), $(int _mode), $(int _hidden_size), $(int _num_layers), $(bool _batch_first), $(bool _bidirectional))); }|]

_cudnn_rnn_tlitttiiibfbblt :: Ptr Tensor -> Ptr TensorList -> Int -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Int -> CBool -> CFloat -> CBool -> CBool -> Ptr IntList -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor,Tensor,Tensor))
_cudnn_rnn_tlitttiiibfbblt _input _weight _weight_stride0 _weight_buf _hx _cx _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::native::_cudnn_rnn(*$(at::Tensor* _input), *$(at::TensorList* _weight), $(int _weight_stride0), *$(at::Tensor* _weight_buf), *$(at::Tensor* _hx), *$(at::Tensor* _cx), $(int _mode), $(int _hidden_size), $(int _num_layers), $(bool _batch_first), $(float _dropout), $(bool _train), $(bool _bidirectional), *$(at::IntArrayRef* _batch_sizes), *$(at::Tensor* _dropout_state))); }|]

_cudnn_rnn_backward_tlitttttttiiibfbbltta :: Ptr Tensor -> Ptr TensorList -> Int -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Int -> CBool -> CFloat -> CBool -> CBool -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr (StdArray CBool 4) -> IO (Ptr (Tensor,Tensor,Tensor,TensorList))
_cudnn_rnn_backward_tlitttttttiiibfbbltta _input _weight _weight_stride0 _weight_buf _hx _cx _output _grad_output _grad_hy _grad_cy _mode _hidden_size _num_layers _batch_first _dropout _train _bidirectional _batch_sizes _dropout_state _reserve _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::TensorList>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::TensorList>(at::native::_cudnn_rnn_backward(*$(at::Tensor* _input), *$(at::TensorList* _weight), $(int _weight_stride0), *$(at::Tensor* _weight_buf), *$(at::Tensor* _hx), *$(at::Tensor* _cx), *$(at::Tensor* _output), *$(at::Tensor* _grad_output), *$(at::Tensor* _grad_hy), *$(at::Tensor* _grad_cy), $(int _mode), $(int _hidden_size), $(int _num_layers), $(bool _batch_first), $(float _dropout), $(bool _train), $(bool _bidirectional), *$(at::IntArrayRef* _batch_sizes), *$(at::Tensor* _dropout_state), *$(at::Tensor* _reserve), *$(std::array<bool,4>* _output_mask))); }|]

_cudnn_init_dropout_state_dbio :: CDouble -> CBool -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
_cudnn_init_dropout_state_dbio _dropout _train _dropout_seed _options = [C.block| at::Tensor* { return new at::Tensor(at::native::_cudnn_init_dropout_state($(double _dropout), $(bool _train), $(int _dropout_seed), *$(at::TensorOptions* _options))); }|]

index_select_backward_tltlb :: Ptr Tensor -> Int64 -> Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
index_select_backward_tltlb _grad _dim _indices _sizes _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::index_select_backward(*$(at::Tensor* _grad), $(int64_t _dim), *$(at::Tensor* _indices), *$(at::IntArrayRef* _sizes), $(bool _keepdim))); }|]

select_backward_tlll :: Ptr Tensor -> Ptr IntList -> Int64 -> Int64 -> IO (Ptr Tensor)
select_backward_tlll _grad _input_sizes _dim _index = [C.block| at::Tensor* { return new at::Tensor(at::native::select_backward(*$(at::Tensor* _grad), *$(at::IntArrayRef* _input_sizes), $(int64_t _dim), $(int64_t _index))); }|]

fused_dropout_cuda_tfp :: Ptr Tensor -> CFloat -> Ptr Generator -> IO (Ptr (Tensor,Tensor))
fused_dropout_cuda_tfp _self _p _generator = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fused_dropout_cuda(*$(at::Tensor* _self), $(float _p), $(at::Generator * _generator))); }|]

masked_scale_cuda_ttf :: Ptr Tensor -> Ptr Tensor -> CFloat -> IO (Ptr Tensor)
masked_scale_cuda_ttf _self _mask _scale = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_scale_cuda(*$(at::Tensor* _self), *$(at::Tensor* _mask), $(float _scale))); }|]

_reshape_from_tensor_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_reshape_from_tensor_tt _self _shape = [C.block| at::Tensor* { return new at::Tensor(at::native::_reshape_from_tensor(*$(at::Tensor* _self), *$(at::Tensor* _shape))); }|]

_shape_as_tensor_t :: Ptr Tensor -> IO (Ptr Tensor)
_shape_as_tensor_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_shape_as_tensor(*$(at::Tensor* _self))); }|]

dropout_tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
dropout_tfb _input _p _train = [C.block| at::Tensor* { return new at::Tensor(at::native::dropout(*$(at::Tensor* _input), $(float _p), $(bool _train))); }|]

dropout__Tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
dropout__Tfb _self _p _train = [C.block| at::Tensor* { return new at::Tensor(at::native::dropout_(*$(at::Tensor* _self), $(float _p), $(bool _train))); }|]

feature_dropout_tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
feature_dropout_tfb _input _p _train = [C.block| at::Tensor* { return new at::Tensor(at::native::feature_dropout(*$(at::Tensor* _input), $(float _p), $(bool _train))); }|]

feature_dropout__Tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
feature_dropout__Tfb _self _p _train = [C.block| at::Tensor* { return new at::Tensor(at::native::feature_dropout_(*$(at::Tensor* _self), $(float _p), $(bool _train))); }|]

alpha_dropout_tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
alpha_dropout_tfb _input _p _train = [C.block| at::Tensor* { return new at::Tensor(at::native::alpha_dropout(*$(at::Tensor* _input), $(float _p), $(bool _train))); }|]

alpha_dropout__Tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
alpha_dropout__Tfb _self _p _train = [C.block| at::Tensor* { return new at::Tensor(at::native::alpha_dropout_(*$(at::Tensor* _self), $(float _p), $(bool _train))); }|]

feature_alpha_dropout_tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
feature_alpha_dropout_tfb _input _p _train = [C.block| at::Tensor* { return new at::Tensor(at::native::feature_alpha_dropout(*$(at::Tensor* _input), $(float _p), $(bool _train))); }|]

feature_alpha_dropout__Tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
feature_alpha_dropout__Tfb _self _p _train = [C.block| at::Tensor* { return new at::Tensor(at::native::feature_alpha_dropout_(*$(at::Tensor* _self), $(float _p), $(bool _train))); }|]

abs_t :: Ptr Tensor -> IO (Ptr Tensor)
abs_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::abs(*$(at::Tensor* _self))); }|]

_abs__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_abs__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_abs__cpu(*$(at::Tensor* _self))); }|]

_abs__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_abs__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_abs__cuda(*$(at::Tensor* _self))); }|]

_abs_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_abs_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_abs_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_abs_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_abs_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_abs_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

acos_t :: Ptr Tensor -> IO (Ptr Tensor)
acos_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::acos(*$(at::Tensor* _self))); }|]

_acos__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_acos__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_acos__cpu(*$(at::Tensor* _self))); }|]

_acos__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_acos__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_acos__cuda(*$(at::Tensor* _self))); }|]

_acos_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_acos_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_acos_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_acos_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_acos_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_acos_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

avg_pool1d_tlllbb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> IO (Ptr Tensor)
avg_pool1d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool1d(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad))); }|]

adaptive_avg_pool1d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
adaptive_avg_pool1d_tl _self _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool1d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

adaptive_max_pool1d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool1d_tl _self _output_size = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool1d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

add_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
add_tts _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::add(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha))); }|]

add__Tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
add__Tts _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::add_(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha))); }|]

add_ttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
add_ttsT _self _other _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::add(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

add_tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
add_tss _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::add(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Scalar* _alpha))); }|]

add__Tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
add__Tss _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::add_(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Scalar* _alpha))); }|]

addmv_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
addmv_tttss _self _mat _vec _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::addmv(*$(at::Tensor* _self), *$(at::Tensor* _mat), *$(at::Tensor* _vec), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

addmv__Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
addmv__Tttss _self _mat _vec _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::addmv_(*$(at::Tensor* _self), *$(at::Tensor* _mat), *$(at::Tensor* _vec), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

addmv_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
addmv_tttssT _self _mat _vec _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::addmv(*$(at::Tensor* _self), *$(at::Tensor* _mat), *$(at::Tensor* _vec), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

addr_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
addr_tttss _self _vec1 _vec2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::addr(*$(at::Tensor* _self), *$(at::Tensor* _vec1), *$(at::Tensor* _vec2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

addr__Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
addr__Tttss _self _vec1 _vec2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::addr_(*$(at::Tensor* _self), *$(at::Tensor* _vec1), *$(at::Tensor* _vec2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

addr_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
addr_tttssT _self _vec1 _vec2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::addr(*$(at::Tensor* _self), *$(at::Tensor* _vec1), *$(at::Tensor* _vec2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

affine_grid_generator_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
affine_grid_generator_tl _theta _size = [C.block| at::Tensor* { return new at::Tensor(at::native::affine_grid_generator(*$(at::Tensor* _theta), *$(at::IntArrayRef* _size))); }|]

affine_grid_generator_backward_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
affine_grid_generator_backward_tl _grad _size = [C.block| at::Tensor* { return new at::Tensor(at::native::affine_grid_generator_backward(*$(at::Tensor* _grad), *$(at::IntArrayRef* _size))); }|]

all_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
all_tib _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::all(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

all_tibT :: Ptr Tensor -> Int -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
all_tibT _self _dim _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::all(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim), *$(at::Tensor* _out))); }|]

allclose_ttffb :: Ptr Tensor -> Ptr Tensor -> CFloat -> CFloat -> CBool -> IO (CBool)
allclose_ttffb _self _other _rtol _atol _equal_nan = [C.block| bool { return (at::native::allclose(*$(at::Tensor* _self), *$(at::Tensor* _other), $(float _rtol), $(float _atol), $(bool _equal_nan))); }|]

any_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
any_tib _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::any(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

any_tibT :: Ptr Tensor -> Int -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
any_tibT _self _dim _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::any(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim), *$(at::Tensor* _out))); }|]

arange_so :: Ptr Scalar -> Ptr TensorOptions -> IO (Ptr Tensor)
arange_so _end _options = [C.block| at::Tensor* { return new at::Tensor(at::native::arange(*$(at::Scalar* _end), *$(at::TensorOptions* _options))); }|]

arange_sso :: Ptr Scalar -> Ptr Scalar -> Ptr TensorOptions -> IO (Ptr Tensor)
arange_sso _start _end _options = [C.block| at::Tensor* { return new at::Tensor(at::native::arange(*$(at::Scalar* _start), *$(at::Scalar* _end), *$(at::TensorOptions* _options))); }|]

arange_ssso :: Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr TensorOptions -> IO (Ptr Tensor)
arange_ssso _start _end _step _options = [C.block| at::Tensor* { return new at::Tensor(at::native::arange(*$(at::Scalar* _start), *$(at::Scalar* _end), *$(at::Scalar* _step), *$(at::TensorOptions* _options))); }|]

arange_sT :: Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
arange_sT _end _out = [C.block| at::Tensor* { return new at::Tensor(at::native::arange(*$(at::Scalar* _end), *$(at::Tensor* _out))); }|]

arange_cpu_out_sssT :: Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
arange_cpu_out_sssT _start _end _step _out = [C.block| at::Tensor* { return new at::Tensor(at::native::arange_cpu_out(*$(at::Scalar* _start), *$(at::Scalar* _end), *$(at::Scalar* _step), *$(at::Tensor* _out))); }|]

arange_cuda_out_sssT :: Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
arange_cuda_out_sssT _start _end _step _out = [C.block| at::Tensor* { return new at::Tensor(at::native::arange_cuda_out(*$(at::Scalar* _start), *$(at::Scalar* _end), *$(at::Scalar* _step), *$(at::Tensor* _out))); }|]

_dim_arange_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
_dim_arange_ti _like _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::_dim_arange(*$(at::Tensor* _like), $(int _dim))); }|]

argmax_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
argmax_tib _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::argmax(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

argmax_t :: Ptr Tensor -> IO (Ptr Tensor)
argmax_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::argmax(*$(at::Tensor* _self))); }|]

_argmax_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
_argmax_tib _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::_argmax(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

argmin_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
argmin_tib _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::argmin(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

argmin_t :: Ptr Tensor -> IO (Ptr Tensor)
argmin_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::argmin(*$(at::Tensor* _self))); }|]

_argmin_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
_argmin_tib _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::_argmin(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

as_strided_tlli :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Int -> IO (Ptr Tensor)
as_strided_tlli _self _size _stride _storage_offset = [C.block| at::Tensor* { return new at::Tensor(at::native::as_strided(*$(at::Tensor* _self), *$(at::IntArrayRef* _size), *$(at::IntArrayRef* _stride), $(int _storage_offset))); }|]

as_strided__Tlli :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Int -> IO (Ptr Tensor)
as_strided__Tlli _self _size _stride _storage_offset = [C.block| at::Tensor* { return new at::Tensor(at::native::as_strided_(*$(at::Tensor* _self), *$(at::IntArrayRef* _size), *$(at::IntArrayRef* _stride), $(int _storage_offset))); }|]

asin_t :: Ptr Tensor -> IO (Ptr Tensor)
asin_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::asin(*$(at::Tensor* _self))); }|]

_asin__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_asin__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_asin__cpu(*$(at::Tensor* _self))); }|]

_asin__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_asin__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_asin__cuda(*$(at::Tensor* _self))); }|]

_asin_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_asin_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_asin_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_asin_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_asin_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_asin_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

atan_t :: Ptr Tensor -> IO (Ptr Tensor)
atan_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::atan(*$(at::Tensor* _self))); }|]

_atan__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_atan__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_atan__cpu(*$(at::Tensor* _self))); }|]

_atan__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_atan__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_atan__cuda(*$(at::Tensor* _self))); }|]

_atan_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_atan_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_atan_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_atan_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_atan_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_atan_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

baddbmm_cpu_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
baddbmm_cpu_tttss _self _batch1 _batch2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm_cpu(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

baddbmm_cuda_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
baddbmm_cuda_tttss _self _batch1 _batch2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm_cuda(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

baddbmm__cpu_Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
baddbmm__cpu_Tttss _self _batch1 _batch2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm__cpu(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

baddbmm__cuda_Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
baddbmm__cuda_Tttss _self _batch1 _batch2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm__cuda(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

_baddbmm_mkl__Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
_baddbmm_mkl__Tttss _self _batch1 _batch2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::_baddbmm_mkl_(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

baddbmm_out_cpu_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
baddbmm_out_cpu_tttssT _self _batch1 _batch2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

baddbmm_out_cuda_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
baddbmm_out_cuda_tttssT _self _batch1 _batch2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::baddbmm_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

bartlett_window_io :: Int -> Ptr TensorOptions -> IO (Ptr Tensor)
bartlett_window_io _window_length _options = [C.block| at::Tensor* { return new at::Tensor(at::native::bartlett_window($(int _window_length), *$(at::TensorOptions* _options))); }|]

bartlett_window_ibo :: Int -> CBool -> Ptr TensorOptions -> IO (Ptr Tensor)
bartlett_window_ibo _window_length _periodic _options = [C.block| at::Tensor* { return new at::Tensor(at::native::bartlett_window($(int _window_length), $(bool _periodic), *$(at::TensorOptions* _options))); }|]

batch_norm_tttttbffb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CFloat -> CFloat -> CBool -> IO (Ptr Tensor)
batch_norm_tttttbffb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled = [C.block| at::Tensor* { return new at::Tensor(at::native::batch_norm(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(bool _training), $(float _momentum), $(float _eps), $(bool _cudnn_enabled))); }|]

_batch_norm_impl_index_tttttbddb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CDouble -> CDouble -> CBool -> IO (Ptr (Tensor,Tensor,Tensor,Int64))
_batch_norm_impl_index_tttttbddb _input _weight _bias _running_mean _running_var _training _momentum _eps _cudnn_enabled = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,int64_t>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,int64_t>(at::native::_batch_norm_impl_index(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(bool _training), $(double _momentum), $(double _eps), $(bool _cudnn_enabled))); }|]

_batch_norm_impl_index_backward_ltttttttbda :: Int64 -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CDouble -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
_batch_norm_impl_index_backward_ltttttttbda _impl_index _input _grad_output _weight _running_mean _running_var _save_mean _save_var_transform _train _eps _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::_batch_norm_impl_index_backward($(int64_t _impl_index), *$(at::Tensor* _input), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), *$(at::Tensor* _save_mean), *$(at::Tensor* _save_var_transform), $(bool _train), $(double _eps), *$(std::array<bool,3>* _output_mask))); }|]

bernoulli_tp :: Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
bernoulli_tp _self _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli(*$(at::Tensor* _self), $(at::Generator * _generator))); }|]

bernoulli_tpT :: Ptr Tensor -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
bernoulli_tpT _self _generator _out = [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli(*$(at::Tensor* _self), $(at::Generator * _generator), *$(at::Tensor* _out))); }|]

bernoulli_tensor_cpu__Ttp :: Ptr Tensor -> Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
bernoulli_tensor_cpu__Ttp _self _p _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli_tensor_cpu_(*$(at::Tensor* _self), *$(at::Tensor* _p), $(at::Generator * _generator))); }|]

bernoulli_tensor_cuda__Ttp :: Ptr Tensor -> Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
bernoulli_tensor_cuda__Ttp _self _p _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli_tensor_cuda_(*$(at::Tensor* _self), *$(at::Tensor* _p), $(at::Generator * _generator))); }|]

bernoulli_scalar_cpu__Tfp :: Ptr Tensor -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
bernoulli_scalar_cpu__Tfp _self _p _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli_scalar_cpu_(*$(at::Tensor* _self), $(float _p), $(at::Generator * _generator))); }|]

bernoulli_scalar_cuda__Tfp :: Ptr Tensor -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
bernoulli_scalar_cuda__Tfp _self _p _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli_scalar_cuda_(*$(at::Tensor* _self), $(float _p), $(at::Generator * _generator))); }|]

bernoulli_tfp :: Ptr Tensor -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
bernoulli_tfp _self _p _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::bernoulli(*$(at::Tensor* _self), $(float _p), $(at::Generator * _generator))); }|]

bilinear_tttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
bilinear_tttt _input1 _input2 _weight _bias = [C.block| at::Tensor* { return new at::Tensor(at::native::bilinear(*$(at::Tensor* _input1), *$(at::Tensor* _input2), *$(at::Tensor* _weight), *$(at::Tensor* _bias))); }|]

binary_cross_entropy_with_logits_tttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_tttti _self _target _weight _pos_weight _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_with_logits(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), *$(at::Tensor* _pos_weight), $(int _reduction))); }|]

binary_cross_entropy_with_logits_backward_ttttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
binary_cross_entropy_with_logits_backward_ttttti _grad_output _self _target _weight _pos_weight _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_with_logits_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), *$(at::Tensor* _pos_weight), $(int _reduction))); }|]

_bincount_cpu_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
_bincount_cpu_tti _self _weights _minlength = [C.block| at::Tensor* { return new at::Tensor(at::native::_bincount_cpu(*$(at::Tensor* _self), *$(at::Tensor* _weights), $(int _minlength))); }|]

_bincount_cuda_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
_bincount_cuda_tti _self _weights _minlength = [C.block| at::Tensor* { return new at::Tensor(at::native::_bincount_cuda(*$(at::Tensor* _self), *$(at::Tensor* _weights), $(int _minlength))); }|]

blackman_window_io :: Int -> Ptr TensorOptions -> IO (Ptr Tensor)
blackman_window_io _window_length _options = [C.block| at::Tensor* { return new at::Tensor(at::native::blackman_window($(int _window_length), *$(at::TensorOptions* _options))); }|]

blackman_window_ibo :: Int -> CBool -> Ptr TensorOptions -> IO (Ptr Tensor)
blackman_window_ibo _window_length _periodic _options = [C.block| at::Tensor* { return new at::Tensor(at::native::blackman_window($(int _window_length), $(bool _periodic), *$(at::TensorOptions* _options))); }|]

bmm_cpu_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
bmm_cpu_tt _self _mat2 = [C.block| at::Tensor* { return new at::Tensor(at::native::bmm_cpu(*$(at::Tensor* _self), *$(at::Tensor* _mat2))); }|]

bmm_cuda_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
bmm_cuda_tt _self _mat2 = [C.block| at::Tensor* { return new at::Tensor(at::native::bmm_cuda(*$(at::Tensor* _self), *$(at::Tensor* _mat2))); }|]

bmm_out_cpu_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
bmm_out_cpu_ttT _self _mat2 _out = [C.block| at::Tensor* { return new at::Tensor(at::native::bmm_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _mat2), *$(at::Tensor* _out))); }|]

bmm_out_cuda_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
bmm_out_cuda_ttT _self _mat2 _out = [C.block| at::Tensor* { return new at::Tensor(at::native::bmm_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _mat2), *$(at::Tensor* _out))); }|]

broadcast_tensors_l :: Ptr TensorList -> IO (Ptr TensorList)
broadcast_tensors_l _tensors = [C.block| at::TensorList* { return new at::TensorList(at::native::broadcast_tensors(*$(at::TensorList* _tensors))); }|]

cat_li :: Ptr TensorList -> Int -> IO (Ptr Tensor)
cat_li _tensors _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::cat(*$(at::TensorList* _tensors), $(int _dim))); }|]

cat_liT :: Ptr TensorList -> Int -> Ptr Tensor -> IO (Ptr Tensor)
cat_liT _tensors _dim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::cat(*$(at::TensorList* _tensors), $(int _dim), *$(at::Tensor* _out))); }|]

ceil_t :: Ptr Tensor -> IO (Ptr Tensor)
ceil_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::ceil(*$(at::Tensor* _self))); }|]

_ceil__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_ceil__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_ceil__cpu(*$(at::Tensor* _self))); }|]

_ceil__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_ceil__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_ceil__cuda(*$(at::Tensor* _self))); }|]

_ceil_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_ceil_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_ceil_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_ceil_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_ceil_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_ceil_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

chain_matmul_l :: Ptr TensorList -> IO (Ptr Tensor)
chain_matmul_l _matrices = [C.block| at::Tensor* { return new at::Tensor(at::native::chain_matmul(*$(at::TensorList* _matrices))); }|]

chunk_tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
chunk_tii _self _chunks _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::chunk(*$(at::Tensor* _self), $(int _chunks), $(int _dim))); }|]

clamp_tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
clamp_tss _self _min _max = [C.block| at::Tensor* { return new at::Tensor(at::native::clamp(*$(at::Tensor* _self), *$(at::Scalar* _min), *$(at::Scalar* _max))); }|]

_clamp__cpu_Tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
_clamp__cpu_Tss _self _min _max = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp__cpu(*$(at::Tensor* _self), *$(at::Scalar* _min), *$(at::Scalar* _max))); }|]

_clamp__cuda_Tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
_clamp__cuda_Tss _self _min _max = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp__cuda(*$(at::Tensor* _self), *$(at::Scalar* _min), *$(at::Scalar* _max))); }|]

_clamp_out_cpu_tssT :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_clamp_out_cpu_tssT _self _min _max _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_out_cpu(*$(at::Tensor* _self), *$(at::Scalar* _min), *$(at::Scalar* _max), *$(at::Tensor* _out))); }|]

_clamp_out_cuda_tssT :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_clamp_out_cuda_tssT _self _min _max _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_out_cuda(*$(at::Tensor* _self), *$(at::Scalar* _min), *$(at::Scalar* _max), *$(at::Tensor* _out))); }|]

clamp_max_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
clamp_max_ts _self _max = [C.block| at::Tensor* { return new at::Tensor(at::native::clamp_max(*$(at::Tensor* _self), *$(at::Scalar* _max))); }|]

_clamp_max__cpu_Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
_clamp_max__cpu_Ts _self _max = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_max__cpu(*$(at::Tensor* _self), *$(at::Scalar* _max))); }|]

_clamp_max__cuda_Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
_clamp_max__cuda_Ts _self _max = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_max__cuda(*$(at::Tensor* _self), *$(at::Scalar* _max))); }|]

_clamp_max_out_cpu_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_clamp_max_out_cpu_tsT _self _max _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_max_out_cpu(*$(at::Tensor* _self), *$(at::Scalar* _max), *$(at::Tensor* _out))); }|]

_clamp_max_out_cuda_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_clamp_max_out_cuda_tsT _self _max _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_max_out_cuda(*$(at::Tensor* _self), *$(at::Scalar* _max), *$(at::Tensor* _out))); }|]

clamp_min_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
clamp_min_ts _self _min = [C.block| at::Tensor* { return new at::Tensor(at::native::clamp_min(*$(at::Tensor* _self), *$(at::Scalar* _min))); }|]

_clamp_min__cpu_Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
_clamp_min__cpu_Ts _self _min = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_min__cpu(*$(at::Tensor* _self), *$(at::Scalar* _min))); }|]

_clamp_min__cuda_Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
_clamp_min__cuda_Ts _self _min = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_min__cuda(*$(at::Tensor* _self), *$(at::Scalar* _min))); }|]

_clamp_min_out_cpu_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_clamp_min_out_cpu_tsT _self _min _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_min_out_cpu(*$(at::Tensor* _self), *$(at::Scalar* _min), *$(at::Tensor* _out))); }|]

_clamp_min_out_cuda_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_clamp_min_out_cuda_tsT _self _min _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_clamp_min_out_cuda(*$(at::Tensor* _self), *$(at::Scalar* _min), *$(at::Tensor* _out))); }|]

cudnn_is_acceptable_t :: Ptr Tensor -> IO (CBool)
cudnn_is_acceptable_t _self = [C.block| bool { return (at::native::cudnn_is_acceptable(*$(at::Tensor* _self))); }|]

constant_pad_nd_tls :: Ptr Tensor -> Ptr IntList -> Ptr Scalar -> IO (Ptr Tensor)
constant_pad_nd_tls _self _pad _value = [C.block| at::Tensor* { return new at::Tensor(at::native::constant_pad_nd(*$(at::Tensor* _self), *$(at::IntArrayRef* _pad), *$(at::Scalar* _value))); }|]

contiguous_t :: Ptr Tensor -> IO (Ptr Tensor)
contiguous_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::contiguous(*$(at::Tensor* _self))); }|]

convolution_tttlllbli :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr IntList -> Int -> IO (Ptr Tensor)
convolution_tttlllbli _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups = [C.block| at::Tensor* { return new at::Tensor(at::native::convolution(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _transposed), *$(at::IntArrayRef* _output_padding), $(int _groups))); }|]

_convolution_tttlllblibbb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr IntList -> Int -> CBool -> CBool -> CBool -> IO (Ptr Tensor)
_convolution_tttlllblibbb _input _weight _bias _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled = [C.block| at::Tensor* { return new at::Tensor(at::native::_convolution(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _transposed), *$(at::IntArrayRef* _output_padding), $(int _groups), $(bool _benchmark), $(bool _deterministic), $(bool _cudnn_enabled))); }|]

_convolution_nogroup_tttlllbl :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr IntList -> IO (Ptr Tensor)
_convolution_nogroup_tttlllbl _input _weight _bias _stride _padding _dilation _transposed _output_padding = [C.block| at::Tensor* { return new at::Tensor(at::native::_convolution_nogroup(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _transposed), *$(at::IntArrayRef* _output_padding))); }|]

_convolution_double_backward_ttttttlllblibbba :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr IntList -> Int -> CBool -> CBool -> CBool -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
_convolution_double_backward_ttttttlllblibbba _ggI _ggW _ggb _gO _weight _self _stride _padding _dilation _transposed _output_padding _groups _benchmark _deterministic _cudnn_enabled _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::_convolution_double_backward(*$(at::Tensor* _ggI), *$(at::Tensor* _ggW), *$(at::Tensor* _ggb), *$(at::Tensor* _gO), *$(at::Tensor* _weight), *$(at::Tensor* _self), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _transposed), *$(at::IntArrayRef* _output_padding), $(int _groups), $(bool _benchmark), $(bool _deterministic), $(bool _cudnn_enabled), *$(std::array<bool,3>* _output_mask))); }|]

conv1d_tttllli :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> IO (Ptr Tensor)
conv1d_tttllli _input _weight _bias _stride _padding _dilation _groups = [C.block| at::Tensor* { return new at::Tensor(at::native::conv1d(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(int _groups))); }|]

conv2d_tttllli :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> IO (Ptr Tensor)
conv2d_tttllli _input _weight _bias _stride _padding _dilation _groups = [C.block| at::Tensor* { return new at::Tensor(at::native::conv2d(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(int _groups))); }|]

conv3d_tttllli :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> IO (Ptr Tensor)
conv3d_tttllli _input _weight _bias _stride _padding _dilation _groups = [C.block| at::Tensor* { return new at::Tensor(at::native::conv3d(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(int _groups))); }|]

conv_tbc_ttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
conv_tbc_ttti _self _weight _bias _pad = [C.block| at::Tensor* { return new at::Tensor(at::native::conv_tbc(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::Tensor* _bias), $(int _pad))); }|]

conv_tbc_backward_tttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr (Tensor,Tensor,Tensor))
conv_tbc_backward_tttti _self _input _weight _bias _pad = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::conv_tbc_backward(*$(at::Tensor* _self), *$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), $(int _pad))); }|]

conv_transpose1d_tttlllil :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> Ptr IntList -> IO (Ptr Tensor)
conv_transpose1d_tttlllil _input _weight _bias _stride _padding _output_padding _groups _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::conv_transpose1d(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), $(int _groups), *$(at::IntArrayRef* _dilation))); }|]

conv_transpose2d_tttlllil :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> Ptr IntList -> IO (Ptr Tensor)
conv_transpose2d_tttlllil _input _weight _bias _stride _padding _output_padding _groups _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::conv_transpose2d(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), $(int _groups), *$(at::IntArrayRef* _dilation))); }|]

conv_transpose3d_tttlllil :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> Ptr IntList -> IO (Ptr Tensor)
conv_transpose3d_tttlllil _input _weight _bias _stride _padding _output_padding _groups _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::conv_transpose3d(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), $(int _groups), *$(at::IntArrayRef* _dilation))); }|]

_s_copy__cpu_Ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
_s_copy__cpu_Ttb _self _src _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_copy__cpu(*$(at::Tensor* _self), *$(at::Tensor* _src), $(bool _non_blocking))); }|]

_s_copy__cuda_Ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
_s_copy__cuda_Ttb _self _src _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_copy__cuda(*$(at::Tensor* _self), *$(at::Tensor* _src), $(bool _non_blocking))); }|]

_s_copy_from_cuda_ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
_s_copy_from_cuda_ttb _self _dst _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_copy_from_cuda(*$(at::Tensor* _self), *$(at::Tensor* _dst), $(bool _non_blocking))); }|]

_copy_same_type__cpu_Tt :: Ptr Tensor -> Ptr Tensor -> IO ()
_copy_same_type__cpu_Tt _self _src = [C.block| void {  (at::native::_copy_same_type__cpu(*$(at::Tensor* _self), *$(at::Tensor* _src))); }|]

cos_t :: Ptr Tensor -> IO (Ptr Tensor)
cos_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::cos(*$(at::Tensor* _self))); }|]

_cos__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_cos__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_cos__cpu(*$(at::Tensor* _self))); }|]

_cos__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_cos__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_cos__cuda(*$(at::Tensor* _self))); }|]

_cos_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_cos_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_cos_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_cos_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_cos_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_cos_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

cosh_t :: Ptr Tensor -> IO (Ptr Tensor)
cosh_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::cosh(*$(at::Tensor* _self))); }|]

_cosh__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_cosh__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_cosh__cpu(*$(at::Tensor* _self))); }|]

_cosh__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_cosh__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_cosh__cuda(*$(at::Tensor* _self))); }|]

_cosh_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_cosh_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_cosh_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_cosh_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_cosh_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_cosh_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

cosine_embedding_loss_tttfi :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CFloat -> Int -> IO (Ptr Tensor)
cosine_embedding_loss_tttfi _input1 _input2 _target _margin _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::cosine_embedding_loss(*$(at::Tensor* _input1), *$(at::Tensor* _input2), *$(at::Tensor* _target), $(float _margin), $(int _reduction))); }|]

cudnn_affine_grid_generator_forward_tiiii :: Ptr Tensor -> Int -> Int -> Int -> Int -> IO (Ptr Tensor)
cudnn_affine_grid_generator_forward_tiiii _theta _N _C _H _W = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_affine_grid_generator_forward(*$(at::Tensor* _theta), $(int _N), $(int _C), $(int _H), $(int _W))); }|]

cudnn_affine_grid_generator_backward_tiiii :: Ptr Tensor -> Int -> Int -> Int -> Int -> IO (Ptr Tensor)
cudnn_affine_grid_generator_backward_tiiii _grad _N _C _H _W = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_affine_grid_generator_backward(*$(at::Tensor* _grad), $(int _N), $(int _C), $(int _H), $(int _W))); }|]

cudnn_batch_norm_tttttbff :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CFloat -> CFloat -> IO (Ptr (Tensor,Tensor,Tensor))
cudnn_batch_norm_tttttbff _input _weight _bias _running_mean _running_var _training _exponential_average_factor _epsilon = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::cudnn_batch_norm(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(bool _training), $(float _exponential_average_factor), $(float _epsilon))); }|]

cudnn_batch_norm_backward_tttttttf :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CFloat -> IO (Ptr (Tensor,Tensor,Tensor))
cudnn_batch_norm_backward_tttttttf _input _grad_output _weight _running_mean _running_var _save_mean _save_var _epsilon = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::cudnn_batch_norm_backward(*$(at::Tensor* _input), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), *$(at::Tensor* _save_mean), *$(at::Tensor* _save_var), $(float _epsilon))); }|]

cudnn_convolution_tttlllibb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
cudnn_convolution_tttlllibb _self _weight _bias _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_convolution(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

cudnn_convolution_backward_input_lttlllibb :: Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
cudnn_convolution_backward_input_lttlllibb _self_size _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_convolution_backward_input(*$(at::IntArrayRef* _self_size), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

cudnn_convolution_backward_tttlllibba :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
cudnn_convolution_backward_tttlllibba _self _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::cudnn_convolution_backward(*$(at::Tensor* _self), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic), *$(std::array<bool,3>* _output_mask))); }|]

cudnn_convolution_backward_bias_t :: Ptr Tensor -> IO (Ptr Tensor)
cudnn_convolution_backward_bias_t _grad_output = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_convolution_backward_bias(*$(at::Tensor* _grad_output))); }|]

cudnn_convolution_backward_weight_lttlllibb :: Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
cudnn_convolution_backward_weight_lttlllibb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_convolution_backward_weight(*$(at::IntArrayRef* _weight_size), *$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

cudnn_convolution_transpose_tttllllibb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
cudnn_convolution_transpose_tttllllibb _self _weight _bias _padding _output_padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_convolution_transpose(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

cudnn_convolution_transpose_backward_tttllllibba :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
cudnn_convolution_transpose_backward_tttllllibba _self _grad_output _weight _padding _output_padding _stride _dilation _groups _benchmark _deterministic _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::cudnn_convolution_transpose_backward(*$(at::Tensor* _self), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic), *$(std::array<bool,3>* _output_mask))); }|]

cudnn_convolution_backward_bias_t :: Ptr Tensor -> IO (Ptr Tensor)
cudnn_convolution_backward_bias_t _grad_output = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_convolution_backward_bias(*$(at::Tensor* _grad_output))); }|]

cudnn_convolution_transpose_backward_input_ttlllibb :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
cudnn_convolution_transpose_backward_input_ttlllibb _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_convolution_transpose_backward_input(*$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

cudnn_convolution_transpose_backward_weight_lttlllibb :: Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
cudnn_convolution_transpose_backward_weight_lttlllibb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_convolution_transpose_backward_weight(*$(at::IntArrayRef* _weight_size), *$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

cudnn_grid_sampler_forward_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
cudnn_grid_sampler_forward_tt _self _grid = [C.block| at::Tensor* { return new at::Tensor(at::native::cudnn_grid_sampler_forward(*$(at::Tensor* _self), *$(at::Tensor* _grid))); }|]

cudnn_grid_sampler_backward_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
cudnn_grid_sampler_backward_ttt _self _grid _grad_output = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::cudnn_grid_sampler_backward(*$(at::Tensor* _self), *$(at::Tensor* _grid), *$(at::Tensor* _grad_output))); }|]

cumsum_tis :: Ptr Tensor -> Int -> Ptr ScalarType -> IO (Ptr Tensor)
cumsum_tis _self _dim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::cumsum(*$(at::Tensor* _self), $(int _dim), *$(at::ScalarType* _dtype))); }|]

cumsum_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
cumsum_ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::cumsum(*$(at::Tensor* _self), $(int _dim))); }|]

cumsum_tisT :: Ptr Tensor -> Int -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
cumsum_tisT _self _dim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::cumsum(*$(at::Tensor* _self), $(int _dim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

cumsum_tiT :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
cumsum_tiT _self _dim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::cumsum(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _out))); }|]

cumprod_tis :: Ptr Tensor -> Int -> Ptr ScalarType -> IO (Ptr Tensor)
cumprod_tis _self _dim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::cumprod(*$(at::Tensor* _self), $(int _dim), *$(at::ScalarType* _dtype))); }|]

cumprod_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
cumprod_ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::cumprod(*$(at::Tensor* _self), $(int _dim))); }|]

cumprod_tisT :: Ptr Tensor -> Int -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
cumprod_tisT _self _dim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::cumprod(*$(at::Tensor* _self), $(int _dim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

cumprod_tiT :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
cumprod_tiT _self _dim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::cumprod(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _out))); }|]

ctc_loss_ttlliib :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Int -> Int -> CBool -> IO (Ptr Tensor)
ctc_loss_ttlliib _log_probs _targets _input_lengths _target_lengths _blank _reduction _zero_infinity = [C.block| at::Tensor* { return new at::Tensor(at::native::ctc_loss(*$(at::Tensor* _log_probs), *$(at::Tensor* _targets), *$(at::IntArrayRef* _input_lengths), *$(at::IntArrayRef* _target_lengths), $(int _blank), $(int _reduction), $(bool _zero_infinity))); }|]

ctc_loss_ttttiib :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> CBool -> IO (Ptr Tensor)
ctc_loss_ttttiib _log_probs _targets _input_lengths _target_lengths _blank _reduction _zero_infinity = [C.block| at::Tensor* { return new at::Tensor(at::native::ctc_loss(*$(at::Tensor* _log_probs), *$(at::Tensor* _targets), *$(at::Tensor* _input_lengths), *$(at::Tensor* _target_lengths), $(int _blank), $(int _reduction), $(bool _zero_infinity))); }|]

ctc_loss_cpu_ttllib :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Int -> CBool -> IO (Ptr (Tensor,Tensor))
ctc_loss_cpu_ttllib _log_probs _targets _input_lengths _target_lengths _blank _zero_infinity = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::ctc_loss_cpu(*$(at::Tensor* _log_probs), *$(at::Tensor* _targets), *$(at::IntArrayRef* _input_lengths), *$(at::IntArrayRef* _target_lengths), $(int _blank), $(bool _zero_infinity))); }|]

ctc_loss_gpu_ttllib :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Int -> CBool -> IO (Ptr (Tensor,Tensor))
ctc_loss_gpu_ttllib _log_probs _targets _input_lengths _target_lengths _blank _zero_infinity = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::ctc_loss_gpu(*$(at::Tensor* _log_probs), *$(at::Tensor* _targets), *$(at::IntArrayRef* _input_lengths), *$(at::IntArrayRef* _target_lengths), $(int _blank), $(bool _zero_infinity))); }|]

ctc_loss_backward_cpu_tttllttib :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
ctc_loss_backward_cpu_tttllttib _grad _log_probs _targets _input_lengths _target_lengths _neg_log_likelihood _log_alpha _blank _zero_infinity = [C.block| at::Tensor* { return new at::Tensor(at::native::ctc_loss_backward_cpu(*$(at::Tensor* _grad), *$(at::Tensor* _log_probs), *$(at::Tensor* _targets), *$(at::IntArrayRef* _input_lengths), *$(at::IntArrayRef* _target_lengths), *$(at::Tensor* _neg_log_likelihood), *$(at::Tensor* _log_alpha), $(int _blank), $(bool _zero_infinity))); }|]

ctc_loss_backward_gpu_tttllttib :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
ctc_loss_backward_gpu_tttllttib _grad _log_probs _targets _input_lengths _target_lengths _neg_log_likelihood _log_alpha _blank _zero_infinity = [C.block| at::Tensor* { return new at::Tensor(at::native::ctc_loss_backward_gpu(*$(at::Tensor* _grad), *$(at::Tensor* _log_probs), *$(at::Tensor* _targets), *$(at::IntArrayRef* _input_lengths), *$(at::IntArrayRef* _target_lengths), *$(at::Tensor* _neg_log_likelihood), *$(at::Tensor* _log_alpha), $(int _blank), $(bool _zero_infinity))); }|]

det_t :: Ptr Tensor -> IO (Ptr Tensor)
det_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::det(*$(at::Tensor* _self))); }|]

diag_embed_tiii :: Ptr Tensor -> Int -> Int -> Int -> IO (Ptr Tensor)
diag_embed_tiii _self _offset _dim1 _dim2 = [C.block| at::Tensor* { return new at::Tensor(at::native::diag_embed(*$(at::Tensor* _self), $(int _offset), $(int _dim1), $(int _dim2))); }|]

diagflat_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
diagflat_ti _self _offset = [C.block| at::Tensor* { return new at::Tensor(at::native::diagflat(*$(at::Tensor* _self), $(int _offset))); }|]

diagonal_tiii :: Ptr Tensor -> Int -> Int -> Int -> IO (Ptr Tensor)
diagonal_tiii _self _offset _dim1 _dim2 = [C.block| at::Tensor* { return new at::Tensor(at::native::diagonal(*$(at::Tensor* _self), $(int _offset), $(int _dim1), $(int _dim2))); }|]

div_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
div_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::div(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

div__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
div__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::div_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

div_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
div_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::div(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

div_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
div_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::div(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

div__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
div__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::div_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

dot_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
dot_tt _self _tensor = [C.block| at::Tensor* { return new at::Tensor(at::native::dot(*$(at::Tensor* _self), *$(at::Tensor* _tensor))); }|]

dot_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
dot_ttT _self _tensor _out = [C.block| at::Tensor* { return new at::Tensor(at::native::dot(*$(at::Tensor* _self), *$(at::Tensor* _tensor), *$(at::Tensor* _out))); }|]

einsum_sl :: Ptr StdString -> Ptr TensorList -> IO (Ptr Tensor)
einsum_sl _equation _tensors = [C.block| at::Tensor* { return new at::Tensor(at::native::einsum(*$(std::string* _equation), *$(at::TensorList* _tensors))); }|]

embedding_ttibb :: Ptr Tensor -> Ptr Tensor -> Int -> CBool -> CBool -> IO (Ptr Tensor)
embedding_ttibb _weight _indices _padding_idx _scale_grad_by_freq _sparse = [C.block| at::Tensor* { return new at::Tensor(at::native::embedding(*$(at::Tensor* _weight), *$(at::Tensor* _indices), $(int _padding_idx), $(bool _scale_grad_by_freq), $(bool _sparse))); }|]

embedding_backward_ttiibb :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> CBool -> CBool -> IO (Ptr Tensor)
embedding_backward_ttiibb _grad _indices _num_weights _padding_idx _scale_grad_by_freq _sparse = [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_backward(*$(at::Tensor* _grad), *$(at::Tensor* _indices), $(int _num_weights), $(int _padding_idx), $(bool _scale_grad_by_freq), $(bool _sparse))); }|]

embedding_dense_backward_cpu_ttiib :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> CBool -> IO (Ptr Tensor)
embedding_dense_backward_cpu_ttiib _grad _indices _num_weights _padding_idx _scale_grad_by_freq = [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_dense_backward_cpu(*$(at::Tensor* _grad), *$(at::Tensor* _indices), $(int _num_weights), $(int _padding_idx), $(bool _scale_grad_by_freq))); }|]

embedding_dense_backward_cuda_ttiib :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> CBool -> IO (Ptr Tensor)
embedding_dense_backward_cuda_ttiib _grad _indices _num_weights _padding_idx _scale_grad_by_freq = [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_dense_backward_cuda(*$(at::Tensor* _grad), *$(at::Tensor* _indices), $(int _num_weights), $(int _padding_idx), $(bool _scale_grad_by_freq))); }|]

embedding_renorm_cpu__Ttff :: Ptr Tensor -> Ptr Tensor -> CFloat -> CFloat -> IO (Ptr Tensor)
embedding_renorm_cpu__Ttff _self _indices _max_norm _norm_type = [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_renorm_cpu_(*$(at::Tensor* _self), *$(at::Tensor* _indices), $(float _max_norm), $(float _norm_type))); }|]

embedding_renorm_cuda__Ttff :: Ptr Tensor -> Ptr Tensor -> CFloat -> CFloat -> IO (Ptr Tensor)
embedding_renorm_cuda__Ttff _self _indices _max_norm _norm_type = [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_renorm_cuda_(*$(at::Tensor* _self), *$(at::Tensor* _indices), $(float _max_norm), $(float _norm_type))); }|]

embedding_sparse_backward_ttiib :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> CBool -> IO (Ptr Tensor)
embedding_sparse_backward_ttiib _grad _indices _num_weights _padding_idx _scale_grad_by_freq = [C.block| at::Tensor* { return new at::Tensor(at::native::embedding_sparse_backward(*$(at::Tensor* _grad), *$(at::Tensor* _indices), $(int _num_weights), $(int _padding_idx), $(bool _scale_grad_by_freq))); }|]

embedding_bag_tttbib :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> Int -> CBool -> IO (Ptr (Tensor,Tensor,Tensor,Tensor))
embedding_bag_tttbib _weight _indices _offsets _scale_grad_by_freq _mode _sparse = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::native::embedding_bag(*$(at::Tensor* _weight), *$(at::Tensor* _indices), *$(at::Tensor* _offsets), $(bool _scale_grad_by_freq), $(int _mode), $(bool _sparse))); }|]

_embedding_bag_cpu_tttbib :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> Int -> CBool -> IO (Ptr (Tensor,Tensor,Tensor,Tensor))
_embedding_bag_cpu_tttbib _weight _indices _offsets _scale_grad_by_freq _mode _sparse = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::native::_embedding_bag_cpu(*$(at::Tensor* _weight), *$(at::Tensor* _indices), *$(at::Tensor* _offsets), $(bool _scale_grad_by_freq), $(int _mode), $(bool _sparse))); }|]

_embedding_bag_cuda_tttbib :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> Int -> CBool -> IO (Ptr (Tensor,Tensor,Tensor,Tensor))
_embedding_bag_cuda_tttbib _weight _indices _offsets _scale_grad_by_freq _mode _sparse = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::native::_embedding_bag_cuda(*$(at::Tensor* _weight), *$(at::Tensor* _indices), *$(at::Tensor* _offsets), $(bool _scale_grad_by_freq), $(int _mode), $(bool _sparse))); }|]

_embedding_bag_backward_ttttttibib :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> CBool -> Int -> CBool -> IO (Ptr Tensor)
_embedding_bag_backward_ttttttibib _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode _sparse = [C.block| at::Tensor* { return new at::Tensor(at::native::_embedding_bag_backward(*$(at::Tensor* _grad), *$(at::Tensor* _indices), *$(at::Tensor* _offsets), *$(at::Tensor* _offset2bag), *$(at::Tensor* _bag_size), *$(at::Tensor* _maximum_indices), $(int _num_weights), $(bool _scale_grad_by_freq), $(int _mode), $(bool _sparse))); }|]

_embedding_bag_sparse_backward_tttttibi :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> CBool -> Int -> IO (Ptr Tensor)
_embedding_bag_sparse_backward_tttttibi _grad _indices _offsets _offset2bag _bag_size _num_weights _scale_grad_by_freq _mode = [C.block| at::Tensor* { return new at::Tensor(at::native::_embedding_bag_sparse_backward(*$(at::Tensor* _grad), *$(at::Tensor* _indices), *$(at::Tensor* _offsets), *$(at::Tensor* _offset2bag), *$(at::Tensor* _bag_size), $(int _num_weights), $(bool _scale_grad_by_freq), $(int _mode))); }|]

_embedding_bag_dense_backward_cpu_ttttttibi :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> CBool -> Int -> IO (Ptr Tensor)
_embedding_bag_dense_backward_cpu_ttttttibi _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode = [C.block| at::Tensor* { return new at::Tensor(at::native::_embedding_bag_dense_backward_cpu(*$(at::Tensor* _grad), *$(at::Tensor* _indices), *$(at::Tensor* _offsets), *$(at::Tensor* _offset2bag), *$(at::Tensor* _bag_size), *$(at::Tensor* _maximum_indices), $(int _num_weights), $(bool _scale_grad_by_freq), $(int _mode))); }|]

_embedding_bag_dense_backward_cuda_ttttttibi :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> CBool -> Int -> IO (Ptr Tensor)
_embedding_bag_dense_backward_cuda_ttttttibi _grad _indices _offsets _offset2bag _bag_size _maximum_indices _num_weights _scale_grad_by_freq _mode = [C.block| at::Tensor* { return new at::Tensor(at::native::_embedding_bag_dense_backward_cuda(*$(at::Tensor* _grad), *$(at::Tensor* _indices), *$(at::Tensor* _offsets), *$(at::Tensor* _offset2bag), *$(at::Tensor* _bag_size), *$(at::Tensor* _maximum_indices), $(int _num_weights), $(bool _scale_grad_by_freq), $(int _mode))); }|]

empty_cpu_lo :: Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
empty_cpu_lo _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::empty_cpu(*$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

empty_cuda_lo :: Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
empty_cuda_lo _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::empty_cuda(*$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

empty_sparse_lo :: Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
empty_sparse_lo _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::empty_sparse(*$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

resize_cpu__Tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
resize_cpu__Tl _self _size = [C.block| at::Tensor* { return new at::Tensor(at::native::resize_cpu_(*$(at::Tensor* _self), *$(at::IntArrayRef* _size))); }|]

resize_cuda__Tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
resize_cuda__Tl _self _size = [C.block| at::Tensor* { return new at::Tensor(at::native::resize_cuda_(*$(at::Tensor* _self), *$(at::IntArrayRef* _size))); }|]

empty_lT :: Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
empty_lT _size _out = [C.block| at::Tensor* { return new at::Tensor(at::native::empty(*$(at::IntArrayRef* _size), *$(at::Tensor* _out))); }|]

empty_like_t :: Ptr Tensor -> IO (Ptr Tensor)
empty_like_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::empty_like(*$(at::Tensor* _self))); }|]

empty_like_to :: Ptr Tensor -> Ptr TensorOptions -> IO (Ptr Tensor)
empty_like_to _self _options = [C.block| at::Tensor* { return new at::Tensor(at::native::empty_like(*$(at::Tensor* _self), *$(at::TensorOptions* _options))); }|]

empty_strided_cpu_llo :: Ptr IntList -> Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
empty_strided_cpu_llo _size _stride _options = [C.block| at::Tensor* { return new at::Tensor(at::native::empty_strided_cpu(*$(at::IntArrayRef* _size), *$(at::IntArrayRef* _stride), *$(at::TensorOptions* _options))); }|]

empty_strided_cuda_llo :: Ptr IntList -> Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
empty_strided_cuda_llo _size _stride _options = [C.block| at::Tensor* { return new at::Tensor(at::native::empty_strided_cuda(*$(at::IntArrayRef* _size), *$(at::IntArrayRef* _stride), *$(at::TensorOptions* _options))); }|]

erf_t :: Ptr Tensor -> IO (Ptr Tensor)
erf_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::erf(*$(at::Tensor* _self))); }|]

_erf__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_erf__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_erf__cpu(*$(at::Tensor* _self))); }|]

_erf__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_erf__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_erf__cuda(*$(at::Tensor* _self))); }|]

_erf_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_erf_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_erf_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_erf_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_erf_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_erf_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

erfc_t :: Ptr Tensor -> IO (Ptr Tensor)
erfc_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::erfc(*$(at::Tensor* _self))); }|]

_erfc__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_erfc__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_erfc__cpu(*$(at::Tensor* _self))); }|]

_erfc__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_erfc__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_erfc__cuda(*$(at::Tensor* _self))); }|]

_erfc_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_erfc_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_erfc_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_erfc_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_erfc_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_erfc_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

exp_t :: Ptr Tensor -> IO (Ptr Tensor)
exp_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::exp(*$(at::Tensor* _self))); }|]

_exp__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_exp__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_exp__cpu(*$(at::Tensor* _self))); }|]

_exp__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_exp__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_exp__cuda(*$(at::Tensor* _self))); }|]

_exp_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_exp_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_exp_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_exp_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_exp_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_exp_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

expm1_t :: Ptr Tensor -> IO (Ptr Tensor)
expm1_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::expm1(*$(at::Tensor* _self))); }|]

_expm1__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_expm1__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_expm1__cpu(*$(at::Tensor* _self))); }|]

_expm1__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_expm1__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_expm1__cuda(*$(at::Tensor* _self))); }|]

_expm1_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_expm1_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_expm1_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_expm1_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_expm1_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_expm1_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

expand_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
expand_tlb _self _size _implicit = [C.block| at::Tensor* { return new at::Tensor(at::native::expand(*$(at::Tensor* _self), *$(at::IntArrayRef* _size), $(bool _implicit))); }|]

expand_as_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
expand_as_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::expand_as(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

eye_io :: Int -> Ptr TensorOptions -> IO (Ptr Tensor)
eye_io _n _options = [C.block| at::Tensor* { return new at::Tensor(at::native::eye($(int _n), *$(at::TensorOptions* _options))); }|]

eye_iio :: Int -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
eye_iio _n _m _options = [C.block| at::Tensor* { return new at::Tensor(at::native::eye($(int _n), $(int _m), *$(at::TensorOptions* _options))); }|]

eye_out_cpu_iT :: Int -> Ptr Tensor -> IO (Ptr Tensor)
eye_out_cpu_iT _n _out = [C.block| at::Tensor* { return new at::Tensor(at::native::eye_out_cpu($(int _n), *$(at::Tensor* _out))); }|]

eye_out_cuda_iT :: Int -> Ptr Tensor -> IO (Ptr Tensor)
eye_out_cuda_iT _n _out = [C.block| at::Tensor* { return new at::Tensor(at::native::eye_out_cuda($(int _n), *$(at::Tensor* _out))); }|]

eye_out_cpu_iiT :: Int -> Int -> Ptr Tensor -> IO (Ptr Tensor)
eye_out_cpu_iiT _n _m _out = [C.block| at::Tensor* { return new at::Tensor(at::native::eye_out_cpu($(int _n), $(int _m), *$(at::Tensor* _out))); }|]

eye_out_cuda_iiT :: Int -> Int -> Ptr Tensor -> IO (Ptr Tensor)
eye_out_cuda_iiT _n _m _out = [C.block| at::Tensor* { return new at::Tensor(at::native::eye_out_cuda($(int _n), $(int _m), *$(at::Tensor* _out))); }|]

flatten_tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
flatten_tii _self _start_dim _end_dim = [C.block| at::Tensor* { return new at::Tensor(at::native::flatten(*$(at::Tensor* _self), $(int _start_dim), $(int _end_dim))); }|]

fill__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
fill__Ts _self _value = [C.block| at::Tensor* { return new at::Tensor(at::native::fill_(*$(at::Tensor* _self), *$(at::Scalar* _value))); }|]

fill__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
fill__Tt _self _value = [C.block| at::Tensor* { return new at::Tensor(at::native::fill_(*$(at::Tensor* _self), *$(at::Tensor* _value))); }|]

floor_t :: Ptr Tensor -> IO (Ptr Tensor)
floor_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::floor(*$(at::Tensor* _self))); }|]

_floor__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_floor__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_floor__cpu(*$(at::Tensor* _self))); }|]

_floor__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_floor__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_floor__cuda(*$(at::Tensor* _self))); }|]

_floor_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_floor_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_floor_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_floor_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_floor_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_floor_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

full_lso :: Ptr IntList -> Ptr Scalar -> Ptr TensorOptions -> IO (Ptr Tensor)
full_lso _size _fill_value _options = [C.block| at::Tensor* { return new at::Tensor(at::native::full(*$(at::IntArrayRef* _size), *$(at::Scalar* _fill_value), *$(at::TensorOptions* _options))); }|]

full_lsT :: Ptr IntList -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
full_lsT _size _fill_value _out = [C.block| at::Tensor* { return new at::Tensor(at::native::full(*$(at::IntArrayRef* _size), *$(at::Scalar* _fill_value), *$(at::Tensor* _out))); }|]

full_like_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
full_like_ts _self _fill_value = [C.block| at::Tensor* { return new at::Tensor(at::native::full_like(*$(at::Tensor* _self), *$(at::Scalar* _fill_value))); }|]

full_like_tso :: Ptr Tensor -> Ptr Scalar -> Ptr TensorOptions -> IO (Ptr Tensor)
full_like_tso _self _fill_value _options = [C.block| at::Tensor* { return new at::Tensor(at::native::full_like(*$(at::Tensor* _self), *$(at::Scalar* _fill_value), *$(at::TensorOptions* _options))); }|]

grid_sampler_ttii :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
grid_sampler_ttii _input _grid _interpolation_mode _padding_mode = [C.block| at::Tensor* { return new at::Tensor(at::native::grid_sampler(*$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

grid_sampler_2d_cpu_ttii :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
grid_sampler_2d_cpu_ttii _input _grid _interpolation_mode _padding_mode = [C.block| at::Tensor* { return new at::Tensor(at::native::grid_sampler_2d_cpu(*$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

grid_sampler_2d_cuda_ttii :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
grid_sampler_2d_cuda_ttii _input _grid _interpolation_mode _padding_mode = [C.block| at::Tensor* { return new at::Tensor(at::native::grid_sampler_2d_cuda(*$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

grid_sampler_2d_backward_cpu_tttii :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr (Tensor,Tensor))
grid_sampler_2d_backward_cpu_tttii _grad_output _input _grid _interpolation_mode _padding_mode = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::grid_sampler_2d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

grid_sampler_2d_backward_cuda_tttii :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr (Tensor,Tensor))
grid_sampler_2d_backward_cuda_tttii _grad_output _input _grid _interpolation_mode _padding_mode = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::grid_sampler_2d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

grid_sampler_3d_cpu_ttii :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
grid_sampler_3d_cpu_ttii _input _grid _interpolation_mode _padding_mode = [C.block| at::Tensor* { return new at::Tensor(at::native::grid_sampler_3d_cpu(*$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

grid_sampler_3d_cuda_ttii :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
grid_sampler_3d_cuda_ttii _input _grid _interpolation_mode _padding_mode = [C.block| at::Tensor* { return new at::Tensor(at::native::grid_sampler_3d_cuda(*$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

grid_sampler_3d_backward_cpu_tttii :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr (Tensor,Tensor))
grid_sampler_3d_backward_cpu_tttii _grad_output _input _grid _interpolation_mode _padding_mode = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::grid_sampler_3d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

grid_sampler_3d_backward_cuda_tttii :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr (Tensor,Tensor))
grid_sampler_3d_backward_cuda_tttii _grad_output _input _grid _interpolation_mode _padding_mode = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::grid_sampler_3d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _input), *$(at::Tensor* _grid), $(int _interpolation_mode), $(int _padding_mode))); }|]

hann_window_io :: Int -> Ptr TensorOptions -> IO (Ptr Tensor)
hann_window_io _window_length _options = [C.block| at::Tensor* { return new at::Tensor(at::native::hann_window($(int _window_length), *$(at::TensorOptions* _options))); }|]

hann_window_ibo :: Int -> CBool -> Ptr TensorOptions -> IO (Ptr Tensor)
hann_window_ibo _window_length _periodic _options = [C.block| at::Tensor* { return new at::Tensor(at::native::hann_window($(int _window_length), $(bool _periodic), *$(at::TensorOptions* _options))); }|]

hamming_window_io :: Int -> Ptr TensorOptions -> IO (Ptr Tensor)
hamming_window_io _window_length _options = [C.block| at::Tensor* { return new at::Tensor(at::native::hamming_window($(int _window_length), *$(at::TensorOptions* _options))); }|]

hamming_window_ibo :: Int -> CBool -> Ptr TensorOptions -> IO (Ptr Tensor)
hamming_window_ibo _window_length _periodic _options = [C.block| at::Tensor* { return new at::Tensor(at::native::hamming_window($(int _window_length), $(bool _periodic), *$(at::TensorOptions* _options))); }|]

hamming_window_ibfo :: Int -> CBool -> CFloat -> Ptr TensorOptions -> IO (Ptr Tensor)
hamming_window_ibfo _window_length _periodic _alpha _options = [C.block| at::Tensor* { return new at::Tensor(at::native::hamming_window($(int _window_length), $(bool _periodic), $(float _alpha), *$(at::TensorOptions* _options))); }|]

hamming_window_ibffo :: Int -> CBool -> CFloat -> CFloat -> Ptr TensorOptions -> IO (Ptr Tensor)
hamming_window_ibffo _window_length _periodic _alpha _beta _options = [C.block| at::Tensor* { return new at::Tensor(at::native::hamming_window($(int _window_length), $(bool _periodic), $(float _alpha), $(float _beta), *$(at::TensorOptions* _options))); }|]

hinge_embedding_loss_ttfi :: Ptr Tensor -> Ptr Tensor -> CFloat -> Int -> IO (Ptr Tensor)
hinge_embedding_loss_ttfi _self _target _margin _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::hinge_embedding_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(float _margin), $(int _reduction))); }|]

ger_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
ger_tt _self _vec2 = [C.block| at::Tensor* { return new at::Tensor(at::native::ger(*$(at::Tensor* _self), *$(at::Tensor* _vec2))); }|]

ger_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
ger_ttT _self _vec2 _out = [C.block| at::Tensor* { return new at::Tensor(at::native::ger(*$(at::Tensor* _self), *$(at::Tensor* _vec2), *$(at::Tensor* _out))); }|]

gesv_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
gesv_tt _self _A = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gesv(*$(at::Tensor* _self), *$(at::Tensor* _A))); }|]

gesv_ttTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
gesv_ttTT _self _A _solution _lu = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gesv(*$(at::Tensor* _self), *$(at::Tensor* _A), *$(at::Tensor* _solution), *$(at::Tensor* _lu))); }|]

_gesv_helper_cpu_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
_gesv_helper_cpu_tt _self _A = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_gesv_helper_cpu(*$(at::Tensor* _self), *$(at::Tensor* _A))); }|]

_gesv_helper_cuda_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
_gesv_helper_cuda_tt _self _A = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_gesv_helper_cuda(*$(at::Tensor* _self), *$(at::Tensor* _A))); }|]

group_norm_tittfb :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
group_norm_tittfb _input _num_groups _weight _bias _eps _cudnn_enabled = [C.block| at::Tensor* { return new at::Tensor(at::native::group_norm(*$(at::Tensor* _input), $(int _num_groups), *$(at::Tensor* _weight), *$(at::Tensor* _bias), $(float _eps), $(bool _cudnn_enabled))); }|]

fft_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
fft_tib _self _signal_ndim _normalized = [C.block| at::Tensor* { return new at::Tensor(at::native::fft(*$(at::Tensor* _self), $(int _signal_ndim), $(bool _normalized))); }|]

ifft_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
ifft_tib _self _signal_ndim _normalized = [C.block| at::Tensor* { return new at::Tensor(at::native::ifft(*$(at::Tensor* _self), $(int _signal_ndim), $(bool _normalized))); }|]

rfft_tibb :: Ptr Tensor -> Int -> CBool -> CBool -> IO (Ptr Tensor)
rfft_tibb _self _signal_ndim _normalized _onesided = [C.block| at::Tensor* { return new at::Tensor(at::native::rfft(*$(at::Tensor* _self), $(int _signal_ndim), $(bool _normalized), $(bool _onesided))); }|]

irfft_tibbl :: Ptr Tensor -> Int -> CBool -> CBool -> Ptr IntList -> IO (Ptr Tensor)
irfft_tibbl _self _signal_ndim _normalized _onesided _signal_sizes = [C.block| at::Tensor* { return new at::Tensor(at::native::irfft(*$(at::Tensor* _self), $(int _signal_ndim), $(bool _normalized), $(bool _onesided), *$(at::IntArrayRef* _signal_sizes))); }|]

_fft_mkl_tibbblbbl :: Ptr Tensor -> Int -> CBool -> CBool -> CBool -> Ptr IntList -> CBool -> CBool -> Ptr IntList -> IO (Ptr Tensor)
_fft_mkl_tibbblbbl _self _signal_ndim _complex_input _complex_output _inverse _checked_signal_sizes _normalized _onesided _output_sizes = [C.block| at::Tensor* { return new at::Tensor(at::native::_fft_mkl(*$(at::Tensor* _self), $(int _signal_ndim), $(bool _complex_input), $(bool _complex_output), $(bool _inverse), *$(at::IntArrayRef* _checked_signal_sizes), $(bool _normalized), $(bool _onesided), *$(at::IntArrayRef* _output_sizes))); }|]

_fft_cufft_tibbblbbl :: Ptr Tensor -> Int -> CBool -> CBool -> CBool -> Ptr IntList -> CBool -> CBool -> Ptr IntList -> IO (Ptr Tensor)
_fft_cufft_tibbblbbl _self _signal_ndim _complex_input _complex_output _inverse _checked_signal_sizes _normalized _onesided _output_sizes = [C.block| at::Tensor* { return new at::Tensor(at::native::_fft_cufft(*$(at::Tensor* _self), $(int _signal_ndim), $(bool _complex_input), $(bool _complex_output), $(bool _inverse), *$(at::IntArrayRef* _checked_signal_sizes), $(bool _normalized), $(bool _onesided), *$(at::IntArrayRef* _output_sizes))); }|]

_cufft_get_plan_cache_size_ :: IO (Int)
_cufft_get_plan_cache_size_  = [C.block| int { return (at::native::_cufft_get_plan_cache_size()); }|]

_cufft_get_plan_cache_max_size_ :: IO (Int)
_cufft_get_plan_cache_max_size_  = [C.block| int { return (at::native::_cufft_get_plan_cache_max_size()); }|]

_cufft_set_plan_cache_max_size_i :: Int -> IO ()
_cufft_set_plan_cache_max_size_i _max_size = [C.block| void {  (at::native::_cufft_set_plan_cache_max_size($(int _max_size))); }|]

_cufft_clear_plan_cache_ :: IO ()
_cufft_clear_plan_cache_  = [C.block| void {  (at::native::_cufft_clear_plan_cache()); }|]

index_tl :: Ptr Tensor -> Ptr TensorList -> IO (Ptr Tensor)
index_tl _self _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::index(*$(at::Tensor* _self), *$(at::TensorList* _indices))); }|]

index_copy__Titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
index_copy__Titt _self _dim _index _source = [C.block| at::Tensor* { return new at::Tensor(at::native::index_copy_(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _source))); }|]

index_copy_titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
index_copy_titt _self _dim _index _source = [C.block| at::Tensor* { return new at::Tensor(at::native::index_copy(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _source))); }|]

index_put__Tltb :: Ptr Tensor -> Ptr TensorList -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
index_put__Tltb _self _indices _values _accumulate = [C.block| at::Tensor* { return new at::Tensor(at::native::index_put_(*$(at::Tensor* _self), *$(at::TensorList* _indices), *$(at::Tensor* _values), $(bool _accumulate))); }|]

index_put_tltb :: Ptr Tensor -> Ptr TensorList -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
index_put_tltb _self _indices _values _accumulate = [C.block| at::Tensor* { return new at::Tensor(at::native::index_put(*$(at::Tensor* _self), *$(at::TensorList* _indices), *$(at::Tensor* _values), $(bool _accumulate))); }|]

instance_norm_tttttbffb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CFloat -> CFloat -> CBool -> IO (Ptr Tensor)
instance_norm_tttttbffb _input _weight _bias _running_mean _running_var _use_input_stats _momentum _eps _cudnn_enabled = [C.block| at::Tensor* { return new at::Tensor(at::native::instance_norm(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(bool _use_input_stats), $(float _momentum), $(float _eps), $(bool _cudnn_enabled))); }|]

inverse_t :: Ptr Tensor -> IO (Ptr Tensor)
inverse_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::inverse(*$(at::Tensor* _self))); }|]

inverse_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
inverse_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::inverse(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_inverse_helper_cpu_t :: Ptr Tensor -> IO (Ptr Tensor)
_inverse_helper_cpu_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_inverse_helper_cpu(*$(at::Tensor* _self))); }|]

_inverse_helper_cuda_t :: Ptr Tensor -> IO (Ptr Tensor)
_inverse_helper_cuda_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_inverse_helper_cuda(*$(at::Tensor* _self))); }|]

isclose_ttffb :: Ptr Tensor -> Ptr Tensor -> CFloat -> CFloat -> CBool -> IO (Ptr Tensor)
isclose_ttffb _self _other _rtol _atol _equal_nan = [C.block| at::Tensor* { return new at::Tensor(at::native::isclose(*$(at::Tensor* _self), *$(at::Tensor* _other), $(float _rtol), $(float _atol), $(bool _equal_nan))); }|]

isnan_t :: Ptr Tensor -> IO (Ptr Tensor)
isnan_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::isnan(*$(at::Tensor* _self))); }|]

is_distributed_t :: Ptr Tensor -> IO (CBool)
is_distributed_t _self = [C.block| bool { return (at::native::is_distributed(*$(at::Tensor* _self))); }|]

is_floating_point_t :: Ptr Tensor -> IO (CBool)
is_floating_point_t _self = [C.block| bool { return (at::native::is_floating_point(*$(at::Tensor* _self))); }|]

is_complex_t :: Ptr Tensor -> IO (CBool)
is_complex_t _self = [C.block| bool { return (at::native::is_complex(*$(at::Tensor* _self))); }|]

is_nonzero_t :: Ptr Tensor -> IO (CBool)
is_nonzero_t _self = [C.block| bool { return (at::native::is_nonzero(*$(at::Tensor* _self))); }|]

is_same_size_tt :: Ptr Tensor -> Ptr Tensor -> IO (CBool)
is_same_size_tt _self _other = [C.block| bool { return (at::native::is_same_size(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

is_signed_t :: Ptr Tensor -> IO (CBool)
is_signed_t _self = [C.block| bool { return (at::native::is_signed(*$(at::Tensor* _self))); }|]

kl_div_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
kl_div_tti _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::kl_div(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

kl_div_backward_cpu_ttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
kl_div_backward_cpu_ttti _grad_output _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::kl_div_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

kl_div_backward_cuda_ttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
kl_div_backward_cuda_ttti _grad_output _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::kl_div_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

kthvalue_tiib :: Ptr Tensor -> Int -> Int -> CBool -> IO (Ptr (Tensor,Tensor))
kthvalue_tiib _self _k _dim _keepdim = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::kthvalue(*$(at::Tensor* _self), $(int _k), $(int _dim), $(bool _keepdim))); }|]

kthvalue_tiibTT :: Ptr Tensor -> Int -> Int -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
kthvalue_tiibTT _self _k _dim _keepdim _values _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::kthvalue(*$(at::Tensor* _self), $(int _k), $(int _dim), $(bool _keepdim), *$(at::Tensor* _values), *$(at::Tensor* _indices))); }|]

layer_norm_tlttfb :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
layer_norm_tlttfb _input _normalized_shape _weight _bias _eps _cudnn_enable = [C.block| at::Tensor* { return new at::Tensor(at::native::layer_norm(*$(at::Tensor* _input), *$(at::IntArrayRef* _normalized_shape), *$(at::Tensor* _weight), *$(at::Tensor* _bias), $(float _eps), $(bool _cudnn_enable))); }|]

linear_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
linear_ttt _input _weight _bias = [C.block| at::Tensor* { return new at::Tensor(at::native::linear(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias))); }|]

fbgemm_linear_int8_weight_ttttsst :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
fbgemm_linear_int8_weight_ttttsst _input _weight _packed _col_offsets _weight_scale _weight_zero_point _bias = [C.block| at::Tensor* { return new at::Tensor(at::native::fbgemm_linear_int8_weight(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _packed), *$(at::Tensor* _col_offsets), *$(at::Scalar* _weight_scale), *$(at::Scalar* _weight_zero_point), *$(at::Tensor* _bias))); }|]

fbgemm_linear_quantize_weight_t :: Ptr Tensor -> IO (Ptr (Tensor,Tensor,CFloat,Int))
fbgemm_linear_quantize_weight_t _input = [C.block| std::tuple<at::Tensor,at::Tensor,float,int>* { return new std::tuple<at::Tensor,at::Tensor,float,int>(at::native::fbgemm_linear_quantize_weight(*$(at::Tensor* _input))); }|]

fbgemm_pack_quantized_matrix_tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
fbgemm_pack_quantized_matrix_tii _input _K _N = [C.block| at::Tensor* { return new at::Tensor(at::native::fbgemm_pack_quantized_matrix(*$(at::Tensor* _input), $(int _K), $(int _N))); }|]

fbgemm_is_cpu_supported_ :: IO (CBool)
fbgemm_is_cpu_supported_  = [C.block| bool { return (at::native::fbgemm_is_cpu_supported()); }|]

linspace_ssio :: Ptr Scalar -> Ptr Scalar -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
linspace_ssio _start _end _steps _options = [C.block| at::Tensor* { return new at::Tensor(at::native::linspace(*$(at::Scalar* _start), *$(at::Scalar* _end), $(int _steps), *$(at::TensorOptions* _options))); }|]

linspace_cpu_out_ssiT :: Ptr Scalar -> Ptr Scalar -> Int -> Ptr Tensor -> IO (Ptr Tensor)
linspace_cpu_out_ssiT _start _end _steps _out = [C.block| at::Tensor* { return new at::Tensor(at::native::linspace_cpu_out(*$(at::Scalar* _start), *$(at::Scalar* _end), $(int _steps), *$(at::Tensor* _out))); }|]

linspace_cuda_out_ssiT :: Ptr Scalar -> Ptr Scalar -> Int -> Ptr Tensor -> IO (Ptr Tensor)
linspace_cuda_out_ssiT _start _end _steps _out = [C.block| at::Tensor* { return new at::Tensor(at::native::linspace_cuda_out(*$(at::Scalar* _start), *$(at::Scalar* _end), $(int _steps), *$(at::Tensor* _out))); }|]

log_t :: Ptr Tensor -> IO (Ptr Tensor)
log_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::log(*$(at::Tensor* _self))); }|]

_log__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_log__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_log__cpu(*$(at::Tensor* _self))); }|]

_log__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_log__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_log__cuda(*$(at::Tensor* _self))); }|]

_log_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_log_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_log_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_log_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_log_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_log_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

log10_t :: Ptr Tensor -> IO (Ptr Tensor)
log10_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::log10(*$(at::Tensor* _self))); }|]

_log10__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_log10__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_log10__cpu(*$(at::Tensor* _self))); }|]

_log10__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_log10__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_log10__cuda(*$(at::Tensor* _self))); }|]

_log10_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_log10_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_log10_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_log10_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_log10_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_log10_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

log1p_t :: Ptr Tensor -> IO (Ptr Tensor)
log1p_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::log1p(*$(at::Tensor* _self))); }|]

_log1p__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_log1p__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_log1p__cpu(*$(at::Tensor* _self))); }|]

_log1p__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_log1p__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_log1p__cuda(*$(at::Tensor* _self))); }|]

log1p_sparse__T :: Ptr Tensor -> IO (Ptr Tensor)
log1p_sparse__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::log1p_sparse_(*$(at::Tensor* _self))); }|]

_log1p_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_log1p_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_log1p_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_log1p_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_log1p_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_log1p_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

log1p_out_sparse_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
log1p_out_sparse_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::log1p_out_sparse(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

log2_t :: Ptr Tensor -> IO (Ptr Tensor)
log2_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::log2(*$(at::Tensor* _self))); }|]

_log2__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_log2__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_log2__cpu(*$(at::Tensor* _self))); }|]

_log2__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_log2__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_log2__cuda(*$(at::Tensor* _self))); }|]

_log2_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_log2_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_log2_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_log2_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_log2_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_log2_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

logdet_t :: Ptr Tensor -> IO (Ptr Tensor)
logdet_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::logdet(*$(at::Tensor* _self))); }|]

logspace_ssio :: Ptr Scalar -> Ptr Scalar -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
logspace_ssio _start _end _steps _options = [C.block| at::Tensor* { return new at::Tensor(at::native::logspace(*$(at::Scalar* _start), *$(at::Scalar* _end), $(int _steps), *$(at::TensorOptions* _options))); }|]

logspace_cpu_out_ssiT :: Ptr Scalar -> Ptr Scalar -> Int -> Ptr Tensor -> IO (Ptr Tensor)
logspace_cpu_out_ssiT _start _end _steps _out = [C.block| at::Tensor* { return new at::Tensor(at::native::logspace_cpu_out(*$(at::Scalar* _start), *$(at::Scalar* _end), $(int _steps), *$(at::Tensor* _out))); }|]

logspace_cuda_out_ssiT :: Ptr Scalar -> Ptr Scalar -> Int -> Ptr Tensor -> IO (Ptr Tensor)
logspace_cuda_out_ssiT _start _end _steps _out = [C.block| at::Tensor* { return new at::Tensor(at::native::logspace_cuda_out(*$(at::Scalar* _start), *$(at::Scalar* _end), $(int _steps), *$(at::Tensor* _out))); }|]

log_softmax_tis :: Ptr Tensor -> Int -> Ptr ScalarType -> IO (Ptr Tensor)
log_softmax_tis _self _dim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax(*$(at::Tensor* _self), $(int _dim), *$(at::ScalarType* _dtype))); }|]

log_softmax_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
log_softmax_ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax(*$(at::Tensor* _self), $(int _dim))); }|]

log_softmax_cpu_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
log_softmax_cpu_tib _self _dim _half_to_float = [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax_cpu(*$(at::Tensor* _self), $(int _dim), $(bool _half_to_float))); }|]

log_softmax_cuda_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
log_softmax_cuda_tib _self _dim _half_to_float = [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax_cuda(*$(at::Tensor* _self), $(int _dim), $(bool _half_to_float))); }|]

log_softmax_backward_cpu_ttit :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
log_softmax_backward_cpu_ttit _grad_output _output _dim _self = [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _output), $(int _dim), *$(at::Tensor* _self))); }|]

log_softmax_backward_cuda_ttit :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
log_softmax_backward_cuda_ttit _grad_output _output _dim _self = [C.block| at::Tensor* { return new at::Tensor(at::native::log_softmax_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _output), $(int _dim), *$(at::Tensor* _self))); }|]

logsumexp_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
logsumexp_tlb _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::logsumexp(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim))); }|]

logsumexp_tlbT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
logsumexp_tlbT _self _dim _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::logsumexp(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::Tensor* _out))); }|]

logsumexp_backward_tttlb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
logsumexp_backward_tttlb _grad _self _res _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::logsumexp_backward(*$(at::Tensor* _grad), *$(at::Tensor* _self), *$(at::Tensor* _res), *$(at::IntArrayRef* _dim), $(bool _keepdim))); }|]

margin_ranking_loss_tttfi :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CFloat -> Int -> IO (Ptr Tensor)
margin_ranking_loss_tttfi _input1 _input2 _target _margin _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::margin_ranking_loss(*$(at::Tensor* _input1), *$(at::Tensor* _input2), *$(at::Tensor* _target), $(float _margin), $(int _reduction))); }|]

matmul_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
matmul_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::matmul(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

matmul_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
matmul_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::matmul(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

matrix_rank_tfb :: Ptr Tensor -> CFloat -> CBool -> IO (Ptr Tensor)
matrix_rank_tfb _self _tol _symmetric = [C.block| at::Tensor* { return new at::Tensor(at::native::matrix_rank(*$(at::Tensor* _self), $(float _tol), $(bool _symmetric))); }|]

matrix_rank_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
matrix_rank_tb _self _symmetric = [C.block| at::Tensor* { return new at::Tensor(at::native::matrix_rank(*$(at::Tensor* _self), $(bool _symmetric))); }|]

matrix_power_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
matrix_power_ti _self _n = [C.block| at::Tensor* { return new at::Tensor(at::native::matrix_power(*$(at::Tensor* _self), $(int _n))); }|]

max_tlb :: Ptr Tensor -> Int64 -> CBool -> IO (Ptr (Tensor,Tensor))
max_tlb _self _dim _keepdim = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max(*$(at::Tensor* _self), $(int64_t _dim), $(bool _keepdim))); }|]

max_tlbTT :: Ptr Tensor -> Int64 -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
max_tlbTT _self _dim _keepdim _max _max_values = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max(*$(at::Tensor* _self), $(int64_t _dim), $(bool _keepdim), *$(at::Tensor* _max), *$(at::Tensor* _max_values))); }|]

max_values_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
max_values_tlb _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::max_values(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim))); }|]

max_pool1d_with_indices_tllllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr (Tensor,Tensor))
max_pool1d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool1d_with_indices(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode))); }|]

max_pool1d_tllllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr Tensor)
max_pool1d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode = [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool1d(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode))); }|]

max_pool2d_tllllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr Tensor)
max_pool2d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode = [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode))); }|]

max_pool3d_tllllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr Tensor)
max_pool3d_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode = [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode))); }|]

mean_ts :: Ptr Tensor -> Ptr ScalarType -> IO (Ptr Tensor)
mean_ts _self _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::mean(*$(at::Tensor* _self), *$(at::ScalarType* _dtype))); }|]

mean_t :: Ptr Tensor -> IO (Ptr Tensor)
mean_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::mean(*$(at::Tensor* _self))); }|]

mean_tlbs :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr ScalarType -> IO (Ptr Tensor)
mean_tlbs _self _dim _keepdim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::mean(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::ScalarType* _dtype))); }|]

mean_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
mean_tlb _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::mean(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim))); }|]

mean_tls :: Ptr Tensor -> Ptr IntList -> Ptr ScalarType -> IO (Ptr Tensor)
mean_tls _self _dim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::mean(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), *$(at::ScalarType* _dtype))); }|]

mean_tlbsT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
mean_tlbsT _self _dim _keepdim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mean(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

mean_tlbT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
mean_tlbT _self _dim _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mean(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::Tensor* _out))); }|]

mean_tlsT :: Ptr Tensor -> Ptr IntList -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
mean_tlsT _self _dim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mean(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

sum_backward_tllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr Tensor)
sum_backward_tllb _grad _sizes _dims _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::sum_backward(*$(at::Tensor* _grad), *$(at::IntArrayRef* _sizes), *$(at::IntArrayRef* _dims), $(bool _keepdim))); }|]

median_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr (Tensor,Tensor))
median_tib _self _dim _keepdim = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::median(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

median_tibTT :: Ptr Tensor -> Int -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
median_tibTT _self _dim _keepdim _values _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::median(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim), *$(at::Tensor* _values), *$(at::Tensor* _indices))); }|]

min_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr (Tensor,Tensor))
min_tib _self _dim _keepdim = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::min(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

min_tibTT :: Ptr Tensor -> Int -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
min_tibTT _self _dim _keepdim _min _min_indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::min(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim), *$(at::Tensor* _min), *$(at::Tensor* _min_indices))); }|]

min_values_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
min_values_tlb _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::min_values(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim))); }|]

mkldnn_convolution_tttllli :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> IO (Ptr Tensor)
mkldnn_convolution_tttllli _self _weight _bias _padding _stride _dilation _groups = [C.block| at::Tensor* { return new at::Tensor(at::native::mkldnn_convolution(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups))); }|]

mkldnn_convolution_backward_input_lttlllib :: Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> IO (Ptr Tensor)
mkldnn_convolution_backward_input_lttlllib _self_size _grad_output _weight _padding _stride _dilation _groups _bias_defined = [C.block| at::Tensor* { return new at::Tensor(at::native::mkldnn_convolution_backward_input(*$(at::IntArrayRef* _self_size), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _bias_defined))); }|]

mkldnn_convolution_backward_weights_lttlllib :: Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> IO (Ptr (Tensor,Tensor))
mkldnn_convolution_backward_weights_lttlllib _weight_size _grad_output _self _padding _stride _dilation _groups _bias_defined = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::mkldnn_convolution_backward_weights(*$(at::IntArrayRef* _weight_size), *$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _bias_defined))); }|]

mkldnn_convolution_backward_tttlllia :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
mkldnn_convolution_backward_tttlllia _self _grad_output _weight _padding _stride _dilation _groups _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::mkldnn_convolution_backward(*$(at::Tensor* _self), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), *$(std::array<bool,3>* _output_mask))); }|]

miopen_batch_norm_tttttbff :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CFloat -> CFloat -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_batch_norm_tttttbff _input _weight _bias _running_mean _running_var _training _exponential_average_factor _epsilon = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::miopen_batch_norm(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(bool _training), $(float _exponential_average_factor), $(float _epsilon))); }|]

miopen_batch_norm_backward_tttttttf :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CFloat -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_batch_norm_backward_tttttttf _input _grad_output _weight _running_mean _running_var _save_mean _save_var _epsilon = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::miopen_batch_norm_backward(*$(at::Tensor* _input), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), *$(at::Tensor* _save_mean), *$(at::Tensor* _save_var), $(float _epsilon))); }|]

miopen_convolution_tttlllibb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
miopen_convolution_tttlllibb _self _weight _bias _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::miopen_convolution(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

miopen_convolution_backward_input_lttlllibb :: Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
miopen_convolution_backward_input_lttlllibb _self_size _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::miopen_convolution_backward_input(*$(at::IntArrayRef* _self_size), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

miopen_convolution_backward_tttlllibba :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_convolution_backward_tttlllibba _self _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::miopen_convolution_backward(*$(at::Tensor* _self), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic), *$(std::array<bool,3>* _output_mask))); }|]

miopen_convolution_backward_bias_t :: Ptr Tensor -> IO (Ptr Tensor)
miopen_convolution_backward_bias_t _grad_output = [C.block| at::Tensor* { return new at::Tensor(at::native::miopen_convolution_backward_bias(*$(at::Tensor* _grad_output))); }|]

miopen_convolution_backward_weight_lttlllibb :: Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
miopen_convolution_backward_weight_lttlllibb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::miopen_convolution_backward_weight(*$(at::IntArrayRef* _weight_size), *$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

miopen_convolution_transpose_tttllllibb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
miopen_convolution_transpose_tttllllibb _self _weight _bias _padding _output_padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::miopen_convolution_transpose(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

miopen_convolution_transpose_backward_tttllllibba :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
miopen_convolution_transpose_backward_tttllllibba _self _grad_output _weight _padding _output_padding _stride _dilation _groups _benchmark _deterministic _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::miopen_convolution_transpose_backward(*$(at::Tensor* _self), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic), *$(std::array<bool,3>* _output_mask))); }|]

miopen_convolution_transpose_backward_input_ttlllibb :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
miopen_convolution_transpose_backward_input_ttlllibb _grad_output _weight _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::miopen_convolution_transpose_backward_input(*$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

miopen_convolution_transpose_backward_weight_lttlllibb :: Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> CBool -> CBool -> IO (Ptr Tensor)
miopen_convolution_transpose_backward_weight_lttlllibb _weight_size _grad_output _self _padding _stride _dilation _groups _benchmark _deterministic = [C.block| at::Tensor* { return new at::Tensor(at::native::miopen_convolution_transpose_backward_weight(*$(at::IntArrayRef* _weight_size), *$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _dilation), $(int _groups), $(bool _benchmark), $(bool _deterministic))); }|]

mm_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mm_tt _self _mat2 = [C.block| at::Tensor* { return new at::Tensor(at::native::mm(*$(at::Tensor* _self), *$(at::Tensor* _mat2))); }|]

mm_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mm_ttT _self _mat2 _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mm(*$(at::Tensor* _self), *$(at::Tensor* _mat2), *$(at::Tensor* _out))); }|]

_sparse_mm_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sparse_mm_tt _sparse _dense = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_mm(*$(at::Tensor* _sparse), *$(at::Tensor* _dense))); }|]

mode_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr (Tensor,Tensor))
mode_tib _self _dim _keepdim = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::mode(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

mode_tibTT :: Ptr Tensor -> Int -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
mode_tibTT _self _dim _keepdim _values _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::mode(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim), *$(at::Tensor* _values), *$(at::Tensor* _indices))); }|]

mul_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mul_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::mul(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

mul__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mul__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::mul_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

mul_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mul_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mul(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

mul_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
mul_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::mul(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

mul__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
mul__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::mul_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

mv_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mv_tt _self _vec = [C.block| at::Tensor* { return new at::Tensor(at::native::mv(*$(at::Tensor* _self), *$(at::Tensor* _vec))); }|]

mv_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mv_ttT _self _vec _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mv(*$(at::Tensor* _self), *$(at::Tensor* _vec), *$(at::Tensor* _out))); }|]

mvlgamma_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
mvlgamma_ti _self _p = [C.block| at::Tensor* { return new at::Tensor(at::native::mvlgamma(*$(at::Tensor* _self), $(int _p))); }|]

mvlgamma__Ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
mvlgamma__Ti _self _p = [C.block| at::Tensor* { return new at::Tensor(at::native::mvlgamma_(*$(at::Tensor* _self), $(int _p))); }|]

narrow_copy_dense_tiii :: Ptr Tensor -> Int -> Int -> Int -> IO (Ptr Tensor)
narrow_copy_dense_tiii _self _dim _start _length = [C.block| at::Tensor* { return new at::Tensor(at::native::narrow_copy_dense(*$(at::Tensor* _self), $(int _dim), $(int _start), $(int _length))); }|]

narrow_copy_sparse_tiii :: Ptr Tensor -> Int -> Int -> Int -> IO (Ptr Tensor)
narrow_copy_sparse_tiii _self _dim _start _length = [C.block| at::Tensor* { return new at::Tensor(at::native::narrow_copy_sparse(*$(at::Tensor* _self), $(int _dim), $(int _start), $(int _length))); }|]

narrow_tiii :: Ptr Tensor -> Int -> Int -> Int -> IO (Ptr Tensor)
narrow_tiii _self _dim _start _length = [C.block| at::Tensor* { return new at::Tensor(at::native::narrow(*$(at::Tensor* _self), $(int _dim), $(int _start), $(int _length))); }|]

batch_norm_cpu_tttttbff :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CFloat -> CFloat -> IO (Ptr (Tensor,Tensor,Tensor))
batch_norm_cpu_tttttbff _input _weight _bias _running_mean _running_var _training _momentum _eps = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::batch_norm_cpu(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(bool _training), $(float _momentum), $(float _eps))); }|]

batch_norm_cuda_tttttbff :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CFloat -> CFloat -> IO (Ptr (Tensor,Tensor,Tensor))
batch_norm_cuda_tttttbff _input _weight _bias _running_mean _running_var _training _momentum _eps = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::batch_norm_cuda(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(bool _training), $(float _momentum), $(float _eps))); }|]

batch_norm_backward_cpu_tttttttbfa :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CFloat -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
batch_norm_backward_cpu_tttttttbfa _grad_out _input _weight _running_mean _running_var _save_mean _save_invstd _train _eps _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::batch_norm_backward_cpu(*$(at::Tensor* _grad_out), *$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), *$(at::Tensor* _save_mean), *$(at::Tensor* _save_invstd), $(bool _train), $(float _eps), *$(std::array<bool,3>* _output_mask))); }|]

batch_norm_backward_cuda_tttttttbfa :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CFloat -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
batch_norm_backward_cuda_tttttttbfa _grad_out _input _weight _running_mean _running_var _save_mean _save_invstd _train _eps _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::batch_norm_backward_cuda(*$(at::Tensor* _grad_out), *$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), *$(at::Tensor* _save_mean), *$(at::Tensor* _save_invstd), $(bool _train), $(float _eps), *$(std::array<bool,3>* _output_mask))); }|]

batch_norm_update_stats_cpu_tttf :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CFloat -> IO (Ptr (Tensor,Tensor))
batch_norm_update_stats_cpu_tttf _input _running_mean _running_var _momentum = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::batch_norm_update_stats_cpu(*$(at::Tensor* _input), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(float _momentum))); }|]

batch_norm_update_stats_cuda_tttf :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CFloat -> IO (Ptr (Tensor,Tensor))
batch_norm_update_stats_cuda_tttf _input _running_mean _running_var _momentum = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::batch_norm_update_stats_cuda(*$(at::Tensor* _input), *$(at::Tensor* _running_mean), *$(at::Tensor* _running_var), $(float _momentum))); }|]

_nnpack_available_ :: IO (CBool)
_nnpack_available_  = [C.block| bool { return (at::native::_nnpack_available()); }|]

_nnpack_spatial_convolution_tttl :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
_nnpack_spatial_convolution_tttl _input _weight _bias _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::_nnpack_spatial_convolution(*$(at::Tensor* _input), *$(at::Tensor* _weight), *$(at::Tensor* _bias), *$(at::IntArrayRef* _padding))); }|]

_nnpack_spatial_convolution_backward_tttla :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
_nnpack_spatial_convolution_backward_tttla _input _grad_output _weight _padding _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::_nnpack_spatial_convolution_backward(*$(at::Tensor* _input), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding), *$(std::array<bool,3>* _output_mask))); }|]

_nnpack_spatial_convolution_backward_input_tttl :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
_nnpack_spatial_convolution_backward_input_tttl _input _grad_output _weight _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::_nnpack_spatial_convolution_backward_input(*$(at::Tensor* _input), *$(at::Tensor* _grad_output), *$(at::Tensor* _weight), *$(at::IntArrayRef* _padding))); }|]

_nnpack_spatial_convolution_backward_weight_tltl :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
_nnpack_spatial_convolution_backward_weight_tltl _input _weightsize _grad_output _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::_nnpack_spatial_convolution_backward_weight(*$(at::Tensor* _input), *$(at::IntArrayRef* _weightsize), *$(at::Tensor* _grad_output), *$(at::IntArrayRef* _padding))); }|]

ones_lo :: Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
ones_lo _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::ones(*$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

ones_lT :: Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
ones_lT _size _out = [C.block| at::Tensor* { return new at::Tensor(at::native::ones(*$(at::IntArrayRef* _size), *$(at::Tensor* _out))); }|]

ones_like_t :: Ptr Tensor -> IO (Ptr Tensor)
ones_like_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::ones_like(*$(at::Tensor* _self))); }|]

ones_like_to :: Ptr Tensor -> Ptr TensorOptions -> IO (Ptr Tensor)
ones_like_to _self _options = [C.block| at::Tensor* { return new at::Tensor(at::native::ones_like(*$(at::Tensor* _self), *$(at::TensorOptions* _options))); }|]

pairwise_distance_ttffb :: Ptr Tensor -> Ptr Tensor -> CFloat -> CFloat -> CBool -> IO (Ptr Tensor)
pairwise_distance_ttffb _x1 _x2 _p _eps _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::pairwise_distance(*$(at::Tensor* _x1), *$(at::Tensor* _x2), $(float _p), $(float _eps), $(bool _keepdim))); }|]

cdist_ttd :: Ptr Tensor -> Ptr Tensor -> CDouble -> IO (Ptr Tensor)
cdist_ttd _x1 _x2 _p = [C.block| at::Tensor* { return new at::Tensor(at::native::cdist(*$(at::Tensor* _x1), *$(at::Tensor* _x2), $(double _p))); }|]

pdist_tf :: Ptr Tensor -> CFloat -> IO (Ptr Tensor)
pdist_tf _self _p = [C.block| at::Tensor* { return new at::Tensor(at::native::pdist(*$(at::Tensor* _self), $(float _p))); }|]

_pdist_forward_tf :: Ptr Tensor -> CFloat -> IO (Ptr Tensor)
_pdist_forward_tf _self _p = [C.block| at::Tensor* { return new at::Tensor(at::native::_pdist_forward(*$(at::Tensor* _self), $(float _p))); }|]

_pdist_backward_ttft :: Ptr Tensor -> Ptr Tensor -> CFloat -> Ptr Tensor -> IO (Ptr Tensor)
_pdist_backward_ttft _grad _self _p _pdist = [C.block| at::Tensor* { return new at::Tensor(at::native::_pdist_backward(*$(at::Tensor* _grad), *$(at::Tensor* _self), $(float _p), *$(at::Tensor* _pdist))); }|]

cosine_similarity_ttif :: Ptr Tensor -> Ptr Tensor -> Int -> CFloat -> IO (Ptr Tensor)
cosine_similarity_ttif _x1 _x2 _dim _eps = [C.block| at::Tensor* { return new at::Tensor(at::native::cosine_similarity(*$(at::Tensor* _x1), *$(at::Tensor* _x2), $(int _dim), $(float _eps))); }|]

permute_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
permute_tl _self _dims = [C.block| at::Tensor* { return new at::Tensor(at::native::permute(*$(at::Tensor* _self), *$(at::IntArrayRef* _dims))); }|]

permute_backwards_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
permute_backwards_tl _grad _fwd_dims = [C.block| at::Tensor* { return new at::Tensor(at::native::permute_backwards(*$(at::Tensor* _grad), *$(at::IntArrayRef* _fwd_dims))); }|]

pixel_shuffle_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
pixel_shuffle_ti _self _upscale_factor = [C.block| at::Tensor* { return new at::Tensor(at::native::pixel_shuffle(*$(at::Tensor* _self), $(int _upscale_factor))); }|]

pin_memory_t :: Ptr Tensor -> IO (Ptr Tensor)
pin_memory_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::pin_memory(*$(at::Tensor* _self))); }|]

pinverse_tf :: Ptr Tensor -> CFloat -> IO (Ptr Tensor)
pinverse_tf _self _rcond = [C.block| at::Tensor* { return new at::Tensor(at::native::pinverse(*$(at::Tensor* _self), $(float _rcond))); }|]

scalar_tensor_so :: Ptr Scalar -> Ptr TensorOptions -> IO (Ptr Tensor)
scalar_tensor_so _s _options = [C.block| at::Tensor* { return new at::Tensor(at::native::scalar_tensor(*$(at::Scalar* _s), *$(at::TensorOptions* _options))); }|]

rand_lo :: Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
rand_lo _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::rand(*$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

rand_lpo :: Ptr IntList -> Ptr Generator -> Ptr TensorOptions -> IO (Ptr Tensor)
rand_lpo _size _generator _options = [C.block| at::Tensor* { return new at::Tensor(at::native::rand(*$(at::IntArrayRef* _size), $(at::Generator * _generator), *$(at::TensorOptions* _options))); }|]

rand_lT :: Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
rand_lT _size _out = [C.block| at::Tensor* { return new at::Tensor(at::native::rand(*$(at::IntArrayRef* _size), *$(at::Tensor* _out))); }|]

rand_lpT :: Ptr IntList -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
rand_lpT _size _generator _out = [C.block| at::Tensor* { return new at::Tensor(at::native::rand(*$(at::IntArrayRef* _size), $(at::Generator * _generator), *$(at::Tensor* _out))); }|]

rand_like_t :: Ptr Tensor -> IO (Ptr Tensor)
rand_like_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::rand_like(*$(at::Tensor* _self))); }|]

rand_like_to :: Ptr Tensor -> Ptr TensorOptions -> IO (Ptr Tensor)
rand_like_to _self _options = [C.block| at::Tensor* { return new at::Tensor(at::native::rand_like(*$(at::Tensor* _self), *$(at::TensorOptions* _options))); }|]

randint_ilo :: Int -> Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
randint_ilo _high _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randint($(int _high), *$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

randint_ilpo :: Int -> Ptr IntList -> Ptr Generator -> Ptr TensorOptions -> IO (Ptr Tensor)
randint_ilpo _high _size _generator _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randint($(int _high), *$(at::IntArrayRef* _size), $(at::Generator * _generator), *$(at::TensorOptions* _options))); }|]

randint_iilo :: Int -> Int -> Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
randint_iilo _low _high _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randint($(int _low), $(int _high), *$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

randint_iilpo :: Int -> Int -> Ptr IntList -> Ptr Generator -> Ptr TensorOptions -> IO (Ptr Tensor)
randint_iilpo _low _high _size _generator _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randint($(int _low), $(int _high), *$(at::IntArrayRef* _size), $(at::Generator * _generator), *$(at::TensorOptions* _options))); }|]

randint_ilT :: Int -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
randint_ilT _high _size _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randint($(int _high), *$(at::IntArrayRef* _size), *$(at::Tensor* _out))); }|]

randint_ilpT :: Int -> Ptr IntList -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
randint_ilpT _high _size _generator _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randint($(int _high), *$(at::IntArrayRef* _size), $(at::Generator * _generator), *$(at::Tensor* _out))); }|]

randint_iilT :: Int -> Int -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
randint_iilT _low _high _size _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randint($(int _low), $(int _high), *$(at::IntArrayRef* _size), *$(at::Tensor* _out))); }|]

randint_iilpT :: Int -> Int -> Ptr IntList -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
randint_iilpT _low _high _size _generator _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randint($(int _low), $(int _high), *$(at::IntArrayRef* _size), $(at::Generator * _generator), *$(at::Tensor* _out))); }|]

randint_like_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
randint_like_ti _self _high = [C.block| at::Tensor* { return new at::Tensor(at::native::randint_like(*$(at::Tensor* _self), $(int _high))); }|]

randint_like_tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
randint_like_tii _self _low _high = [C.block| at::Tensor* { return new at::Tensor(at::native::randint_like(*$(at::Tensor* _self), $(int _low), $(int _high))); }|]

randint_like_tio :: Ptr Tensor -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
randint_like_tio _self _high _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randint_like(*$(at::Tensor* _self), $(int _high), *$(at::TensorOptions* _options))); }|]

randint_like_tiio :: Ptr Tensor -> Int -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
randint_like_tiio _self _low _high _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randint_like(*$(at::Tensor* _self), $(int _low), $(int _high), *$(at::TensorOptions* _options))); }|]

randn_lo :: Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
randn_lo _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randn(*$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

randn_lpo :: Ptr IntList -> Ptr Generator -> Ptr TensorOptions -> IO (Ptr Tensor)
randn_lpo _size _generator _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randn(*$(at::IntArrayRef* _size), $(at::Generator * _generator), *$(at::TensorOptions* _options))); }|]

randn_lT :: Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
randn_lT _size _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randn(*$(at::IntArrayRef* _size), *$(at::Tensor* _out))); }|]

randn_lpT :: Ptr IntList -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
randn_lpT _size _generator _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randn(*$(at::IntArrayRef* _size), $(at::Generator * _generator), *$(at::Tensor* _out))); }|]

randn_like_t :: Ptr Tensor -> IO (Ptr Tensor)
randn_like_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::randn_like(*$(at::Tensor* _self))); }|]

randn_like_to :: Ptr Tensor -> Ptr TensorOptions -> IO (Ptr Tensor)
randn_like_to _self _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randn_like(*$(at::Tensor* _self), *$(at::TensorOptions* _options))); }|]

randperm_io :: Int -> Ptr TensorOptions -> IO (Ptr Tensor)
randperm_io _n _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randperm($(int _n), *$(at::TensorOptions* _options))); }|]

randperm_ipo :: Int -> Ptr Generator -> Ptr TensorOptions -> IO (Ptr Tensor)
randperm_ipo _n _generator _options = [C.block| at::Tensor* { return new at::Tensor(at::native::randperm($(int _n), $(at::Generator * _generator), *$(at::TensorOptions* _options))); }|]

randperm_iT :: Int -> Ptr Tensor -> IO (Ptr Tensor)
randperm_iT _n _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randperm($(int _n), *$(at::Tensor* _out))); }|]

randperm_out_cpu_ipT :: Int -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
randperm_out_cpu_ipT _n _generator _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randperm_out_cpu($(int _n), $(at::Generator * _generator), *$(at::Tensor* _out))); }|]

randperm_out_cuda_ipT :: Int -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
randperm_out_cuda_ipT _n _generator _out = [C.block| at::Tensor* { return new at::Tensor(at::native::randperm_out_cuda($(int _n), $(at::Generator * _generator), *$(at::Tensor* _out))); }|]

range_ssso :: Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr TensorOptions -> IO (Ptr Tensor)
range_ssso _start _end _step _options = [C.block| at::Tensor* { return new at::Tensor(at::native::range(*$(at::Scalar* _start), *$(at::Scalar* _end), *$(at::Scalar* _step), *$(at::TensorOptions* _options))); }|]

range_sso :: Ptr Scalar -> Ptr Scalar -> Ptr TensorOptions -> IO (Ptr Tensor)
range_sso _start _end _options = [C.block| at::Tensor* { return new at::Tensor(at::native::range(*$(at::Scalar* _start), *$(at::Scalar* _end), *$(at::TensorOptions* _options))); }|]

range_cpu_out_sssT :: Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
range_cpu_out_sssT _start _end _step _out = [C.block| at::Tensor* { return new at::Tensor(at::native::range_cpu_out(*$(at::Scalar* _start), *$(at::Scalar* _end), *$(at::Scalar* _step), *$(at::Tensor* _out))); }|]

range_cuda_out_sssT :: Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
range_cuda_out_sssT _start _end _step _out = [C.block| at::Tensor* { return new at::Tensor(at::native::range_cuda_out(*$(at::Scalar* _start), *$(at::Scalar* _end), *$(at::Scalar* _step), *$(at::Tensor* _out))); }|]

repeat_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
repeat_tl _self _repeats = [C.block| at::Tensor* { return new at::Tensor(at::native::repeat(*$(at::Tensor* _self), *$(at::IntArrayRef* _repeats))); }|]

reshape_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reshape_tl _self _shape = [C.block| at::Tensor* { return new at::Tensor(at::native::reshape(*$(at::Tensor* _self), *$(at::IntArrayRef* _shape))); }|]

reshape_as_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
reshape_as_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::reshape_as(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

roiPooling2d_forward_cpu_ttiif :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> CFloat -> IO (Ptr (Tensor,Tensor))
roiPooling2d_forward_cpu_ttiif _input _rois _pooledHeight _pooledWidth _spatialScale = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::RoiPooling2d_forward_cpu(*$(at::Tensor* _input), *$(at::Tensor* _rois), $(int _pooledHeight), $(int _pooledWidth), $(float _spatialScale))); }|]

roiPooling2d_forward_cuda_ttiif :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> CFloat -> IO (Ptr (Tensor,Tensor))
roiPooling2d_forward_cuda_ttiif _input _rois _pooledHeight _pooledWidth _spatialScale = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::RoiPooling2d_forward_cuda(*$(at::Tensor* _input), *$(at::Tensor* _rois), $(int _pooledHeight), $(int _pooledWidth), $(float _spatialScale))); }|]

roiPooling2d_backward_cpu_ttiiftt :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> CFloat -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
roiPooling2d_backward_cpu_ttiiftt _input _rois _pooledHeight _pooledWidth _spatialScale _gradOutput _argmaxes = [C.block| at::Tensor* { return new at::Tensor(at::native::RoiPooling2d_backward_cpu(*$(at::Tensor* _input), *$(at::Tensor* _rois), $(int _pooledHeight), $(int _pooledWidth), $(float _spatialScale), *$(at::Tensor* _gradOutput), *$(at::Tensor* _argmaxes))); }|]

roiPooling2d_backward_cuda_ttiiftt :: Ptr Tensor -> Ptr Tensor -> Int -> Int -> CFloat -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
roiPooling2d_backward_cuda_ttiiftt _input _rois _pooledHeight _pooledWidth _spatialScale _gradOutput _argmaxes = [C.block| at::Tensor* { return new at::Tensor(at::native::RoiPooling2d_backward_cuda(*$(at::Tensor* _input), *$(at::Tensor* _rois), $(int _pooledHeight), $(int _pooledWidth), $(float _spatialScale), *$(at::Tensor* _gradOutput), *$(at::Tensor* _argmaxes))); }|]

round_t :: Ptr Tensor -> IO (Ptr Tensor)
round_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::round(*$(at::Tensor* _self))); }|]

_round__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_round__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_round__cpu(*$(at::Tensor* _self))); }|]

_round__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_round__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_round__cuda(*$(at::Tensor* _self))); }|]

_round_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_round_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_round_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_round_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_round_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_round_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

rrelu_tssbp :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> CBool -> Ptr Generator -> IO (Ptr Tensor)
rrelu_tssbp _self _lower _upper _training _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu(*$(at::Tensor* _self), *$(at::Scalar* _lower), *$(at::Scalar* _upper), $(bool _training), $(at::Generator * _generator))); }|]

rrelu__Tssbp :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> CBool -> Ptr Generator -> IO (Ptr Tensor)
rrelu__Tssbp _self _lower _upper _training _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_(*$(at::Tensor* _self), *$(at::Scalar* _lower), *$(at::Scalar* _upper), $(bool _training), $(at::Generator * _generator))); }|]

relu_t :: Ptr Tensor -> IO (Ptr Tensor)
relu_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::relu(*$(at::Tensor* _self))); }|]

relu__T :: Ptr Tensor -> IO (Ptr Tensor)
relu__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::relu_(*$(at::Tensor* _self))); }|]

prelu_cpu_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
prelu_cpu_tt _self _weight = [C.block| at::Tensor* { return new at::Tensor(at::native::prelu_cpu(*$(at::Tensor* _self), *$(at::Tensor* _weight))); }|]

prelu_cuda_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
prelu_cuda_tt _self _weight = [C.block| at::Tensor* { return new at::Tensor(at::native::prelu_cuda(*$(at::Tensor* _self), *$(at::Tensor* _weight))); }|]

prelu_backward_cpu_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
prelu_backward_cpu_ttt _grad_output _self _weight = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::prelu_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight))); }|]

prelu_backward_cuda_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
prelu_backward_cuda_ttt _grad_output _self _weight = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::prelu_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight))); }|]

hardshrink_cpu_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
hardshrink_cpu_ts _self _lambd = [C.block| at::Tensor* { return new at::Tensor(at::native::hardshrink_cpu(*$(at::Tensor* _self), *$(at::Scalar* _lambd))); }|]

hardshrink_cuda_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
hardshrink_cuda_ts _self _lambd = [C.block| at::Tensor* { return new at::Tensor(at::native::hardshrink_cuda(*$(at::Tensor* _self), *$(at::Scalar* _lambd))); }|]

hardshrink_backward_cpu_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
hardshrink_backward_cpu_tts _grad_out _self _lambd = [C.block| at::Tensor* { return new at::Tensor(at::native::hardshrink_backward_cpu(*$(at::Tensor* _grad_out), *$(at::Tensor* _self), *$(at::Scalar* _lambd))); }|]

hardshrink_backward_cuda_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
hardshrink_backward_cuda_tts _grad_out _self _lambd = [C.block| at::Tensor* { return new at::Tensor(at::native::hardshrink_backward_cuda(*$(at::Tensor* _grad_out), *$(at::Tensor* _self), *$(at::Scalar* _lambd))); }|]

rsqrt_t :: Ptr Tensor -> IO (Ptr Tensor)
rsqrt_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::rsqrt(*$(at::Tensor* _self))); }|]

_rsqrt__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_rsqrt__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_rsqrt__cpu(*$(at::Tensor* _self))); }|]

_rsqrt__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_rsqrt__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_rsqrt__cuda(*$(at::Tensor* _self))); }|]

_rsqrt_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_rsqrt_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_rsqrt_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_rsqrt_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_rsqrt_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_rsqrt_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

select_tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
select_tii _self _dim _index = [C.block| at::Tensor* { return new at::Tensor(at::native::select(*$(at::Tensor* _self), $(int _dim), $(int _index))); }|]

selu_t :: Ptr Tensor -> IO (Ptr Tensor)
selu_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::selu(*$(at::Tensor* _self))); }|]

selu__T :: Ptr Tensor -> IO (Ptr Tensor)
selu__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::selu_(*$(at::Tensor* _self))); }|]

celu_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
celu_ts _self _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::celu(*$(at::Tensor* _self), *$(at::Scalar* _alpha))); }|]

celu__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
celu__Ts _self _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::celu_(*$(at::Tensor* _self), *$(at::Scalar* _alpha))); }|]

sigmoid_t :: Ptr Tensor -> IO (Ptr Tensor)
sigmoid_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::sigmoid(*$(at::Tensor* _self))); }|]

_sigmoid__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_sigmoid__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sigmoid__cpu(*$(at::Tensor* _self))); }|]

_sigmoid__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_sigmoid__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sigmoid__cuda(*$(at::Tensor* _self))); }|]

_sigmoid_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sigmoid_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sigmoid_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_sigmoid_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sigmoid_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sigmoid_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

sin_t :: Ptr Tensor -> IO (Ptr Tensor)
sin_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::sin(*$(at::Tensor* _self))); }|]

_sin__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_sin__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sin__cpu(*$(at::Tensor* _self))); }|]

_sin__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_sin__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sin__cuda(*$(at::Tensor* _self))); }|]

_sin_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sin_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sin_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_sin_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sin_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sin_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

sinh_t :: Ptr Tensor -> IO (Ptr Tensor)
sinh_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::sinh(*$(at::Tensor* _self))); }|]

_sinh__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_sinh__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sinh__cpu(*$(at::Tensor* _self))); }|]

_sinh__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_sinh__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sinh__cuda(*$(at::Tensor* _self))); }|]

_sinh_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sinh_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sinh_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_sinh_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sinh_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sinh_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

detach_t :: Ptr Tensor -> IO (Ptr Tensor)
detach_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::detach(*$(at::Tensor* _self))); }|]

detach__T :: Ptr Tensor -> IO (Ptr Tensor)
detach__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::detach_(*$(at::Tensor* _self))); }|]

size_ti :: Ptr Tensor -> Int -> IO (Int)
size_ti _self _dim = [C.block| int { return (at::native::size(*$(at::Tensor* _self), $(int _dim))); }|]

_safe_size_ll :: Ptr IntList -> Ptr IntList -> IO (Int64)
_safe_size_ll _sizes _dim = [C.block| int64_t { return (at::native::_safe_size(*$(at::IntArrayRef* _sizes), *$(at::IntArrayRef* _dim))); }|]

slice_tiiii :: Ptr Tensor -> Int -> Int -> Int -> Int -> IO (Ptr Tensor)
slice_tiiii _self _dim _start _end _step = [C.block| at::Tensor* { return new at::Tensor(at::native::slice(*$(at::Tensor* _self), $(int _dim), $(int _start), $(int _end), $(int _step))); }|]

slice_backward_tlllll :: Ptr Tensor -> Ptr IntList -> Int64 -> Int64 -> Int64 -> Int64 -> IO (Ptr Tensor)
slice_backward_tlllll _grad _input_sizes _dim _start _end _step = [C.block| at::Tensor* { return new at::Tensor(at::native::slice_backward(*$(at::Tensor* _grad), *$(at::IntArrayRef* _input_sizes), $(int64_t _dim), $(int64_t _start), $(int64_t _end), $(int64_t _step))); }|]

slogdet_t :: Ptr Tensor -> IO (Ptr (Tensor,Tensor))
slogdet_t _self = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::slogdet(*$(at::Tensor* _self))); }|]

smm_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
smm_tt _self _mat2 = [C.block| at::Tensor* { return new at::Tensor(at::native::smm(*$(at::Tensor* _self), *$(at::Tensor* _mat2))); }|]

softmax_tis :: Ptr Tensor -> Int -> Ptr ScalarType -> IO (Ptr Tensor)
softmax_tis _self _dim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::softmax(*$(at::Tensor* _self), $(int _dim), *$(at::ScalarType* _dtype))); }|]

softmax_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
softmax_ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::softmax(*$(at::Tensor* _self), $(int _dim))); }|]

softmax_cpu_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
softmax_cpu_tib _self _dim _half_to_float = [C.block| at::Tensor* { return new at::Tensor(at::native::softmax_cpu(*$(at::Tensor* _self), $(int _dim), $(bool _half_to_float))); }|]

softmax_cuda_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
softmax_cuda_tib _self _dim _half_to_float = [C.block| at::Tensor* { return new at::Tensor(at::native::softmax_cuda(*$(at::Tensor* _self), $(int _dim), $(bool _half_to_float))); }|]

softmax_backward_cpu_ttit :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
softmax_backward_cpu_ttit _grad_output _output _dim _self = [C.block| at::Tensor* { return new at::Tensor(at::native::softmax_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _output), $(int _dim), *$(at::Tensor* _self))); }|]

softmax_backward_cuda_ttit :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
softmax_backward_cuda_ttit _grad_output _output _dim _self = [C.block| at::Tensor* { return new at::Tensor(at::native::softmax_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _output), $(int _dim), *$(at::Tensor* _self))); }|]

add_out_sparse_cpu_ttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
add_out_sparse_cpu_ttsT _self _other _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::add_out_sparse_cpu(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

add_out_sparse_cuda_ttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
add_out_sparse_cuda_ttsT _self _other _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::add_out_sparse_cuda(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

add_out_dense_sparse_cpu_trsT :: Ptr Tensor -> Ptr SparseTensorRef -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
add_out_dense_sparse_cpu_trsT _self _other _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::add_out_dense_sparse_cpu(*$(at::Tensor* _self), *$(at::SparseTensorRef* _other), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

add_out_dense_sparse_cuda_trsT :: Ptr Tensor -> Ptr SparseTensorRef -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
add_out_dense_sparse_cuda_trsT _self _other _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::add_out_dense_sparse_cuda(*$(at::Tensor* _self), *$(at::SparseTensorRef* _other), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

div_out_sparse_zerodim_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
div_out_sparse_zerodim_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::div_out_sparse_zerodim(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

div_out_sparse_scalar_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
div_out_sparse_scalar_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::div_out_sparse_scalar(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

mul_out_sparse_cpu_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mul_out_sparse_cpu_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mul_out_sparse_cpu(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

mul_out_sparse_cuda_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mul_out_sparse_cuda_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mul_out_sparse_cuda(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

mul_out_sparse_zerodim_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
mul_out_sparse_zerodim_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mul_out_sparse_zerodim(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

mul_out_sparse_scalar_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
mul_out_sparse_scalar_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::mul_out_sparse_scalar(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

split_tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
split_tii _self _split_size _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::split(*$(at::Tensor* _self), $(int _split_size), $(int _dim))); }|]

split_with_sizes_tli :: Ptr Tensor -> Ptr IntList -> Int -> IO (Ptr TensorList)
split_with_sizes_tli _self _split_sizes _dim = [C.block| at::TensorList* { return new at::TensorList(at::native::split_with_sizes(*$(at::Tensor* _self), *$(at::IntArrayRef* _split_sizes), $(int _dim))); }|]

squeeze_t :: Ptr Tensor -> IO (Ptr Tensor)
squeeze_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::squeeze(*$(at::Tensor* _self))); }|]

squeeze_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
squeeze_ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::squeeze(*$(at::Tensor* _self), $(int _dim))); }|]

unsqueeze_to_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
unsqueeze_to_tl _self _sizes = [C.block| at::Tensor* { return new at::Tensor(at::native::unsqueeze_to(*$(at::Tensor* _self), *$(at::IntArrayRef* _sizes))); }|]

unsqueeze_to_tll :: Ptr Tensor -> Int64 -> Ptr IntList -> IO (Ptr Tensor)
unsqueeze_to_tll _self _dim _sizes = [C.block| at::Tensor* { return new at::Tensor(at::native::unsqueeze_to(*$(at::Tensor* _self), $(int64_t _dim), *$(at::IntArrayRef* _sizes))); }|]

squeeze__T :: Ptr Tensor -> IO (Ptr Tensor)
squeeze__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::squeeze_(*$(at::Tensor* _self))); }|]

squeeze__Ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
squeeze__Ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::squeeze_(*$(at::Tensor* _self), $(int _dim))); }|]

sspaddmm_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
sspaddmm_tttss _self _mat1 _mat2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::sspaddmm(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

_sspaddmm_out_only_sparse_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_sspaddmm_out_only_sparse_tttssT _self _mat1 _mat2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sspaddmm_out_only_sparse(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

_sspaddmm_out_only_sparse_cuda_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_sspaddmm_out_only_sparse_cuda_tttssT _self _mat1 _mat2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sspaddmm_out_only_sparse_cuda(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

_sspaddmm_out_cpu_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_sspaddmm_out_cpu_tttssT _self _mat1 _mat2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sspaddmm_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

_sspaddmm_out_cuda_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_sspaddmm_out_cuda_tttssT _self _mat1 _mat2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sspaddmm_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

stack_li :: Ptr TensorList -> Int -> IO (Ptr Tensor)
stack_li _tensors _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::stack(*$(at::TensorList* _tensors), $(int _dim))); }|]

stack_liT :: Ptr TensorList -> Int -> Ptr Tensor -> IO (Ptr Tensor)
stack_liT _tensors _dim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::stack(*$(at::TensorList* _tensors), $(int _dim), *$(at::Tensor* _out))); }|]

stft_tiiitbb :: Ptr Tensor -> Int -> Int -> Int -> Ptr Tensor -> CBool -> CBool -> IO (Ptr Tensor)
stft_tiiitbb _self _n_fft _hop_length _win_length _window _normalized _onesided = [C.block| at::Tensor* { return new at::Tensor(at::native::stft(*$(at::Tensor* _self), $(int _n_fft), $(int _hop_length), $(int _win_length), *$(at::Tensor* _window), $(bool _normalized), $(bool _onesided))); }|]

stride_ti :: Ptr Tensor -> Int -> IO (Int)
stride_ti _self _dim = [C.block| int { return (at::native::stride(*$(at::Tensor* _self), $(int _dim))); }|]

sum_ts :: Ptr Tensor -> Ptr ScalarType -> IO (Ptr Tensor)
sum_ts _self _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::sum(*$(at::Tensor* _self), *$(at::ScalarType* _dtype))); }|]

sum_t :: Ptr Tensor -> IO (Ptr Tensor)
sum_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::sum(*$(at::Tensor* _self))); }|]

sum_tlbs :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr ScalarType -> IO (Ptr Tensor)
sum_tlbs _self _dim _keepdim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::sum(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::ScalarType* _dtype))); }|]

sum_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
sum_tlb _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::sum(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim))); }|]

sum_tls :: Ptr Tensor -> Ptr IntList -> Ptr ScalarType -> IO (Ptr Tensor)
sum_tls _self _dim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::sum(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), *$(at::ScalarType* _dtype))); }|]

sum_tlbsT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
sum_tlbsT _self _dim _keepdim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::sum(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

sum_tlbT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
sum_tlbT _self _dim _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::sum(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::Tensor* _out))); }|]

sum_tlsT :: Ptr Tensor -> Ptr IntList -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
sum_tlsT _self _dim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::sum(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

sum_to_size_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
sum_to_size_tl _self _size = [C.block| at::Tensor* { return new at::Tensor(at::native::sum_to_size(*$(at::Tensor* _self), *$(at::IntArrayRef* _size))); }|]

sqrt_t :: Ptr Tensor -> IO (Ptr Tensor)
sqrt_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::sqrt(*$(at::Tensor* _self))); }|]

_sqrt__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_sqrt__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sqrt__cpu(*$(at::Tensor* _self))); }|]

_sqrt__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_sqrt__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sqrt__cuda(*$(at::Tensor* _self))); }|]

_sqrt_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sqrt_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sqrt_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_sqrt_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_sqrt_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_sqrt_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

std_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
std_tb _self _unbiased = [C.block| at::Tensor* { return new at::Tensor(at::native::std(*$(at::Tensor* _self), $(bool _unbiased))); }|]

std_tlbb :: Ptr Tensor -> Ptr IntList -> CBool -> CBool -> IO (Ptr Tensor)
std_tlbb _self _dim _unbiased _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::std(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _unbiased), $(bool _keepdim))); }|]

std_tlbbT :: Ptr Tensor -> Ptr IntList -> CBool -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
std_tlbbT _self _dim _unbiased _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::std(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _unbiased), $(bool _keepdim), *$(at::Tensor* _out))); }|]

prod_ts :: Ptr Tensor -> Ptr ScalarType -> IO (Ptr Tensor)
prod_ts _self _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::prod(*$(at::Tensor* _self), *$(at::ScalarType* _dtype))); }|]

prod_t :: Ptr Tensor -> IO (Ptr Tensor)
prod_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::prod(*$(at::Tensor* _self))); }|]

prod_tibs :: Ptr Tensor -> Int -> CBool -> Ptr ScalarType -> IO (Ptr Tensor)
prod_tibs _self _dim _keepdim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::prod(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim), *$(at::ScalarType* _dtype))); }|]

prod_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
prod_tib _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::prod(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim))); }|]

prod_tis :: Ptr Tensor -> Int -> Ptr ScalarType -> IO (Ptr Tensor)
prod_tis _self _dim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::prod(*$(at::Tensor* _self), $(int _dim), *$(at::ScalarType* _dtype))); }|]

prod_tibsT :: Ptr Tensor -> Int -> CBool -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
prod_tibsT _self _dim _keepdim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::prod(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

prod_tibT :: Ptr Tensor -> Int -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
prod_tibT _self _dim _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::prod(*$(at::Tensor* _self), $(int _dim), $(bool _keepdim), *$(at::Tensor* _out))); }|]

prod_tisT :: Ptr Tensor -> Int -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
prod_tisT _self _dim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::prod(*$(at::Tensor* _self), $(int _dim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

t_t :: Ptr Tensor -> IO (Ptr Tensor)
t_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::t(*$(at::Tensor* _self))); }|]

t__T :: Ptr Tensor -> IO (Ptr Tensor)
t__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::t_(*$(at::Tensor* _self))); }|]

tan_t :: Ptr Tensor -> IO (Ptr Tensor)
tan_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::tan(*$(at::Tensor* _self))); }|]

_tan__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_tan__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_tan__cpu(*$(at::Tensor* _self))); }|]

_tan__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_tan__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_tan__cuda(*$(at::Tensor* _self))); }|]

_tan_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_tan_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_tan_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_tan_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_tan_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_tan_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

tanh_t :: Ptr Tensor -> IO (Ptr Tensor)
tanh_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::tanh(*$(at::Tensor* _self))); }|]

_tanh__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_tanh__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_tanh__cpu(*$(at::Tensor* _self))); }|]

_tanh__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_tanh__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_tanh__cuda(*$(at::Tensor* _self))); }|]

_tanh_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_tanh_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_tanh_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_tanh_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_tanh_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_tanh_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

tensordot_ttll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
tensordot_ttll _self _other _dims_self _dims_other = [C.block| at::Tensor* { return new at::Tensor(at::native::tensordot(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::IntArrayRef* _dims_self), *$(at::IntArrayRef* _dims_other))); }|]

threshold_tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
threshold_tss _self _threshold _value = [C.block| at::Tensor* { return new at::Tensor(at::native::threshold(*$(at::Tensor* _self), *$(at::Scalar* _threshold), *$(at::Scalar* _value))); }|]

threshold__Tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
threshold__Tss _self _threshold _value = [C.block| at::Tensor* { return new at::Tensor(at::native::threshold_(*$(at::Tensor* _self), *$(at::Scalar* _threshold), *$(at::Scalar* _value))); }|]

threshold_tssT :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
threshold_tssT _self _threshold _value _out = [C.block| at::Tensor* { return new at::Tensor(at::native::threshold(*$(at::Tensor* _self), *$(at::Scalar* _threshold), *$(at::Scalar* _value), *$(at::Tensor* _out))); }|]

threshold_backward_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
threshold_backward_tts _grad_output _self _threshold = [C.block| at::Tensor* { return new at::Tensor(at::native::threshold_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _threshold))); }|]

transpose_tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
transpose_tii _self _dim0 _dim1 = [C.block| at::Tensor* { return new at::Tensor(at::native::transpose(*$(at::Tensor* _self), $(int _dim0), $(int _dim1))); }|]

transpose__Tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
transpose__Tii _self _dim0 _dim1 = [C.block| at::Tensor* { return new at::Tensor(at::native::transpose_(*$(at::Tensor* _self), $(int _dim0), $(int _dim1))); }|]

one_hot_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
one_hot_ti _self _num_classes = [C.block| at::Tensor* { return new at::Tensor(at::native::one_hot(*$(at::Tensor* _self), $(int _num_classes))); }|]

flip_cpu_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
flip_cpu_tl _self _dims = [C.block| at::Tensor* { return new at::Tensor(at::native::flip_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _dims))); }|]

flip_cuda_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
flip_cuda_tl _self _dims = [C.block| at::Tensor* { return new at::Tensor(at::native::flip_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _dims))); }|]

roll_cpu_tll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
roll_cpu_tll _self _shifts _dims = [C.block| at::Tensor* { return new at::Tensor(at::native::roll_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _shifts), *$(at::IntArrayRef* _dims))); }|]

roll_cuda_tll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
roll_cuda_tll _self _shifts _dims = [C.block| at::Tensor* { return new at::Tensor(at::native::roll_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _shifts), *$(at::IntArrayRef* _dims))); }|]

rot90_til :: Ptr Tensor -> Int -> Ptr IntList -> IO (Ptr Tensor)
rot90_til _self _k _dims = [C.block| at::Tensor* { return new at::Tensor(at::native::rot90(*$(at::Tensor* _self), $(int _k), *$(at::IntArrayRef* _dims))); }|]

_trilinear_tttlllli :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Int -> IO (Ptr Tensor)
_trilinear_tttlllli _i1 _i2 _i3 _expand1 _expand2 _expand3 _sumdim _unroll_dim = [C.block| at::Tensor* { return new at::Tensor(at::native::_trilinear(*$(at::Tensor* _i1), *$(at::Tensor* _i2), *$(at::Tensor* _i3), *$(at::IntArrayRef* _expand1), *$(at::IntArrayRef* _expand2), *$(at::IntArrayRef* _expand3), *$(at::IntArrayRef* _sumdim), $(int _unroll_dim))); }|]

triplet_margin_loss_tttfffbi :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CFloat -> CFloat -> CFloat -> CBool -> Int -> IO (Ptr Tensor)
triplet_margin_loss_tttfffbi _anchor _positive _negative _margin _p _eps _swap _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::triplet_margin_loss(*$(at::Tensor* _anchor), *$(at::Tensor* _positive), *$(at::Tensor* _negative), $(float _margin), $(float _p), $(float _eps), $(bool _swap), $(int _reduction))); }|]

trunc_t :: Ptr Tensor -> IO (Ptr Tensor)
trunc_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::trunc(*$(at::Tensor* _self))); }|]

_trunc__cpu_T :: Ptr Tensor -> IO (Ptr Tensor)
_trunc__cpu_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_trunc__cpu(*$(at::Tensor* _self))); }|]

_trunc__cuda_T :: Ptr Tensor -> IO (Ptr Tensor)
_trunc__cuda_T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_trunc__cuda(*$(at::Tensor* _self))); }|]

_trunc_out_cpu_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_trunc_out_cpu_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_trunc_out_cpu(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

_trunc_out_cuda_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_trunc_out_cuda_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_trunc_out_cuda(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

type_as_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
type_as_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::type_as(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

_unique_cpu_tbb :: Ptr Tensor -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
_unique_cpu_tbb _self _sorted _return_inverse = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_unique_cpu(*$(at::Tensor* _self), $(bool _sorted), $(bool _return_inverse))); }|]

_unique_cuda_tbb :: Ptr Tensor -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
_unique_cuda_tbb _self _sorted _return_inverse = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_unique_cuda(*$(at::Tensor* _self), $(bool _sorted), $(bool _return_inverse))); }|]

_unique_dim_cpu_tibb :: Ptr Tensor -> Int -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
_unique_dim_cpu_tibb _self _dim _sorted _return_inverse = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_unique_dim_cpu(*$(at::Tensor* _self), $(int _dim), $(bool _sorted), $(bool _return_inverse))); }|]

_unique_dim_cuda_tibb :: Ptr Tensor -> Int -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
_unique_dim_cuda_tibb _self _dim _sorted _return_inverse = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_unique_dim_cuda(*$(at::Tensor* _self), $(int _dim), $(bool _sorted), $(bool _return_inverse))); }|]

_unsafe_view_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
_unsafe_view_tl _self _size = [C.block| at::Tensor* { return new at::Tensor(at::native::_unsafe_view(*$(at::Tensor* _self), *$(at::IntArrayRef* _size))); }|]

unsqueeze_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
unsqueeze_ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::unsqueeze(*$(at::Tensor* _self), $(int _dim))); }|]

unsqueeze__Ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
unsqueeze__Ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::unsqueeze_(*$(at::Tensor* _self), $(int _dim))); }|]

var_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
var_tb _self _unbiased = [C.block| at::Tensor* { return new at::Tensor(at::native::var(*$(at::Tensor* _self), $(bool _unbiased))); }|]

var_tlbb :: Ptr Tensor -> Ptr IntList -> CBool -> CBool -> IO (Ptr Tensor)
var_tlbb _self _dim _unbiased _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::var(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _unbiased), $(bool _keepdim))); }|]

var_tlbbT :: Ptr Tensor -> Ptr IntList -> CBool -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
var_tlbbT _self _dim _unbiased _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::var(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _unbiased), $(bool _keepdim), *$(at::Tensor* _out))); }|]

var_backward_ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
var_backward_ttb _grad _self _unbiased = [C.block| at::Tensor* { return new at::Tensor(at::native::var_backward(*$(at::Tensor* _grad), *$(at::Tensor* _self), $(bool _unbiased))); }|]

var_backward_ttlbb :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> CBool -> CBool -> IO (Ptr Tensor)
var_backward_ttlbb _grad _self _dim _unbiased _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::var_backward(*$(at::Tensor* _grad), *$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _unbiased), $(bool _keepdim))); }|]

view_as_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
view_as_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::view_as(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

where_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
where_ttt _condition _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::where(*$(at::Tensor* _condition), *$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

_s_where_cpu_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_s_where_cpu_ttt _condition _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_where_cpu(*$(at::Tensor* _condition), *$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

_s_where_cuda_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_s_where_cuda_ttt _condition _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_where_cuda(*$(at::Tensor* _condition), *$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

norm_except_dim_tii :: Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
norm_except_dim_tii _v _pow _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::norm_except_dim(*$(at::Tensor* _v), $(int _pow), $(int _dim))); }|]

_weight_norm_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
_weight_norm_tti _v _g _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::_weight_norm(*$(at::Tensor* _v), *$(at::Tensor* _g), $(int _dim))); }|]

weight_norm_cuda_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr (Tensor,Tensor))
weight_norm_cuda_tti _v _g _dim = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::weight_norm_cuda(*$(at::Tensor* _v), *$(at::Tensor* _g), $(int _dim))); }|]

weight_norm_cuda_backward_tttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr (Tensor,Tensor))
weight_norm_cuda_backward_tttti _grad_w _saved_v _saved_g _saved_norms _dim = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::weight_norm_cuda_backward(*$(at::Tensor* _grad_w), *$(at::Tensor* _saved_v), *$(at::Tensor* _saved_g), *$(at::Tensor* _saved_norms), $(int _dim))); }|]

_weight_norm_differentiable_backward_tttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr (Tensor,Tensor))
_weight_norm_differentiable_backward_tttti _grad_w _saved_v _saved_g _saved_norms _dim = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_weight_norm_differentiable_backward(*$(at::Tensor* _grad_w), *$(at::Tensor* _saved_v), *$(at::Tensor* _saved_g), *$(at::Tensor* _saved_norms), $(int _dim))); }|]

zeros_lo :: Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
zeros_lo _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::zeros(*$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

zeros_lT :: Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
zeros_lT _size _out = [C.block| at::Tensor* { return new at::Tensor(at::native::zeros(*$(at::IntArrayRef* _size), *$(at::Tensor* _out))); }|]

zeros_like_t :: Ptr Tensor -> IO (Ptr Tensor)
zeros_like_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::zeros_like(*$(at::Tensor* _self))); }|]

zeros_like_to :: Ptr Tensor -> Ptr TensorOptions -> IO (Ptr Tensor)
zeros_like_to _self _options = [C.block| at::Tensor* { return new at::Tensor(at::native::zeros_like(*$(at::Tensor* _self), *$(at::TensorOptions* _options))); }|]

_standard_gamma_grad_cpu_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_standard_gamma_grad_cpu_tt _self _output = [C.block| at::Tensor* { return new at::Tensor(at::native::_standard_gamma_grad_cpu(*$(at::Tensor* _self), *$(at::Tensor* _output))); }|]

_standard_gamma_grad_cuda_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_standard_gamma_grad_cuda_tt _self _output = [C.block| at::Tensor* { return new at::Tensor(at::native::_standard_gamma_grad_cuda(*$(at::Tensor* _self), *$(at::Tensor* _output))); }|]

_s_gamma_cpu_tp :: Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
_s_gamma_cpu_tp _self _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_gamma_cpu(*$(at::Tensor* _self), $(at::Generator * _generator))); }|]

_s_gamma_cuda_tp :: Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
_s_gamma_cuda_tp _self _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_gamma_cuda(*$(at::Tensor* _self), $(at::Generator * _generator))); }|]

_s_poisson_cpu_tp :: Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
_s_poisson_cpu_tp _self _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_poisson_cpu(*$(at::Tensor* _self), $(at::Generator * _generator))); }|]

_s_poisson_cuda_tp :: Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
_s_poisson_cuda_tp _self _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::_s_poisson_cuda(*$(at::Tensor* _self), $(at::Generator * _generator))); }|]

norm_sparse_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
norm_sparse_ts _self _p = [C.block| at::Tensor* { return new at::Tensor(at::native::norm_sparse(*$(at::Tensor* _self), *$(at::Scalar* _p))); }|]

_sparse_sum_t :: Ptr Tensor -> IO (Ptr Tensor)
_sparse_sum_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum(*$(at::Tensor* _self))); }|]

_sparse_sum_ts :: Ptr Tensor -> Ptr ScalarType -> IO (Ptr Tensor)
_sparse_sum_ts _self _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum(*$(at::Tensor* _self), *$(at::ScalarType* _dtype))); }|]

_sparse_sum_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
_sparse_sum_tl _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim))); }|]

_sparse_sum_tls :: Ptr Tensor -> Ptr IntList -> Ptr ScalarType -> IO (Ptr Tensor)
_sparse_sum_tls _self _dim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), *$(at::ScalarType* _dtype))); }|]

_sparse_sum_backward_cpu_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
_sparse_sum_backward_cpu_ttl _grad _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum_backward_cpu(*$(at::Tensor* _grad), *$(at::Tensor* _self), *$(at::IntArrayRef* _dim))); }|]

_sparse_sum_backward_cuda_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
_sparse_sum_backward_cuda_ttl _grad _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_sum_backward_cuda(*$(at::Tensor* _grad), *$(at::Tensor* _self), *$(at::IntArrayRef* _dim))); }|]

norm_tss :: Ptr Tensor -> Ptr Scalar -> Ptr ScalarType -> IO (Ptr Tensor)
norm_tss _self _p _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::norm(*$(at::Tensor* _self), *$(at::Scalar* _p), *$(at::ScalarType* _dtype))); }|]

norm_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
norm_ts _self _p = [C.block| at::Tensor* { return new at::Tensor(at::native::norm(*$(at::Tensor* _self), *$(at::Scalar* _p))); }|]

norm_tslbs :: Ptr Tensor -> Ptr Scalar -> Ptr IntList -> CBool -> Ptr ScalarType -> IO (Ptr Tensor)
norm_tslbs _self _p _dim _keepdim _dtype = [C.block| at::Tensor* { return new at::Tensor(at::native::norm(*$(at::Tensor* _self), *$(at::Scalar* _p), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::ScalarType* _dtype))); }|]

norm_tslb :: Ptr Tensor -> Ptr Scalar -> Ptr IntList -> CBool -> IO (Ptr Tensor)
norm_tslb _self _p _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::norm(*$(at::Tensor* _self), *$(at::Scalar* _p), *$(at::IntArrayRef* _dim), $(bool _keepdim))); }|]

norm_tslbsT :: Ptr Tensor -> Ptr Scalar -> Ptr IntList -> CBool -> Ptr ScalarType -> Ptr Tensor -> IO (Ptr Tensor)
norm_tslbsT _self _p _dim _keepdim _dtype _out = [C.block| at::Tensor* { return new at::Tensor(at::native::norm(*$(at::Tensor* _self), *$(at::Scalar* _p), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::ScalarType* _dtype), *$(at::Tensor* _out))); }|]

norm_tslbT :: Ptr Tensor -> Ptr Scalar -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
norm_tslbT _self _p _dim _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::norm(*$(at::Tensor* _self), *$(at::Scalar* _p), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::Tensor* _out))); }|]

frobenius_norm_t :: Ptr Tensor -> IO (Ptr Tensor)
frobenius_norm_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::frobenius_norm(*$(at::Tensor* _self))); }|]

frobenius_norm_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
frobenius_norm_tlb _self _dim _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::frobenius_norm(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim))); }|]

frobenius_norm_tlbT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
frobenius_norm_tlbT _self _dim _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::frobenius_norm(*$(at::Tensor* _self), *$(at::IntArrayRef* _dim), $(bool _keepdim), *$(at::Tensor* _out))); }|]

nuclear_norm_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
nuclear_norm_tb _self _keepdim = [C.block| at::Tensor* { return new at::Tensor(at::native::nuclear_norm(*$(at::Tensor* _self), $(bool _keepdim))); }|]

nuclear_norm_tbT :: Ptr Tensor -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
nuclear_norm_tbT _self _keepdim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::nuclear_norm(*$(at::Tensor* _self), $(bool _keepdim), *$(at::Tensor* _out))); }|]

clone_sparse_t :: Ptr Tensor -> IO (Ptr Tensor)
clone_sparse_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::clone_sparse(*$(at::Tensor* _self))); }|]

clone_t :: Ptr Tensor -> IO (Ptr Tensor)
clone_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::clone(*$(at::Tensor* _self))); }|]

resize_as_sparse__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
resize_as_sparse__Tt _self _the_template = [C.block| at::Tensor* { return new at::Tensor(at::native::resize_as_sparse_(*$(at::Tensor* _self), *$(at::Tensor* _the_template))); }|]

resize_as__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
resize_as__Tt _self _the_template = [C.block| at::Tensor* { return new at::Tensor(at::native::resize_as_(*$(at::Tensor* _self), *$(at::Tensor* _the_template))); }|]

pow_out_sparse_scalar_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
pow_out_sparse_scalar_tsT _self _exponent _out = [C.block| at::Tensor* { return new at::Tensor(at::native::pow_out_sparse_scalar(*$(at::Tensor* _self), *$(at::Scalar* _exponent), *$(at::Tensor* _out))); }|]

pow_sparse_scalar_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
pow_sparse_scalar_ts _self _exponent = [C.block| at::Tensor* { return new at::Tensor(at::native::pow_sparse_scalar(*$(at::Tensor* _self), *$(at::Scalar* _exponent))); }|]

pow_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
pow_tsT _self _exponent _out = [C.block| at::Tensor* { return new at::Tensor(at::native::pow(*$(at::Tensor* _self), *$(at::Scalar* _exponent), *$(at::Tensor* _out))); }|]

pow_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
pow_ts _self _exponent = [C.block| at::Tensor* { return new at::Tensor(at::native::pow(*$(at::Tensor* _self), *$(at::Scalar* _exponent))); }|]

zero_sparse__T :: Ptr Tensor -> IO (Ptr Tensor)
zero_sparse__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::zero_sparse_(*$(at::Tensor* _self))); }|]

zero__T :: Ptr Tensor -> IO (Ptr Tensor)
zero__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::zero_(*$(at::Tensor* _self))); }|]

sub_ttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
sub_ttsT _self _other _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::sub(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

sub_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
sub_tts _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::sub(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha))); }|]

sub__Tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
sub__Tts _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::sub_(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha))); }|]

sub_tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
sub_tss _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::sub(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Scalar* _alpha))); }|]

sub__Tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
sub__Tss _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::sub_(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Scalar* _alpha))); }|]

rsub_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
rsub_tts _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::rsub(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _alpha))); }|]

rsub_tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
rsub_tss _self _other _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::rsub(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Scalar* _alpha))); }|]

s_addmm_out_sparse_dense_cpu_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
s_addmm_out_sparse_dense_cpu_tttssT _self _mat1 _mat2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_out_sparse_dense_cpu(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

s_addmm_out_sparse_dense_cuda_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
s_addmm_out_sparse_dense_cuda_tttssT _self _mat1 _mat2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_out_sparse_dense_cuda(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

s_addmm_sparse_dense_cpu_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
s_addmm_sparse_dense_cpu_tttss _self _mat1 _mat2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_sparse_dense_cpu(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

s_addmm_sparse_dense_cuda_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
s_addmm_sparse_dense_cuda_tttss _self _mat1 _mat2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_sparse_dense_cuda(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

s_addmm_sparse_dense_cpu__Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
s_addmm_sparse_dense_cpu__Tttss _self _mat1 _mat2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_sparse_dense_cpu_(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

s_addmm_sparse_dense_cuda__Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
s_addmm_sparse_dense_cuda__Tttss _self _mat1 _mat2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::s_addmm_sparse_dense_cuda_(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

_sparse_addmm_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
_sparse_addmm_tttss _self _sparse _dense _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_addmm(*$(at::Tensor* _self), *$(at::Tensor* _sparse), *$(at::Tensor* _dense), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

addmm_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
addmm_tttssT _self _mat1 _mat2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::addmm(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

addmm_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
addmm_tttss _self _mat1 _mat2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::addmm(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

addmm__Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
addmm__Tttss _self _mat1 _mat2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::addmm_(*$(at::Tensor* _self), *$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

sparse_coo_tensor_lo :: Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
sparse_coo_tensor_lo _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_coo_tensor(*$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

sparse_coo_tensor_tto :: Ptr Tensor -> Ptr Tensor -> Ptr TensorOptions -> IO (Ptr Tensor)
sparse_coo_tensor_tto _indices _values _options = [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_coo_tensor(*$(at::Tensor* _indices), *$(at::Tensor* _values), *$(at::TensorOptions* _options))); }|]

sparse_coo_tensor_ttlo :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
sparse_coo_tensor_ttlo _indices _values _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_coo_tensor(*$(at::Tensor* _indices), *$(at::Tensor* _values), *$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

_sparse_coo_tensor_unsafe_ttlo :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
_sparse_coo_tensor_unsafe_ttlo _indices _values _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::_sparse_coo_tensor_unsafe(*$(at::Tensor* _indices), *$(at::Tensor* _values), *$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

new_with_dims_sparse_iilo :: Int -> Int -> Ptr IntList -> Ptr TensorOptions -> IO (Ptr Tensor)
new_with_dims_sparse_iilo _sparse_dim _dense_dim _size _options = [C.block| at::Tensor* { return new at::Tensor(at::native::new_with_dims_sparse($(int _sparse_dim), $(int _dense_dim), *$(at::IntArrayRef* _size), *$(at::TensorOptions* _options))); }|]

new_with_dims_and_tensor_sparse_iiltto :: Int -> Int -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr TensorOptions -> IO (Ptr Tensor)
new_with_dims_and_tensor_sparse_iiltto _sparse_dim _dense_dim _size _indices _values _options = [C.block| at::Tensor* { return new at::Tensor(at::native::new_with_dims_and_tensor_sparse($(int _sparse_dim), $(int _dense_dim), *$(at::IntArrayRef* _size), *$(at::Tensor* _indices), *$(at::Tensor* _values), *$(at::TensorOptions* _options))); }|]

sparse_resize__Tlii :: Ptr Tensor -> Ptr IntList -> Int -> Int -> IO (Ptr Tensor)
sparse_resize__Tlii _self _size _sparse_dim _dense_dim = [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_resize_(*$(at::Tensor* _self), *$(at::IntArrayRef* _size), $(int _sparse_dim), $(int _dense_dim))); }|]

sparse_resize_and_clear__Tlii :: Ptr Tensor -> Ptr IntList -> Int -> Int -> IO (Ptr Tensor)
sparse_resize_and_clear__Tlii _self _size _sparse_dim _dense_dim = [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_resize_and_clear_(*$(at::Tensor* _self), *$(at::IntArrayRef* _size), $(int _sparse_dim), $(int _dense_dim))); }|]

sparse_mask_cpu_tr :: Ptr Tensor -> Ptr SparseTensorRef -> IO (Ptr Tensor)
sparse_mask_cpu_tr _self _mask = [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_mask_cpu(*$(at::Tensor* _self), *$(at::SparseTensorRef* _mask))); }|]

sparse_mask_cuda_tr :: Ptr Tensor -> Ptr SparseTensorRef -> IO (Ptr Tensor)
sparse_mask_cuda_tr _self _mask = [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_mask_cuda(*$(at::Tensor* _self), *$(at::SparseTensorRef* _mask))); }|]

sparse_to_dense_t :: Ptr Tensor -> IO (Ptr Tensor)
sparse_to_dense_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::sparse_to_dense(*$(at::Tensor* _self))); }|]

sparse_dim_sparse_t :: Ptr Tensor -> IO (Int)
sparse_dim_sparse_t _self = [C.block| int { return (at::native::sparse_dim_sparse(*$(at::Tensor* _self))); }|]

dense_dim_sparse_t :: Ptr Tensor -> IO (Int)
dense_dim_sparse_t _self = [C.block| int { return (at::native::dense_dim_sparse(*$(at::Tensor* _self))); }|]

_nnz_sparse_t :: Ptr Tensor -> IO (Int)
_nnz_sparse_t _self = [C.block| int { return (at::native::_nnz_sparse(*$(at::Tensor* _self))); }|]

coalesce_sparse_cpu_t :: Ptr Tensor -> IO (Ptr Tensor)
coalesce_sparse_cpu_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::coalesce_sparse_cpu(*$(at::Tensor* _self))); }|]

coalesce_sparse_cuda_t :: Ptr Tensor -> IO (Ptr Tensor)
coalesce_sparse_cuda_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::coalesce_sparse_cuda(*$(at::Tensor* _self))); }|]

is_coalesced_sparse_t :: Ptr Tensor -> IO (CBool)
is_coalesced_sparse_t _self = [C.block| bool { return (at::native::is_coalesced_sparse(*$(at::Tensor* _self))); }|]

_indices_sparse_t :: Ptr Tensor -> IO (Ptr Tensor)
_indices_sparse_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_indices_sparse(*$(at::Tensor* _self))); }|]

_values_sparse_t :: Ptr Tensor -> IO (Ptr Tensor)
_values_sparse_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::_values_sparse(*$(at::Tensor* _self))); }|]

_coalesced_sparse__Tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_coalesced_sparse__Tb _self _coalesced = [C.block| at::Tensor* { return new at::Tensor(at::native::_coalesced_sparse_(*$(at::Tensor* _self), $(bool _coalesced))); }|]

indices_sparse_t :: Ptr Tensor -> IO (Ptr Tensor)
indices_sparse_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::indices_sparse(*$(at::Tensor* _self))); }|]

values_sparse_t :: Ptr Tensor -> IO (Ptr Tensor)
values_sparse_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::values_sparse(*$(at::Tensor* _self))); }|]

hspmm_out_sparse_cpu_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
hspmm_out_sparse_cpu_ttT _mat1 _mat2 _out = [C.block| at::Tensor* { return new at::Tensor(at::native::hspmm_out_sparse_cpu(*$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Tensor* _out))); }|]

hspmm_out_sparse_cuda_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
hspmm_out_sparse_cuda_ttT _mat1 _mat2 _out = [C.block| at::Tensor* { return new at::Tensor(at::native::hspmm_out_sparse_cuda(*$(at::Tensor* _mat1), *$(at::Tensor* _mat2), *$(at::Tensor* _out))); }|]

hspmm_sparse_cpu_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
hspmm_sparse_cpu_tt _mat1 _mat2 = [C.block| at::Tensor* { return new at::Tensor(at::native::hspmm_sparse_cpu(*$(at::Tensor* _mat1), *$(at::Tensor* _mat2))); }|]

hspmm_sparse_cuda_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
hspmm_sparse_cuda_tt _mat1 _mat2 = [C.block| at::Tensor* { return new at::Tensor(at::native::hspmm_sparse_cuda(*$(at::Tensor* _mat1), *$(at::Tensor* _mat2))); }|]

copy_sparse__Ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
copy_sparse__Ttb _self _src _non_blocking = [C.block| at::Tensor* { return new at::Tensor(at::native::copy_sparse_(*$(at::Tensor* _self), *$(at::Tensor* _src), $(bool _non_blocking))); }|]

numel_t :: Ptr Tensor -> IO (Int)
numel_t _self = [C.block| int { return (at::native::numel(*$(at::Tensor* _self))); }|]

unbind_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
unbind_ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::unbind(*$(at::Tensor* _self), $(int _dim))); }|]

dense_to_sparse_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
dense_to_sparse_ti _self _sparse_dim = [C.block| at::Tensor* { return new at::Tensor(at::native::dense_to_sparse(*$(at::Tensor* _self), $(int _sparse_dim))); }|]

dense_to_sparse_t :: Ptr Tensor -> IO (Ptr Tensor)
dense_to_sparse_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::dense_to_sparse(*$(at::Tensor* _self))); }|]

to_tobb :: Ptr Tensor -> Ptr TensorOptions -> CBool -> CBool -> IO (Ptr Tensor)
to_tobb _self _options _non_blocking _copy = [C.block| at::Tensor* { return new at::Tensor(at::native::to(*$(at::Tensor* _self), *$(at::TensorOptions* _options), $(bool _non_blocking), $(bool _copy))); }|]

to_tdevicesbb :: Ptr Tensor -> Ptr Device -> Ptr ScalarType -> CBool -> CBool -> IO (Ptr Tensor)
to_tdevicesbb _self _device _dtype _non_blocking _copy = [C.block| at::Tensor* { return new at::Tensor(at::native::to(*$(at::Tensor* _self), *$(at::Device* _device), *$(at::ScalarType* _dtype), $(bool _non_blocking), $(bool _copy))); }|]

to_tsbb :: Ptr Tensor -> Ptr ScalarType -> CBool -> CBool -> IO (Ptr Tensor)
to_tsbb _self _dtype _non_blocking _copy = [C.block| at::Tensor* { return new at::Tensor(at::native::to(*$(at::Tensor* _self), *$(at::ScalarType* _dtype), $(bool _non_blocking), $(bool _copy))); }|]

to_ttbb :: Ptr Tensor -> Ptr Tensor -> CBool -> CBool -> IO (Ptr Tensor)
to_ttbb _self _other _non_blocking _copy = [C.block| at::Tensor* { return new at::Tensor(at::native::to(*$(at::Tensor* _self), *$(at::Tensor* _other), $(bool _non_blocking), $(bool _copy))); }|]

meshgrid_l :: Ptr TensorList -> IO (Ptr TensorList)
meshgrid_l _tensors = [C.block| at::TensorList* { return new at::TensorList(at::native::meshgrid(*$(at::TensorList* _tensors))); }|]

cartesian_prod_l :: Ptr TensorList -> IO (Ptr Tensor)
cartesian_prod_l _tensors = [C.block| at::Tensor* { return new at::Tensor(at::native::cartesian_prod(*$(at::TensorList* _tensors))); }|]

combinations_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr Tensor)
combinations_tib _self _r _with_replacement = [C.block| at::Tensor* { return new at::Tensor(at::native::combinations(*$(at::Tensor* _self), $(int _r), $(bool _with_replacement))); }|]

item_t :: Ptr Tensor -> IO (Ptr Scalar)
item_t _self = [C.block| at::Scalar* { return new at::Scalar(at::native::item(*$(at::Tensor* _self))); }|]

_local_scalar_dense_cpu_t :: Ptr Tensor -> IO (Ptr Scalar)
_local_scalar_dense_cpu_t _self = [C.block| at::Scalar* { return new at::Scalar(at::native::_local_scalar_dense_cpu(*$(at::Tensor* _self))); }|]

_local_scalar_dense_cuda_t :: Ptr Tensor -> IO (Ptr Scalar)
_local_scalar_dense_cuda_t _self = [C.block| at::Scalar* { return new at::Scalar(at::native::_local_scalar_dense_cuda(*$(at::Tensor* _self))); }|]

_thnn_fused_lstm_cell_cuda_ttttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
_thnn_fused_lstm_cell_cuda_ttttt _input_gates _hidden_gates _cx _input_bias _hidden_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::_thnn_fused_lstm_cell_cuda(*$(at::Tensor* _input_gates), *$(at::Tensor* _hidden_gates), *$(at::Tensor* _cx), *$(at::Tensor* _input_bias), *$(at::Tensor* _hidden_bias))); }|]

_thnn_fused_lstm_cell_backward_cuda_tttttb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr (Tensor,Tensor,Tensor,Tensor,Tensor))
_thnn_fused_lstm_cell_backward_cuda_tttttb _grad_hy _grad_cy _cx _cy _workspace _has_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::native::_thnn_fused_lstm_cell_backward_cuda(*$(at::Tensor* _grad_hy), *$(at::Tensor* _grad_cy), *$(at::Tensor* _cx), *$(at::Tensor* _cy), *$(at::Tensor* _workspace), $(bool _has_bias))); }|]

_thnn_fused_gru_cell_cuda_ttttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
_thnn_fused_gru_cell_cuda_ttttt _input_gates _hidden_gates _hx _input_bias _hidden_bias = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_thnn_fused_gru_cell_cuda(*$(at::Tensor* _input_gates), *$(at::Tensor* _hidden_gates), *$(at::Tensor* _hx), *$(at::Tensor* _input_bias), *$(at::Tensor* _hidden_bias))); }|]

_thnn_fused_gru_cell_backward_cuda_ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr (Tensor,Tensor,Tensor,Tensor,Tensor))
_thnn_fused_gru_cell_backward_cuda_ttb _grad_hy _workspace _has_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>(at::native::_thnn_fused_gru_cell_backward_cuda(*$(at::Tensor* _grad_hy), *$(at::Tensor* _workspace), $(bool _has_bias))); }|]

lstm_tllbifbbb :: Ptr Tensor -> Ptr TensorList -> Ptr TensorList -> CBool -> Int -> CFloat -> CBool -> CBool -> CBool -> IO (Ptr (Tensor,Tensor,Tensor))
lstm_tllbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::lstm(*$(at::Tensor* _input), *$(at::TensorList* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(float _dropout), $(bool _train), $(bool _bidirectional), $(bool _batch_first))); }|]

lstm_ttllbifbb :: Ptr Tensor -> Ptr Tensor -> Ptr TensorList -> Ptr TensorList -> CBool -> Int -> CFloat -> CBool -> CBool -> IO (Ptr (Tensor,Tensor,Tensor))
lstm_ttllbifbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::lstm(*$(at::Tensor* _data), *$(at::Tensor* _batch_sizes), *$(at::TensorList* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(float _dropout), $(bool _train), $(bool _bidirectional))); }|]

gru_ttlbifbbb :: Ptr Tensor -> Ptr Tensor -> Ptr TensorList -> CBool -> Int -> CFloat -> CBool -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
gru_ttlbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gru(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(float _dropout), $(bool _train), $(bool _bidirectional), $(bool _batch_first))); }|]

gru_tttlbifbb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr TensorList -> CBool -> Int -> CFloat -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
gru_tttlbifbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gru(*$(at::Tensor* _data), *$(at::Tensor* _batch_sizes), *$(at::Tensor* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(float _dropout), $(bool _train), $(bool _bidirectional))); }|]

rnn_tanh_ttlbifbbb :: Ptr Tensor -> Ptr Tensor -> Ptr TensorList -> CBool -> Int -> CFloat -> CBool -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
rnn_tanh_ttlbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::rnn_tanh(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(float _dropout), $(bool _train), $(bool _bidirectional), $(bool _batch_first))); }|]

rnn_tanh_tttlbifbb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr TensorList -> CBool -> Int -> CFloat -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
rnn_tanh_tttlbifbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::rnn_tanh(*$(at::Tensor* _data), *$(at::Tensor* _batch_sizes), *$(at::Tensor* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(float _dropout), $(bool _train), $(bool _bidirectional))); }|]

rnn_relu_ttlbifbbb :: Ptr Tensor -> Ptr Tensor -> Ptr TensorList -> CBool -> Int -> CFloat -> CBool -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
rnn_relu_ttlbifbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::rnn_relu(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(float _dropout), $(bool _train), $(bool _bidirectional), $(bool _batch_first))); }|]

rnn_relu_tttlbifbb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr TensorList -> CBool -> Int -> CFloat -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
rnn_relu_tttlbifbb _data _batch_sizes _hx _params _has_biases _num_layers _dropout _train _bidirectional = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::rnn_relu(*$(at::Tensor* _data), *$(at::Tensor* _batch_sizes), *$(at::Tensor* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(float _dropout), $(bool _train), $(bool _bidirectional))); }|]

lstm_cell_tltttt :: Ptr Tensor -> Ptr TensorList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
lstm_cell_tltttt _input _hx _w_ih _w_hh _b_ih _b_hh = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::lstm_cell(*$(at::Tensor* _input), *$(at::TensorList* _hx), *$(at::Tensor* _w_ih), *$(at::Tensor* _w_hh), *$(at::Tensor* _b_ih), *$(at::Tensor* _b_hh))); }|]

gru_cell_tttttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
gru_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh = [C.block| at::Tensor* { return new at::Tensor(at::native::gru_cell(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::Tensor* _w_ih), *$(at::Tensor* _w_hh), *$(at::Tensor* _b_ih), *$(at::Tensor* _b_hh))); }|]

rnn_tanh_cell_tttttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
rnn_tanh_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh = [C.block| at::Tensor* { return new at::Tensor(at::native::rnn_tanh_cell(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::Tensor* _w_ih), *$(at::Tensor* _w_hh), *$(at::Tensor* _b_ih), *$(at::Tensor* _b_hh))); }|]

rnn_relu_cell_tttttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
rnn_relu_cell_tttttt _input _hx _w_ih _w_hh _b_ih _b_hh = [C.block| at::Tensor* { return new at::Tensor(at::native::rnn_relu_cell(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::Tensor* _w_ih), *$(at::Tensor* _w_hh), *$(at::Tensor* _b_ih), *$(at::Tensor* _b_hh))); }|]

quantized_lstm_tllbidbbb :: Ptr Tensor -> Ptr TensorList -> Ptr TensorList -> CBool -> Int -> CDouble -> CBool -> CBool -> CBool -> IO (Ptr (Tensor,Tensor,Tensor))
quantized_lstm_tllbidbbb _input _hx _params _has_biases _num_layers _dropout _train _bidirectional _batch_first = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::quantized_lstm(*$(at::Tensor* _input), *$(at::TensorList* _hx), *$(at::TensorList* _params), $(bool _has_biases), $(int _num_layers), $(double _dropout), $(bool _train), $(bool _bidirectional), $(bool _batch_first))); }|]

quantized_lstm_cell_tlttttttttssss :: Ptr Tensor -> Ptr TensorList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> IO (Ptr (Tensor,Tensor))
quantized_lstm_cell_tlttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::quantized_lstm_cell(*$(at::Tensor* _input), *$(at::TensorList* _hx), *$(at::Tensor* _w_ih), *$(at::Tensor* _w_hh), *$(at::Tensor* _b_ih), *$(at::Tensor* _b_hh), *$(at::Tensor* _packed_ih), *$(at::Tensor* _packed_hh), *$(at::Tensor* _col_offsets_ih), *$(at::Tensor* _col_offsets_hh), *$(at::Scalar* _scale_ih), *$(at::Scalar* _scale_hh), *$(at::Scalar* _zero_point_ih), *$(at::Scalar* _zero_point_hh))); }|]

quantized_gru_cell_ttttttttttssss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
quantized_gru_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh = [C.block| at::Tensor* { return new at::Tensor(at::native::quantized_gru_cell(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::Tensor* _w_ih), *$(at::Tensor* _w_hh), *$(at::Tensor* _b_ih), *$(at::Tensor* _b_hh), *$(at::Tensor* _packed_ih), *$(at::Tensor* _packed_hh), *$(at::Tensor* _col_offsets_ih), *$(at::Tensor* _col_offsets_hh), *$(at::Scalar* _scale_ih), *$(at::Scalar* _scale_hh), *$(at::Scalar* _zero_point_ih), *$(at::Scalar* _zero_point_hh))); }|]

quantized_rnn_relu_cell_ttttttttttssss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
quantized_rnn_relu_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh = [C.block| at::Tensor* { return new at::Tensor(at::native::quantized_rnn_relu_cell(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::Tensor* _w_ih), *$(at::Tensor* _w_hh), *$(at::Tensor* _b_ih), *$(at::Tensor* _b_hh), *$(at::Tensor* _packed_ih), *$(at::Tensor* _packed_hh), *$(at::Tensor* _col_offsets_ih), *$(at::Tensor* _col_offsets_hh), *$(at::Scalar* _scale_ih), *$(at::Scalar* _scale_hh), *$(at::Scalar* _zero_point_ih), *$(at::Scalar* _zero_point_hh))); }|]

quantized_rnn_tanh_cell_ttttttttttssss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
quantized_rnn_tanh_cell_ttttttttttssss _input _hx _w_ih _w_hh _b_ih _b_hh _packed_ih _packed_hh _col_offsets_ih _col_offsets_hh _scale_ih _scale_hh _zero_point_ih _zero_point_hh = [C.block| at::Tensor* { return new at::Tensor(at::native::quantized_rnn_tanh_cell(*$(at::Tensor* _input), *$(at::Tensor* _hx), *$(at::Tensor* _w_ih), *$(at::Tensor* _w_hh), *$(at::Tensor* _b_ih), *$(at::Tensor* _b_hh), *$(at::Tensor* _packed_ih), *$(at::Tensor* _packed_hh), *$(at::Tensor* _col_offsets_ih), *$(at::Tensor* _col_offsets_hh), *$(at::Scalar* _scale_ih), *$(at::Scalar* _scale_hh), *$(at::Scalar* _zero_point_ih), *$(at::Scalar* _zero_point_hh))); }|]

_pack_padded_sequence_ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr (Tensor,Tensor))
_pack_padded_sequence_ttb _input _lengths _batch_first = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_pack_padded_sequence(*$(at::Tensor* _input), *$(at::Tensor* _lengths), $(bool _batch_first))); }|]

_pack_padded_sequence_backward_tltb :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
_pack_padded_sequence_backward_tltb _grad _input_size _batch_sizes _batch_first = [C.block| at::Tensor* { return new at::Tensor(at::native::_pack_padded_sequence_backward(*$(at::Tensor* _grad), *$(at::IntArrayRef* _input_size), *$(at::Tensor* _batch_sizes), $(bool _batch_first))); }|]

_pad_packed_sequence_ttbsi :: Ptr Tensor -> Ptr Tensor -> CBool -> Ptr Scalar -> Int -> IO (Ptr (Tensor,Tensor))
_pad_packed_sequence_ttbsi _data _batch_sizes _batch_first _padding_value _total_length = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::_pad_packed_sequence(*$(at::Tensor* _data), *$(at::Tensor* _batch_sizes), $(bool _batch_first), *$(at::Scalar* _padding_value), $(int _total_length))); }|]

data_ptr_t :: Ptr Tensor -> IO ()
data_ptr_t _self = [C.block| void {  (at::native::data_ptr(*$(at::Tensor* _self))); }|]

set__Tstorage :: Ptr Tensor -> Ptr Storage -> IO (Ptr Tensor)
set__Tstorage _self _source = [C.block| at::Tensor* { return new at::Tensor(at::native::set_(*$(at::Tensor* _self), *$(at::Storage* _source))); }|]

set__Tstorageill :: Ptr Tensor -> Ptr Storage -> Int -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
set__Tstorageill _self _source _storage_offset _size _stride = [C.block| at::Tensor* { return new at::Tensor(at::native::set_(*$(at::Tensor* _self), *$(at::Storage* _source), $(int _storage_offset), *$(at::IntArrayRef* _size), *$(at::IntArrayRef* _stride))); }|]

set__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
set__Tt _self _source = [C.block| at::Tensor* { return new at::Tensor(at::native::set_(*$(at::Tensor* _self), *$(at::Tensor* _source))); }|]

set__T :: Ptr Tensor -> IO (Ptr Tensor)
set__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::set_(*$(at::Tensor* _self))); }|]

is_set_to_tt :: Ptr Tensor -> Ptr Tensor -> IO (CBool)
is_set_to_tt _self _tensor = [C.block| bool { return (at::native::is_set_to(*$(at::Tensor* _self), *$(at::Tensor* _tensor))); }|]

masked_fill__Tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
masked_fill__Tts _self _mask _value = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_fill_(*$(at::Tensor* _self), *$(at::Tensor* _mask), *$(at::Scalar* _value))); }|]

masked_fill_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
masked_fill_tts _self _mask _value = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_fill(*$(at::Tensor* _self), *$(at::Tensor* _mask), *$(at::Scalar* _value))); }|]

masked_fill__Ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
masked_fill__Ttt _self _mask _value = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_fill_(*$(at::Tensor* _self), *$(at::Tensor* _mask), *$(at::Tensor* _value))); }|]

masked_fill_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
masked_fill_ttt _self _mask _value = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_fill(*$(at::Tensor* _self), *$(at::Tensor* _mask), *$(at::Tensor* _value))); }|]

masked_scatter__Ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
masked_scatter__Ttt _self _mask _source = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_scatter_(*$(at::Tensor* _self), *$(at::Tensor* _mask), *$(at::Tensor* _source))); }|]

masked_scatter_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
masked_scatter_ttt _self _mask _source = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_scatter(*$(at::Tensor* _self), *$(at::Tensor* _mask), *$(at::Tensor* _source))); }|]

view_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
view_tl _self _size = [C.block| at::Tensor* { return new at::Tensor(at::native::view(*$(at::Tensor* _self), *$(at::IntArrayRef* _size))); }|]

put__Tttb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
put__Tttb _self _index _source _accumulate = [C.block| at::Tensor* { return new at::Tensor(at::native::put_(*$(at::Tensor* _self), *$(at::Tensor* _index), *$(at::Tensor* _source), $(bool _accumulate))); }|]

index_add__Titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
index_add__Titt _self _dim _index _source = [C.block| at::Tensor* { return new at::Tensor(at::native::index_add_(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _source))); }|]

index_add_titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
index_add_titt _self _dim _index _source = [C.block| at::Tensor* { return new at::Tensor(at::native::index_add(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _source))); }|]

index_fill__Tits :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
index_fill__Tits _self _dim _index _value = [C.block| at::Tensor* { return new at::Tensor(at::native::index_fill_(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Scalar* _value))); }|]

index_fill_tits :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
index_fill_tits _self _dim _index _value = [C.block| at::Tensor* { return new at::Tensor(at::native::index_fill(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Scalar* _value))); }|]

index_fill__Titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
index_fill__Titt _self _dim _index _value = [C.block| at::Tensor* { return new at::Tensor(at::native::index_fill_(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _value))); }|]

index_fill_titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
index_fill_titt _self _dim _index _value = [C.block| at::Tensor* { return new at::Tensor(at::native::index_fill(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _value))); }|]

scatter__Titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
scatter__Titt _self _dim _index _src = [C.block| at::Tensor* { return new at::Tensor(at::native::scatter_(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _src))); }|]

scatter_titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
scatter_titt _self _dim _index _src = [C.block| at::Tensor* { return new at::Tensor(at::native::scatter(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _src))); }|]

scatter__Tits :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
scatter__Tits _self _dim _index _value = [C.block| at::Tensor* { return new at::Tensor(at::native::scatter_(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Scalar* _value))); }|]

scatter_tits :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
scatter_tits _self _dim _index _value = [C.block| at::Tensor* { return new at::Tensor(at::native::scatter(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Scalar* _value))); }|]

scatter_add__Titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
scatter_add__Titt _self _dim _index _src = [C.block| at::Tensor* { return new at::Tensor(at::native::scatter_add_(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _src))); }|]

scatter_add_titt :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
scatter_add_titt _self _dim _index _src = [C.block| at::Tensor* { return new at::Tensor(at::native::scatter_add(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _src))); }|]

lt__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
lt__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::lt_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

lt__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
lt__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::lt_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

gt__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
gt__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::gt_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

gt__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
gt__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::gt_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

le__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
le__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::le_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

le__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
le__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::le_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

ge__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
ge__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::ge_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

ge__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
ge__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::ge_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

eq__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
eq__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::eq_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

eq__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
eq__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::eq_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

ne__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
ne__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::ne_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

ne__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
ne__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::ne_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__and___ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__and___ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__and__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__and___tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__and___tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__and__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__iand___Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__iand___Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__iand__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__iand___Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__iand___Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__iand__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__or___ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__or___ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__or__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__or___tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__or___tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__or__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__ior___Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__ior___Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__ior__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__ior___Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__ior___Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__ior__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__xor___ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__xor___ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__xor__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__xor___tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__xor___tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__xor__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__ixor___Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__ixor___Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__ixor__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__ixor___Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__ixor___Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__ixor__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__lshift___ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__lshift___ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__lshift__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__lshift___tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__lshift___tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__lshift__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__ilshift___Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__ilshift___Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__ilshift__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__ilshift___Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__ilshift___Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__ilshift__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__rshift___ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__rshift___ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__rshift__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__rshift___tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__rshift___tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__rshift__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

__irshift___Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
__irshift___Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__irshift__(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

__irshift___Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
__irshift___Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::__irshift__(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

lgamma__T :: Ptr Tensor -> IO (Ptr Tensor)
lgamma__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::lgamma_(*$(at::Tensor* _self))); }|]

atan2__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
atan2__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::atan2_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

tril_cpu__Ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
tril_cpu__Ti _self _diagonal = [C.block| at::Tensor* { return new at::Tensor(at::native::tril_cpu_(*$(at::Tensor* _self), $(int _diagonal))); }|]

tril_cuda__Ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
tril_cuda__Ti _self _diagonal = [C.block| at::Tensor* { return new at::Tensor(at::native::tril_cuda_(*$(at::Tensor* _self), $(int _diagonal))); }|]

triu_cpu__Ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
triu_cpu__Ti _self _diagonal = [C.block| at::Tensor* { return new at::Tensor(at::native::triu_cpu_(*$(at::Tensor* _self), $(int _diagonal))); }|]

triu_cuda__Ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
triu_cuda__Ti _self _diagonal = [C.block| at::Tensor* { return new at::Tensor(at::native::triu_cuda_(*$(at::Tensor* _self), $(int _diagonal))); }|]

digamma__T :: Ptr Tensor -> IO (Ptr Tensor)
digamma__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::digamma_(*$(at::Tensor* _self))); }|]

polygamma__Ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
polygamma__Ti _self _n = [C.block| at::Tensor* { return new at::Tensor(at::native::polygamma_(*$(at::Tensor* _self), $(int _n))); }|]

erfinv__T :: Ptr Tensor -> IO (Ptr Tensor)
erfinv__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::erfinv_(*$(at::Tensor* _self))); }|]

frac__T :: Ptr Tensor -> IO (Ptr Tensor)
frac__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::frac_(*$(at::Tensor* _self))); }|]

renorm__Tsis :: Ptr Tensor -> Ptr Scalar -> Int -> Ptr Scalar -> IO (Ptr Tensor)
renorm__Tsis _self _p _dim _maxnorm = [C.block| at::Tensor* { return new at::Tensor(at::native::renorm_(*$(at::Tensor* _self), *$(at::Scalar* _p), $(int _dim), *$(at::Scalar* _maxnorm))); }|]

reciprocal__T :: Ptr Tensor -> IO (Ptr Tensor)
reciprocal__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::reciprocal_(*$(at::Tensor* _self))); }|]

neg__T :: Ptr Tensor -> IO (Ptr Tensor)
neg__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::neg_(*$(at::Tensor* _self))); }|]

pow__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
pow__Ts _self _exponent = [C.block| at::Tensor* { return new at::Tensor(at::native::pow_(*$(at::Tensor* _self), *$(at::Scalar* _exponent))); }|]

pow__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
pow__Tt _self _exponent = [C.block| at::Tensor* { return new at::Tensor(at::native::pow_(*$(at::Tensor* _self), *$(at::Tensor* _exponent))); }|]

lerp__Tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
lerp__Tts _self _end _weight = [C.block| at::Tensor* { return new at::Tensor(at::native::lerp_(*$(at::Tensor* _self), *$(at::Tensor* _end), *$(at::Scalar* _weight))); }|]

sign__T :: Ptr Tensor -> IO (Ptr Tensor)
sign__T _self = [C.block| at::Tensor* { return new at::Tensor(at::native::sign_(*$(at::Tensor* _self))); }|]

fmod__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
fmod__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::fmod_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

fmod__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
fmod__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::fmod_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

remainder__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
remainder__Ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::remainder_(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

remainder__Tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
remainder__Tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::remainder_(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

addbmm__Tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
addbmm__Tttss _self _batch1 _batch2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::addbmm_(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

addbmm_tttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
addbmm_tttssT _self _batch1 _batch2 _beta _alpha _out = [C.block| at::Tensor* { return new at::Tensor(at::native::addbmm(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha), *$(at::Tensor* _out))); }|]

addbmm_tttss :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
addbmm_tttss _self _batch1 _batch2 _beta _alpha = [C.block| at::Tensor* { return new at::Tensor(at::native::addbmm(*$(at::Tensor* _self), *$(at::Tensor* _batch1), *$(at::Tensor* _batch2), *$(at::Scalar* _beta), *$(at::Scalar* _alpha))); }|]

addcmul__Ttts :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
addcmul__Ttts _self _tensor1 _tensor2 _value = [C.block| at::Tensor* { return new at::Tensor(at::native::addcmul_(*$(at::Tensor* _self), *$(at::Tensor* _tensor1), *$(at::Tensor* _tensor2), *$(at::Scalar* _value))); }|]

addcdiv__Ttts :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
addcdiv__Ttts _self _tensor1 _tensor2 _value = [C.block| at::Tensor* { return new at::Tensor(at::native::addcdiv_(*$(at::Tensor* _self), *$(at::Tensor* _tensor1), *$(at::Tensor* _tensor2), *$(at::Scalar* _value))); }|]

random__Tiip :: Ptr Tensor -> Int -> Int -> Ptr Generator -> IO (Ptr Tensor)
random__Tiip _self _from _to _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::random_(*$(at::Tensor* _self), $(int _from), $(int _to), $(at::Generator * _generator))); }|]

random__Tip :: Ptr Tensor -> Int -> Ptr Generator -> IO (Ptr Tensor)
random__Tip _self _to _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::random_(*$(at::Tensor* _self), $(int _to), $(at::Generator * _generator))); }|]

random__Tp :: Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
random__Tp _self _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::random_(*$(at::Tensor* _self), $(at::Generator * _generator))); }|]

uniform__Tffp :: Ptr Tensor -> CFloat -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
uniform__Tffp _self _from _to _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::uniform_(*$(at::Tensor* _self), $(float _from), $(float _to), $(at::Generator * _generator))); }|]

normal__Tffp :: Ptr Tensor -> CFloat -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
normal__Tffp _self _mean _std _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::normal_(*$(at::Tensor* _self), $(float _mean), $(float _std), $(at::Generator * _generator))); }|]

cauchy__Tffp :: Ptr Tensor -> CFloat -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
cauchy__Tffp _self _median _sigma _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::cauchy_(*$(at::Tensor* _self), $(float _median), $(float _sigma), $(at::Generator * _generator))); }|]

log_normal__Tffp :: Ptr Tensor -> CFloat -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
log_normal__Tffp _self _mean _std _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::log_normal_(*$(at::Tensor* _self), $(float _mean), $(float _std), $(at::Generator * _generator))); }|]

exponential__Tfp :: Ptr Tensor -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
exponential__Tfp _self _lambd _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::exponential_(*$(at::Tensor* _self), $(float _lambd), $(at::Generator * _generator))); }|]

geometric__Tfp :: Ptr Tensor -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
geometric__Tfp _self _p _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::geometric_(*$(at::Tensor* _self), $(float _p), $(at::Generator * _generator))); }|]

diag_tiT :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
diag_tiT _self _diagonal _out = [C.block| at::Tensor* { return new at::Tensor(at::native::diag(*$(at::Tensor* _self), $(int _diagonal), *$(at::Tensor* _out))); }|]

diag_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
diag_ti _self _diagonal = [C.block| at::Tensor* { return new at::Tensor(at::native::diag(*$(at::Tensor* _self), $(int _diagonal))); }|]

cross_ttiT :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
cross_ttiT _self _other _dim _out = [C.block| at::Tensor* { return new at::Tensor(at::native::cross(*$(at::Tensor* _self), *$(at::Tensor* _other), $(int _dim), *$(at::Tensor* _out))); }|]

cross_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
cross_tti _self _other _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::cross(*$(at::Tensor* _self), *$(at::Tensor* _other), $(int _dim))); }|]

triu_cpu_out_tiT :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
triu_cpu_out_tiT _self _diagonal _out = [C.block| at::Tensor* { return new at::Tensor(at::native::triu_cpu_out(*$(at::Tensor* _self), $(int _diagonal), *$(at::Tensor* _out))); }|]

triu_cuda_out_tiT :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
triu_cuda_out_tiT _self _diagonal _out = [C.block| at::Tensor* { return new at::Tensor(at::native::triu_cuda_out(*$(at::Tensor* _self), $(int _diagonal), *$(at::Tensor* _out))); }|]

triu_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
triu_ti _self _diagonal = [C.block| at::Tensor* { return new at::Tensor(at::native::triu(*$(at::Tensor* _self), $(int _diagonal))); }|]

tril_cpu_out_tiT :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
tril_cpu_out_tiT _self _diagonal _out = [C.block| at::Tensor* { return new at::Tensor(at::native::tril_cpu_out(*$(at::Tensor* _self), $(int _diagonal), *$(at::Tensor* _out))); }|]

tril_cuda_out_tiT :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
tril_cuda_out_tiT _self _diagonal _out = [C.block| at::Tensor* { return new at::Tensor(at::native::tril_cuda_out(*$(at::Tensor* _self), $(int _diagonal), *$(at::Tensor* _out))); }|]

tril_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
tril_ti _self _diagonal = [C.block| at::Tensor* { return new at::Tensor(at::native::tril(*$(at::Tensor* _self), $(int _diagonal))); }|]

tril_indices_cpu_iiio :: Int -> Int -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
tril_indices_cpu_iiio _row _col _offset _options = [C.block| at::Tensor* { return new at::Tensor(at::native::tril_indices_cpu($(int _row), $(int _col), $(int _offset), *$(at::TensorOptions* _options))); }|]

tril_indices_cuda_iiio :: Int -> Int -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
tril_indices_cuda_iiio _row _col _offset _options = [C.block| at::Tensor* { return new at::Tensor(at::native::tril_indices_cuda($(int _row), $(int _col), $(int _offset), *$(at::TensorOptions* _options))); }|]

triu_indices_cpu_iiio :: Int -> Int -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
triu_indices_cpu_iiio _row _col _offset _options = [C.block| at::Tensor* { return new at::Tensor(at::native::triu_indices_cpu($(int _row), $(int _col), $(int _offset), *$(at::TensorOptions* _options))); }|]

triu_indices_cuda_iiio :: Int -> Int -> Int -> Ptr TensorOptions -> IO (Ptr Tensor)
triu_indices_cuda_iiio _row _col _offset _options = [C.block| at::Tensor* { return new at::Tensor(at::native::triu_indices_cuda($(int _row), $(int _col), $(int _offset), *$(at::TensorOptions* _options))); }|]

trace_t :: Ptr Tensor -> IO (Ptr Tensor)
trace_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::trace(*$(at::Tensor* _self))); }|]

ne_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
ne_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::ne(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

ne_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
ne_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::ne(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

ne_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
ne_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::ne(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

ne_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
ne_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::ne(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

eq_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
eq_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::eq(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

eq_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
eq_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::eq(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

eq_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
eq_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::eq(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

eq_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
eq_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::eq(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

ge_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
ge_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::ge(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

ge_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
ge_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::ge(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

ge_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
ge_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::ge(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

ge_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
ge_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::ge(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

le_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
le_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::le(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

le_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
le_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::le(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

le_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
le_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::le(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

le_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
le_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::le(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

gt_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
gt_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::gt(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

gt_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
gt_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::gt(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

gt_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
gt_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::gt(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

gt_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
gt_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::gt(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

lt_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
lt_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::lt(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

lt_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
lt_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::lt(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

lt_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
lt_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::lt(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

lt_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
lt_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::lt(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

take_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
take_ttT _self _index _out = [C.block| at::Tensor* { return new at::Tensor(at::native::take(*$(at::Tensor* _self), *$(at::Tensor* _index), *$(at::Tensor* _out))); }|]

take_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
take_tt _self _index = [C.block| at::Tensor* { return new at::Tensor(at::native::take(*$(at::Tensor* _self), *$(at::Tensor* _index))); }|]

index_select_titT :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
index_select_titT _self _dim _index _out = [C.block| at::Tensor* { return new at::Tensor(at::native::index_select(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _out))); }|]

index_select_tit :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
index_select_tit _self _dim _index = [C.block| at::Tensor* { return new at::Tensor(at::native::index_select(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index))); }|]

masked_select_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
masked_select_ttT _self _mask _out = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_select(*$(at::Tensor* _self), *$(at::Tensor* _mask), *$(at::Tensor* _out))); }|]

masked_select_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
masked_select_tt _self _mask = [C.block| at::Tensor* { return new at::Tensor(at::native::masked_select(*$(at::Tensor* _self), *$(at::Tensor* _mask))); }|]

nonzero_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
nonzero_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::nonzero(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

nonzero_t :: Ptr Tensor -> IO (Ptr Tensor)
nonzero_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::nonzero(*$(at::Tensor* _self))); }|]

gather_titT :: Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
gather_titT _self _dim _index _out = [C.block| at::Tensor* { return new at::Tensor(at::native::gather(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index), *$(at::Tensor* _out))); }|]

gather_tit :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
gather_tit _self _dim _index = [C.block| at::Tensor* { return new at::Tensor(at::native::gather(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _index))); }|]

addcmul_tttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
addcmul_tttsT _self _tensor1 _tensor2 _value _out = [C.block| at::Tensor* { return new at::Tensor(at::native::addcmul(*$(at::Tensor* _self), *$(at::Tensor* _tensor1), *$(at::Tensor* _tensor2), *$(at::Scalar* _value), *$(at::Tensor* _out))); }|]

addcmul_ttts :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
addcmul_ttts _self _tensor1 _tensor2 _value = [C.block| at::Tensor* { return new at::Tensor(at::native::addcmul(*$(at::Tensor* _self), *$(at::Tensor* _tensor1), *$(at::Tensor* _tensor2), *$(at::Scalar* _value))); }|]

addcdiv_tttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
addcdiv_tttsT _self _tensor1 _tensor2 _value _out = [C.block| at::Tensor* { return new at::Tensor(at::native::addcdiv(*$(at::Tensor* _self), *$(at::Tensor* _tensor1), *$(at::Tensor* _tensor2), *$(at::Scalar* _value), *$(at::Tensor* _out))); }|]

addcdiv_ttts :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
addcdiv_ttts _self _tensor1 _tensor2 _value = [C.block| at::Tensor* { return new at::Tensor(at::native::addcdiv(*$(at::Tensor* _self), *$(at::Tensor* _tensor1), *$(at::Tensor* _tensor2), *$(at::Scalar* _value))); }|]

gels_ttTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
gels_ttTT _self _A _X _qr = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gels(*$(at::Tensor* _self), *$(at::Tensor* _A), *$(at::Tensor* _X), *$(at::Tensor* _qr))); }|]

gels_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
gels_tt _self _A = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::gels(*$(at::Tensor* _self), *$(at::Tensor* _A))); }|]

trtrs_ttbbbTT :: Ptr Tensor -> Ptr Tensor -> CBool -> CBool -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
trtrs_ttbbbTT _self _A _upper _transpose _unitriangular _X _M = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::trtrs(*$(at::Tensor* _self), *$(at::Tensor* _A), $(bool _upper), $(bool _transpose), $(bool _unitriangular), *$(at::Tensor* _X), *$(at::Tensor* _M))); }|]

trtrs_ttbbb :: Ptr Tensor -> Ptr Tensor -> CBool -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
trtrs_ttbbb _self _A _upper _transpose _unitriangular = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::trtrs(*$(at::Tensor* _self), *$(at::Tensor* _A), $(bool _upper), $(bool _transpose), $(bool _unitriangular))); }|]

symeig_tbbTT :: Ptr Tensor -> CBool -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
symeig_tbbTT _self _eigenvectors _upper _e _V = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::symeig(*$(at::Tensor* _self), $(bool _eigenvectors), $(bool _upper), *$(at::Tensor* _e), *$(at::Tensor* _V))); }|]

symeig_tbb :: Ptr Tensor -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
symeig_tbb _self _eigenvectors _upper = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::symeig(*$(at::Tensor* _self), $(bool _eigenvectors), $(bool _upper))); }|]

eig_tbTT :: Ptr Tensor -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
eig_tbTT _self _eigenvectors _e _v = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::eig(*$(at::Tensor* _self), $(bool _eigenvectors), *$(at::Tensor* _e), *$(at::Tensor* _v))); }|]

eig_tb :: Ptr Tensor -> CBool -> IO (Ptr (Tensor,Tensor))
eig_tb _self _eigenvectors = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::eig(*$(at::Tensor* _self), $(bool _eigenvectors))); }|]

svd_tbbTTT :: Ptr Tensor -> CBool -> CBool -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
svd_tbbTTT _self _some _compute_uv _U _S _V = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::svd(*$(at::Tensor* _self), $(bool _some), $(bool _compute_uv), *$(at::Tensor* _U), *$(at::Tensor* _S), *$(at::Tensor* _V))); }|]

svd_tbb :: Ptr Tensor -> CBool -> CBool -> IO (Ptr (Tensor,Tensor,Tensor))
svd_tbb _self _some _compute_uv = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::svd(*$(at::Tensor* _self), $(bool _some), $(bool _compute_uv))); }|]

cholesky_tbT :: Ptr Tensor -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
cholesky_tbT _self _upper _out = [C.block| at::Tensor* { return new at::Tensor(at::native::cholesky(*$(at::Tensor* _self), $(bool _upper), *$(at::Tensor* _out))); }|]

cholesky_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
cholesky_tb _self _upper = [C.block| at::Tensor* { return new at::Tensor(at::native::cholesky(*$(at::Tensor* _self), $(bool _upper))); }|]

_cholesky_helper_cpu_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cholesky_helper_cpu_tb _self _upper = [C.block| at::Tensor* { return new at::Tensor(at::native::_cholesky_helper_cpu(*$(at::Tensor* _self), $(bool _upper))); }|]

_cholesky_helper_cuda_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cholesky_helper_cuda_tb _self _upper = [C.block| at::Tensor* { return new at::Tensor(at::native::_cholesky_helper_cuda(*$(at::Tensor* _self), $(bool _upper))); }|]

cholesky_solve_ttbT :: Ptr Tensor -> Ptr Tensor -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
cholesky_solve_ttbT _self _input2 _upper _out = [C.block| at::Tensor* { return new at::Tensor(at::native::cholesky_solve(*$(at::Tensor* _self), *$(at::Tensor* _input2), $(bool _upper), *$(at::Tensor* _out))); }|]

cholesky_solve_ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
cholesky_solve_ttb _self _input2 _upper = [C.block| at::Tensor* { return new at::Tensor(at::native::cholesky_solve(*$(at::Tensor* _self), *$(at::Tensor* _input2), $(bool _upper))); }|]

_cholesky_solve_helper_cpu_ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cholesky_solve_helper_cpu_ttb _self _A _upper = [C.block| at::Tensor* { return new at::Tensor(at::native::_cholesky_solve_helper_cpu(*$(at::Tensor* _self), *$(at::Tensor* _A), $(bool _upper))); }|]

_cholesky_solve_helper_cuda_ttb :: Ptr Tensor -> Ptr Tensor -> CBool -> IO (Ptr Tensor)
_cholesky_solve_helper_cuda_ttb _self _A _upper = [C.block| at::Tensor* { return new at::Tensor(at::native::_cholesky_solve_helper_cuda(*$(at::Tensor* _self), *$(at::Tensor* _A), $(bool _upper))); }|]

potri_tbT :: Ptr Tensor -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
potri_tbT _self _upper _out = [C.block| at::Tensor* { return new at::Tensor(at::native::potri(*$(at::Tensor* _self), $(bool _upper), *$(at::Tensor* _out))); }|]

potri_tb :: Ptr Tensor -> CBool -> IO (Ptr Tensor)
potri_tb _self _upper = [C.block| at::Tensor* { return new at::Tensor(at::native::potri(*$(at::Tensor* _self), $(bool _upper))); }|]

pstrf_tbsTT :: Ptr Tensor -> CBool -> Ptr Scalar -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
pstrf_tbsTT _self _upper _tol _u _piv = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::pstrf(*$(at::Tensor* _self), $(bool _upper), *$(at::Scalar* _tol), *$(at::Tensor* _u), *$(at::Tensor* _piv))); }|]

pstrf_tbs :: Ptr Tensor -> CBool -> Ptr Scalar -> IO (Ptr (Tensor,Tensor))
pstrf_tbs _self _upper _tol = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::pstrf(*$(at::Tensor* _self), $(bool _upper), *$(at::Scalar* _tol))); }|]

qr_tTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
qr_tTT _self _Q _R = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::qr(*$(at::Tensor* _self), *$(at::Tensor* _Q), *$(at::Tensor* _R))); }|]

qr_t :: Ptr Tensor -> IO (Ptr (Tensor,Tensor))
qr_t _self = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::qr(*$(at::Tensor* _self))); }|]

geqrf_tTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
geqrf_tTT _self _out0 _out1 = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::geqrf(*$(at::Tensor* _self), *$(at::Tensor* _out0), *$(at::Tensor* _out1))); }|]

geqrf_t :: Ptr Tensor -> IO (Ptr (Tensor,Tensor))
geqrf_t _self = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::geqrf(*$(at::Tensor* _self))); }|]

orgqr_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
orgqr_ttT _self _input2 _out = [C.block| at::Tensor* { return new at::Tensor(at::native::orgqr(*$(at::Tensor* _self), *$(at::Tensor* _input2), *$(at::Tensor* _out))); }|]

orgqr_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
orgqr_tt _self _input2 = [C.block| at::Tensor* { return new at::Tensor(at::native::orgqr(*$(at::Tensor* _self), *$(at::Tensor* _input2))); }|]

ormqr_tttbbT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
ormqr_tttbbT _self _input2 _input3 _left _transpose _out = [C.block| at::Tensor* { return new at::Tensor(at::native::ormqr(*$(at::Tensor* _self), *$(at::Tensor* _input2), *$(at::Tensor* _input3), $(bool _left), $(bool _transpose), *$(at::Tensor* _out))); }|]

ormqr_tttbb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> CBool -> CBool -> IO (Ptr Tensor)
ormqr_tttbb _self _input2 _input3 _left _transpose = [C.block| at::Tensor* { return new at::Tensor(at::native::ormqr(*$(at::Tensor* _self), *$(at::Tensor* _input2), *$(at::Tensor* _input3), $(bool _left), $(bool _transpose))); }|]

btrifact_tbTT :: Ptr Tensor -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
btrifact_tbTT _self _pivot _A_LU _pivots = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::btrifact(*$(at::Tensor* _self), $(bool _pivot), *$(at::Tensor* _A_LU), *$(at::Tensor* _pivots))); }|]

btrifact_tb :: Ptr Tensor -> CBool -> IO (Ptr (Tensor,Tensor))
btrifact_tb _self _pivot = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::btrifact(*$(at::Tensor* _self), $(bool _pivot))); }|]

btrifact_with_info_tbTTT :: Ptr Tensor -> CBool -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
btrifact_with_info_tbTTT _self _pivot _A_LU _pivots _info = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::btrifact_with_info(*$(at::Tensor* _self), $(bool _pivot), *$(at::Tensor* _A_LU), *$(at::Tensor* _pivots), *$(at::Tensor* _info))); }|]

btrifact_with_info_tb :: Ptr Tensor -> CBool -> IO (Ptr (Tensor,Tensor,Tensor))
btrifact_with_info_tb _self _pivot = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::btrifact_with_info(*$(at::Tensor* _self), $(bool _pivot))); }|]

btrisolve_tttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
btrisolve_tttT _self _LU_data _LU_pivots _out = [C.block| at::Tensor* { return new at::Tensor(at::native::btrisolve(*$(at::Tensor* _self), *$(at::Tensor* _LU_data), *$(at::Tensor* _LU_pivots), *$(at::Tensor* _out))); }|]

btrisolve_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
btrisolve_ttt _self _LU_data _LU_pivots = [C.block| at::Tensor* { return new at::Tensor(at::native::btrisolve(*$(at::Tensor* _self), *$(at::Tensor* _LU_data), *$(at::Tensor* _LU_pivots))); }|]

multinomial_tibpT :: Ptr Tensor -> Int -> CBool -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
multinomial_tibpT _self _num_samples _replacement _generator _out = [C.block| at::Tensor* { return new at::Tensor(at::native::multinomial(*$(at::Tensor* _self), $(int _num_samples), $(bool _replacement), $(at::Generator * _generator), *$(at::Tensor* _out))); }|]

multinomial_tibp :: Ptr Tensor -> Int -> CBool -> Ptr Generator -> IO (Ptr Tensor)
multinomial_tibp _self _num_samples _replacement _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::multinomial(*$(at::Tensor* _self), $(int _num_samples), $(bool _replacement), $(at::Generator * _generator))); }|]

lgamma_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
lgamma_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::lgamma(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

lgamma_t :: Ptr Tensor -> IO (Ptr Tensor)
lgamma_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::lgamma(*$(at::Tensor* _self))); }|]

digamma_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
digamma_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::digamma(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

digamma_t :: Ptr Tensor -> IO (Ptr Tensor)
digamma_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::digamma(*$(at::Tensor* _self))); }|]

polygamma_itT :: Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
polygamma_itT _n _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::polygamma($(int _n), *$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

polygamma_it :: Int -> Ptr Tensor -> IO (Ptr Tensor)
polygamma_it _n _self = [C.block| at::Tensor* { return new at::Tensor(at::native::polygamma($(int _n), *$(at::Tensor* _self))); }|]

erfinv_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
erfinv_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::erfinv(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

erfinv_t :: Ptr Tensor -> IO (Ptr Tensor)
erfinv_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::erfinv(*$(at::Tensor* _self))); }|]

frac_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
frac_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::frac(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

frac_t :: Ptr Tensor -> IO (Ptr Tensor)
frac_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::frac(*$(at::Tensor* _self))); }|]

dist_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
dist_tts _self _other _p = [C.block| at::Tensor* { return new at::Tensor(at::native::dist(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Scalar* _p))); }|]

reciprocal_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
reciprocal_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::reciprocal(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

reciprocal_t :: Ptr Tensor -> IO (Ptr Tensor)
reciprocal_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::reciprocal(*$(at::Tensor* _self))); }|]

neg_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
neg_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::neg(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

neg_t :: Ptr Tensor -> IO (Ptr Tensor)
neg_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::neg(*$(at::Tensor* _self))); }|]

atan2_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
atan2_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::atan2(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

atan2_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
atan2_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::atan2(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

lerp_ttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
lerp_ttsT _self _end _weight _out = [C.block| at::Tensor* { return new at::Tensor(at::native::lerp(*$(at::Tensor* _self), *$(at::Tensor* _end), *$(at::Scalar* _weight), *$(at::Tensor* _out))); }|]

lerp_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
lerp_tts _self _end _weight = [C.block| at::Tensor* { return new at::Tensor(at::native::lerp(*$(at::Tensor* _self), *$(at::Tensor* _end), *$(at::Scalar* _weight))); }|]

_histc_out_cpu_tissT :: Ptr Tensor -> Int -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_histc_out_cpu_tissT _self _bins _min _max _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_histc_out_cpu(*$(at::Tensor* _self), $(int _bins), *$(at::Scalar* _min), *$(at::Scalar* _max), *$(at::Tensor* _out))); }|]

_histc_out_cuda_tissT :: Ptr Tensor -> Int -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
_histc_out_cuda_tissT _self _bins _min _max _out = [C.block| at::Tensor* { return new at::Tensor(at::native::_histc_out_cuda(*$(at::Tensor* _self), $(int _bins), *$(at::Scalar* _min), *$(at::Scalar* _max), *$(at::Tensor* _out))); }|]

_histc_cpu_tiss :: Ptr Tensor -> Int -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
_histc_cpu_tiss _self _bins _min _max = [C.block| at::Tensor* { return new at::Tensor(at::native::_histc_cpu(*$(at::Tensor* _self), $(int _bins), *$(at::Scalar* _min), *$(at::Scalar* _max))); }|]

_histc_cuda_tiss :: Ptr Tensor -> Int -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
_histc_cuda_tiss _self _bins _min _max = [C.block| at::Tensor* { return new at::Tensor(at::native::_histc_cuda(*$(at::Tensor* _self), $(int _bins), *$(at::Scalar* _min), *$(at::Scalar* _max))); }|]

sign_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
sign_tT _self _out = [C.block| at::Tensor* { return new at::Tensor(at::native::sign(*$(at::Tensor* _self), *$(at::Tensor* _out))); }|]

sign_t :: Ptr Tensor -> IO (Ptr Tensor)
sign_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::sign(*$(at::Tensor* _self))); }|]

fmod_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
fmod_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::fmod(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

fmod_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
fmod_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::fmod(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

fmod_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
fmod_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::fmod(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

fmod_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
fmod_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::fmod(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

remainder_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
remainder_tsT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::remainder(*$(at::Tensor* _self), *$(at::Scalar* _other), *$(at::Tensor* _out))); }|]

remainder_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
remainder_ts _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::remainder(*$(at::Tensor* _self), *$(at::Scalar* _other))); }|]

remainder_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
remainder_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::remainder(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

remainder_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
remainder_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::remainder(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

min_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
min_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::min(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

min_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
min_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::min(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

min_t :: Ptr Tensor -> IO (Ptr Tensor)
min_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::min(*$(at::Tensor* _self))); }|]

max_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
max_ttT _self _other _out = [C.block| at::Tensor* { return new at::Tensor(at::native::max(*$(at::Tensor* _self), *$(at::Tensor* _other), *$(at::Tensor* _out))); }|]

max_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
max_tt _self _other = [C.block| at::Tensor* { return new at::Tensor(at::native::max(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

max_t :: Ptr Tensor -> IO (Ptr Tensor)
max_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::max(*$(at::Tensor* _self))); }|]

median_t :: Ptr Tensor -> IO (Ptr Tensor)
median_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::median(*$(at::Tensor* _self))); }|]

sort_tibTT :: Ptr Tensor -> Int -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
sort_tibTT _self _dim _descending _values _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::sort(*$(at::Tensor* _self), $(int _dim), $(bool _descending), *$(at::Tensor* _values), *$(at::Tensor* _indices))); }|]

sort_tib :: Ptr Tensor -> Int -> CBool -> IO (Ptr (Tensor,Tensor))
sort_tib _self _dim _descending = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::sort(*$(at::Tensor* _self), $(int _dim), $(bool _descending))); }|]

topk_tiibbTT :: Ptr Tensor -> Int -> Int -> CBool -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
topk_tiibbTT _self _k _dim _largest _sorted _values _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::topk(*$(at::Tensor* _self), $(int _k), $(int _dim), $(bool _largest), $(bool _sorted), *$(at::Tensor* _values), *$(at::Tensor* _indices))); }|]

topk_tiibb :: Ptr Tensor -> Int -> Int -> CBool -> CBool -> IO (Ptr (Tensor,Tensor))
topk_tiibb _self _k _dim _largest _sorted = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::topk(*$(at::Tensor* _self), $(int _k), $(int _dim), $(bool _largest), $(bool _sorted))); }|]

all_t :: Ptr Tensor -> IO (Ptr Tensor)
all_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::all(*$(at::Tensor* _self))); }|]

any_t :: Ptr Tensor -> IO (Ptr Tensor)
any_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::any(*$(at::Tensor* _self))); }|]

renorm_tsisT :: Ptr Tensor -> Ptr Scalar -> Int -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
renorm_tsisT _self _p _dim _maxnorm _out = [C.block| at::Tensor* { return new at::Tensor(at::native::renorm(*$(at::Tensor* _self), *$(at::Scalar* _p), $(int _dim), *$(at::Scalar* _maxnorm), *$(at::Tensor* _out))); }|]

renorm_tsis :: Ptr Tensor -> Ptr Scalar -> Int -> Ptr Scalar -> IO (Ptr Tensor)
renorm_tsis _self _p _dim _maxnorm = [C.block| at::Tensor* { return new at::Tensor(at::native::renorm(*$(at::Tensor* _self), *$(at::Scalar* _p), $(int _dim), *$(at::Scalar* _maxnorm))); }|]

unfold_tiii :: Ptr Tensor -> Int -> Int -> Int -> IO (Ptr Tensor)
unfold_tiii _self _dimension _size _step = [C.block| at::Tensor* { return new at::Tensor(at::native::unfold(*$(at::Tensor* _self), $(int _dimension), $(int _size), $(int _step))); }|]

equal_tt :: Ptr Tensor -> Ptr Tensor -> IO (CBool)
equal_tt _self _other = [C.block| bool { return (at::native::equal(*$(at::Tensor* _self), *$(at::Tensor* _other))); }|]

pow_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
pow_ttT _self _exponent _out = [C.block| at::Tensor* { return new at::Tensor(at::native::pow(*$(at::Tensor* _self), *$(at::Tensor* _exponent), *$(at::Tensor* _out))); }|]

pow_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
pow_tt _self _exponent = [C.block| at::Tensor* { return new at::Tensor(at::native::pow(*$(at::Tensor* _self), *$(at::Tensor* _exponent))); }|]

pow_stT :: Ptr Scalar -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
pow_stT _self _exponent _out = [C.block| at::Tensor* { return new at::Tensor(at::native::pow(*$(at::Scalar* _self), *$(at::Tensor* _exponent), *$(at::Tensor* _out))); }|]

pow_st :: Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
pow_st _self _exponent = [C.block| at::Tensor* { return new at::Tensor(at::native::pow(*$(at::Scalar* _self), *$(at::Tensor* _exponent))); }|]

normal_tfpT :: Ptr Tensor -> CFloat -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
normal_tfpT _mean _std _generator _output = [C.block| at::Tensor* { return new at::Tensor(at::native::normal(*$(at::Tensor* _mean), $(float _std), $(at::Generator * _generator), *$(at::Tensor* _output))); }|]

normal_tfp :: Ptr Tensor -> CFloat -> Ptr Generator -> IO (Ptr Tensor)
normal_tfp _mean _std _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::normal(*$(at::Tensor* _mean), $(float _std), $(at::Generator * _generator))); }|]

normal_ftpT :: CFloat -> Ptr Tensor -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
normal_ftpT _mean _std _generator _output = [C.block| at::Tensor* { return new at::Tensor(at::native::normal($(float _mean), *$(at::Tensor* _std), $(at::Generator * _generator), *$(at::Tensor* _output))); }|]

normal_dtp :: CDouble -> Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
normal_dtp _mean _std _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::normal($(double _mean), *$(at::Tensor* _std), $(at::Generator * _generator))); }|]

normal_ttpT :: Ptr Tensor -> Ptr Tensor -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
normal_ttpT _mean _std _generator _output = [C.block| at::Tensor* { return new at::Tensor(at::native::normal(*$(at::Tensor* _mean), *$(at::Tensor* _std), $(at::Generator * _generator), *$(at::Tensor* _output))); }|]

normal_ttp :: Ptr Tensor -> Ptr Tensor -> Ptr Generator -> IO (Ptr Tensor)
normal_ttp _mean _std _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::normal(*$(at::Tensor* _mean), *$(at::Tensor* _std), $(at::Generator * _generator))); }|]

alias_t :: Ptr Tensor -> IO (Ptr Tensor)
alias_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::alias(*$(at::Tensor* _self))); }|]

_dirichlet_grad_tttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_dirichlet_grad_tttT _x _alpha _total _output = [C.block| at::Tensor* { return new at::Tensor(at::native::_dirichlet_grad(*$(at::Tensor* _x), *$(at::Tensor* _alpha), *$(at::Tensor* _total), *$(at::Tensor* _output))); }|]

_dirichlet_grad_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
_dirichlet_grad_ttt _x _alpha _total = [C.block| at::Tensor* { return new at::Tensor(at::native::_dirichlet_grad(*$(at::Tensor* _x), *$(at::Tensor* _alpha), *$(at::Tensor* _total))); }|]

binary_cross_entropy_tttiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
binary_cross_entropy_tttiT _self _target _weight _reduction _output = [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), *$(at::Tensor* _output))); }|]

binary_cross_entropy_ttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
binary_cross_entropy_ttti _self _target _weight _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction))); }|]

binary_cross_entropy_backward_ttttiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
binary_cross_entropy_backward_ttttiT _grad_output _self _target _weight _reduction _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), *$(at::Tensor* _grad_input))); }|]

binary_cross_entropy_backward_tttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
binary_cross_entropy_backward_tttti _grad_output _self _target _weight _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::binary_cross_entropy_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction))); }|]

mse_loss_ttiT :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
mse_loss_ttiT _self _target _reduction _output = [C.block| at::Tensor* { return new at::Tensor(at::native::mse_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _output))); }|]

mse_loss_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
mse_loss_tti _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::mse_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

mse_loss_backward_tttiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
mse_loss_backward_tttiT _grad_output _self _target _reduction _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::mse_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _grad_input))); }|]

mse_loss_backward_ttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
mse_loss_backward_ttti _grad_output _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::mse_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

l1_loss_ttiT :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
l1_loss_ttiT _self _target _reduction _output = [C.block| at::Tensor* { return new at::Tensor(at::native::l1_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _output))); }|]

l1_loss_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
l1_loss_tti _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::l1_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

l1_loss_backward_tttiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
l1_loss_backward_tttiT _grad_output _self _target _reduction _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::l1_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _grad_input))); }|]

l1_loss_backward_ttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
l1_loss_backward_ttti _grad_output _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::l1_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

multi_margin_loss_ttsstiT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
multi_margin_loss_ttsstiT _self _target _p _margin _weight _reduction _output = [C.block| at::Tensor* { return new at::Tensor(at::native::multi_margin_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Scalar* _p), *$(at::Scalar* _margin), *$(at::Tensor* _weight), $(int _reduction), *$(at::Tensor* _output))); }|]

multi_margin_loss_ttssti :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> Int -> IO (Ptr Tensor)
multi_margin_loss_ttssti _self _target _p _margin _weight _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::multi_margin_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Scalar* _p), *$(at::Scalar* _margin), *$(at::Tensor* _weight), $(int _reduction))); }|]

multi_margin_loss_backward_tttsstiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
multi_margin_loss_backward_tttsstiT _grad_output _self _target _p _margin _weight _reduction _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::multi_margin_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Scalar* _p), *$(at::Scalar* _margin), *$(at::Tensor* _weight), $(int _reduction), *$(at::Tensor* _grad_input))); }|]

multi_margin_loss_backward_tttssti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> Int -> IO (Ptr Tensor)
multi_margin_loss_backward_tttssti _grad_output _self _target _p _margin _weight _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::multi_margin_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Scalar* _p), *$(at::Scalar* _margin), *$(at::Tensor* _weight), $(int _reduction))); }|]

multilabel_margin_loss_ttiT :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
multilabel_margin_loss_ttiT _self _target _reduction _output = [C.block| at::Tensor* { return new at::Tensor(at::native::multilabel_margin_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _output))); }|]

multilabel_margin_loss_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
multilabel_margin_loss_tti _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::multilabel_margin_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

multilabel_margin_loss_forward_ttiTT :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
multilabel_margin_loss_forward_ttiTT _self _target _reduction _output _is_target = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::multilabel_margin_loss_forward(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _output), *$(at::Tensor* _is_target))); }|]

multilabel_margin_loss_forward_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr (Tensor,Tensor))
multilabel_margin_loss_forward_tti _self _target _reduction = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::multilabel_margin_loss_forward(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

multilabel_margin_loss_backward_tttitT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
multilabel_margin_loss_backward_tttitT _grad_output _self _target _reduction _is_target _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::multilabel_margin_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _is_target), *$(at::Tensor* _grad_input))); }|]

multilabel_margin_loss_backward_tttit :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
multilabel_margin_loss_backward_tttit _grad_output _self _target _reduction _is_target = [C.block| at::Tensor* { return new at::Tensor(at::native::multilabel_margin_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _is_target))); }|]

nll_loss_tttiiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Ptr Tensor -> IO (Ptr Tensor)
nll_loss_tttiiT _self _target _weight _reduction _ignore_index _output = [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index), *$(at::Tensor* _output))); }|]

nll_loss_tttii :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
nll_loss_tttii _self _target _weight _reduction _ignore_index = [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index))); }|]

nll_loss_forward_tttiiTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
nll_loss_forward_tttiiTT _self _target _weight _reduction _ignore_index _output _total_weight = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::nll_loss_forward(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index), *$(at::Tensor* _output), *$(at::Tensor* _total_weight))); }|]

nll_loss_forward_tttii :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr (Tensor,Tensor))
nll_loss_forward_tttii _self _target _weight _reduction _ignore_index = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::nll_loss_forward(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index))); }|]

nll_loss_backward_ttttiitT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
nll_loss_backward_ttttiitT _grad_output _self _target _weight _reduction _ignore_index _total_weight _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index), *$(at::Tensor* _total_weight), *$(at::Tensor* _grad_input))); }|]

nll_loss_backward_ttttiit :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Ptr Tensor -> IO (Ptr Tensor)
nll_loss_backward_ttttiit _grad_output _self _target _weight _reduction _ignore_index _total_weight = [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index), *$(at::Tensor* _total_weight))); }|]

nll_loss2d_tttiiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Ptr Tensor -> IO (Ptr Tensor)
nll_loss2d_tttiiT _self _target _weight _reduction _ignore_index _output = [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss2d(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index), *$(at::Tensor* _output))); }|]

nll_loss2d_tttii :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr Tensor)
nll_loss2d_tttii _self _target _weight _reduction _ignore_index = [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss2d(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index))); }|]

nll_loss2d_forward_tttiiTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
nll_loss2d_forward_tttiiTT _self _target _weight _reduction _ignore_index _output _total_weight = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::nll_loss2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index), *$(at::Tensor* _output), *$(at::Tensor* _total_weight))); }|]

nll_loss2d_forward_tttii :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> IO (Ptr (Tensor,Tensor))
nll_loss2d_forward_tttii _self _target _weight _reduction _ignore_index = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::nll_loss2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index))); }|]

nll_loss2d_backward_ttttiitT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
nll_loss2d_backward_ttttiitT _grad_output _self _target _weight _reduction _ignore_index _total_weight _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index), *$(at::Tensor* _total_weight), *$(at::Tensor* _grad_input))); }|]

nll_loss2d_backward_ttttiit :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Int -> Ptr Tensor -> IO (Ptr Tensor)
nll_loss2d_backward_ttttiit _grad_output _self _target _weight _reduction _ignore_index _total_weight = [C.block| at::Tensor* { return new at::Tensor(at::native::nll_loss2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), *$(at::Tensor* _weight), $(int _reduction), $(int _ignore_index), *$(at::Tensor* _total_weight))); }|]

smooth_l1_loss_ttiT :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
smooth_l1_loss_ttiT _self _target _reduction _output = [C.block| at::Tensor* { return new at::Tensor(at::native::smooth_l1_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _output))); }|]

smooth_l1_loss_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
smooth_l1_loss_tti _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::smooth_l1_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

smooth_l1_loss_backward_tttiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
smooth_l1_loss_backward_tttiT _grad_output _self _target _reduction _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::smooth_l1_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _grad_input))); }|]

smooth_l1_loss_backward_ttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
smooth_l1_loss_backward_ttti _grad_output _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::smooth_l1_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

soft_margin_loss_ttiT :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
soft_margin_loss_ttiT _self _target _reduction _output = [C.block| at::Tensor* { return new at::Tensor(at::native::soft_margin_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _output))); }|]

soft_margin_loss_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
soft_margin_loss_tti _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::soft_margin_loss(*$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

soft_margin_loss_backward_tttiT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
soft_margin_loss_backward_tttiT _grad_output _self _target _reduction _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::soft_margin_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction), *$(at::Tensor* _grad_input))); }|]

soft_margin_loss_backward_ttti :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
soft_margin_loss_backward_ttti _grad_output _self _target _reduction = [C.block| at::Tensor* { return new at::Tensor(at::native::soft_margin_loss_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _target), $(int _reduction))); }|]

elu_tsssT :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
elu_tsssT _self _alpha _scale _input_scale _output = [C.block| at::Tensor* { return new at::Tensor(at::native::elu(*$(at::Tensor* _self), *$(at::Scalar* _alpha), *$(at::Scalar* _scale), *$(at::Scalar* _input_scale), *$(at::Tensor* _output))); }|]

elu_tsss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
elu_tsss _self _alpha _scale _input_scale = [C.block| at::Tensor* { return new at::Tensor(at::native::elu(*$(at::Tensor* _self), *$(at::Scalar* _alpha), *$(at::Scalar* _scale), *$(at::Scalar* _input_scale))); }|]

elu_backward_tssstT :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
elu_backward_tssstT _grad_output _alpha _scale _input_scale _output _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::elu_backward(*$(at::Tensor* _grad_output), *$(at::Scalar* _alpha), *$(at::Scalar* _scale), *$(at::Scalar* _input_scale), *$(at::Tensor* _output), *$(at::Tensor* _grad_input))); }|]

elu_backward_tssst :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
elu_backward_tssst _grad_output _alpha _scale _input_scale _output = [C.block| at::Tensor* { return new at::Tensor(at::native::elu_backward(*$(at::Tensor* _grad_output), *$(at::Scalar* _alpha), *$(at::Scalar* _scale), *$(at::Scalar* _input_scale), *$(at::Tensor* _output))); }|]

elu__Tsss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
elu__Tsss _self _alpha _scale _input_scale = [C.block| at::Tensor* { return new at::Tensor(at::native::elu_(*$(at::Tensor* _self), *$(at::Scalar* _alpha), *$(at::Scalar* _scale), *$(at::Scalar* _input_scale))); }|]

glu_tiT :: Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
glu_tiT _self _dim _output = [C.block| at::Tensor* { return new at::Tensor(at::native::glu(*$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _output))); }|]

glu_ti :: Ptr Tensor -> Int -> IO (Ptr Tensor)
glu_ti _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::glu(*$(at::Tensor* _self), $(int _dim))); }|]

glu_backward_ttiT :: Ptr Tensor -> Ptr Tensor -> Int -> Ptr Tensor -> IO (Ptr Tensor)
glu_backward_ttiT _grad_output _self _dim _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::glu_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), $(int _dim), *$(at::Tensor* _grad_input))); }|]

glu_backward_tti :: Ptr Tensor -> Ptr Tensor -> Int -> IO (Ptr Tensor)
glu_backward_tti _grad_output _self _dim = [C.block| at::Tensor* { return new at::Tensor(at::native::glu_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), $(int _dim))); }|]

hardtanh_tssT :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
hardtanh_tssT _self _min_val _max_val _output = [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh(*$(at::Tensor* _self), *$(at::Scalar* _min_val), *$(at::Scalar* _max_val), *$(at::Tensor* _output))); }|]

hardtanh_tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
hardtanh_tss _self _min_val _max_val = [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh(*$(at::Tensor* _self), *$(at::Scalar* _min_val), *$(at::Scalar* _max_val))); }|]

hardtanh_backward_ttssT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
hardtanh_backward_ttssT _grad_output _self _min_val _max_val _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _min_val), *$(at::Scalar* _max_val), *$(at::Tensor* _grad_input))); }|]

hardtanh_backward_ttss :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
hardtanh_backward_ttss _grad_output _self _min_val _max_val = [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _min_val), *$(at::Scalar* _max_val))); }|]

hardtanh__Tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
hardtanh__Tss _self _min_val _max_val = [C.block| at::Tensor* { return new at::Tensor(at::native::hardtanh_(*$(at::Tensor* _self), *$(at::Scalar* _min_val), *$(at::Scalar* _max_val))); }|]

leaky_relu_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
leaky_relu_tsT _self _negative_slope _output = [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu(*$(at::Tensor* _self), *$(at::Scalar* _negative_slope), *$(at::Tensor* _output))); }|]

leaky_relu_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
leaky_relu_ts _self _negative_slope = [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu(*$(at::Tensor* _self), *$(at::Scalar* _negative_slope))); }|]

leaky_relu_backward_ttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
leaky_relu_backward_ttsT _grad_output _self _negative_slope _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _negative_slope), *$(at::Tensor* _grad_input))); }|]

leaky_relu_backward_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
leaky_relu_backward_tts _grad_output _self _negative_slope = [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _negative_slope))); }|]

leaky_relu__Ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
leaky_relu__Ts _self _negative_slope = [C.block| at::Tensor* { return new at::Tensor(at::native::leaky_relu_(*$(at::Tensor* _self), *$(at::Scalar* _negative_slope))); }|]

log_sigmoid_tT :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
log_sigmoid_tT _self _output = [C.block| at::Tensor* { return new at::Tensor(at::native::log_sigmoid(*$(at::Tensor* _self), *$(at::Tensor* _output))); }|]

log_sigmoid_t :: Ptr Tensor -> IO (Ptr Tensor)
log_sigmoid_t _self = [C.block| at::Tensor* { return new at::Tensor(at::native::log_sigmoid(*$(at::Tensor* _self))); }|]

log_sigmoid_forward_tTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
log_sigmoid_forward_tTT _self _output _buffer = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::log_sigmoid_forward(*$(at::Tensor* _self), *$(at::Tensor* _output), *$(at::Tensor* _buffer))); }|]

log_sigmoid_forward_t :: Ptr Tensor -> IO (Ptr (Tensor,Tensor))
log_sigmoid_forward_t _self = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::log_sigmoid_forward(*$(at::Tensor* _self))); }|]

log_sigmoid_backward_tttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
log_sigmoid_backward_tttT _grad_output _self _buffer _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::log_sigmoid_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _buffer), *$(at::Tensor* _grad_input))); }|]

log_sigmoid_backward_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
log_sigmoid_backward_ttt _grad_output _self _buffer = [C.block| at::Tensor* { return new at::Tensor(at::native::log_sigmoid_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _buffer))); }|]

rrelu_with_noise_ttssbpT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> CBool -> Ptr Generator -> Ptr Tensor -> IO (Ptr Tensor)
rrelu_with_noise_ttssbpT _self _noise _lower _upper _training _generator _output = [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise(*$(at::Tensor* _self), *$(at::Tensor* _noise), *$(at::Scalar* _lower), *$(at::Scalar* _upper), $(bool _training), $(at::Generator * _generator), *$(at::Tensor* _output))); }|]

rrelu_with_noise_ttssbp :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> CBool -> Ptr Generator -> IO (Ptr Tensor)
rrelu_with_noise_ttssbp _self _noise _lower _upper _training _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise(*$(at::Tensor* _self), *$(at::Tensor* _noise), *$(at::Scalar* _lower), *$(at::Scalar* _upper), $(bool _training), $(at::Generator * _generator))); }|]

rrelu_with_noise_backward_tttssbT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
rrelu_with_noise_backward_tttssbT _grad_output _self _noise _lower _upper _training _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _noise), *$(at::Scalar* _lower), *$(at::Scalar* _upper), $(bool _training), *$(at::Tensor* _grad_input))); }|]

rrelu_with_noise_backward_tttssb :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> CBool -> IO (Ptr Tensor)
rrelu_with_noise_backward_tttssb _grad_output _self _noise _lower _upper _training = [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _noise), *$(at::Scalar* _lower), *$(at::Scalar* _upper), $(bool _training))); }|]

rrelu_with_noise__Ttssbp :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> CBool -> Ptr Generator -> IO (Ptr Tensor)
rrelu_with_noise__Ttssbp _self _noise _lower _upper _training _generator = [C.block| at::Tensor* { return new at::Tensor(at::native::rrelu_with_noise_(*$(at::Tensor* _self), *$(at::Tensor* _noise), *$(at::Scalar* _lower), *$(at::Scalar* _upper), $(bool _training), $(at::Generator * _generator))); }|]

softplus_tssT :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
softplus_tssT _self _beta _threshold _output = [C.block| at::Tensor* { return new at::Tensor(at::native::softplus(*$(at::Tensor* _self), *$(at::Scalar* _beta), *$(at::Scalar* _threshold), *$(at::Tensor* _output))); }|]

softplus_tss :: Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> IO (Ptr Tensor)
softplus_tss _self _beta _threshold = [C.block| at::Tensor* { return new at::Tensor(at::native::softplus(*$(at::Tensor* _self), *$(at::Scalar* _beta), *$(at::Scalar* _threshold))); }|]

softplus_backward_ttsstT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
softplus_backward_ttsstT _grad_output _self _beta _threshold _output _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::softplus_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _beta), *$(at::Scalar* _threshold), *$(at::Tensor* _output), *$(at::Tensor* _grad_input))); }|]

softplus_backward_ttsst :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
softplus_backward_ttsst _grad_output _self _beta _threshold _output = [C.block| at::Tensor* { return new at::Tensor(at::native::softplus_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _beta), *$(at::Scalar* _threshold), *$(at::Tensor* _output))); }|]

softshrink_tsT :: Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
softshrink_tsT _self _lambd _output = [C.block| at::Tensor* { return new at::Tensor(at::native::softshrink(*$(at::Tensor* _self), *$(at::Scalar* _lambd), *$(at::Tensor* _output))); }|]

softshrink_ts :: Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
softshrink_ts _self _lambd = [C.block| at::Tensor* { return new at::Tensor(at::native::softshrink(*$(at::Tensor* _self), *$(at::Scalar* _lambd))); }|]

softshrink_backward_ttsT :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> Ptr Tensor -> IO (Ptr Tensor)
softshrink_backward_ttsT _grad_output _self _lambd _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::softshrink_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _lambd), *$(at::Tensor* _grad_input))); }|]

softshrink_backward_tts :: Ptr Tensor -> Ptr Tensor -> Ptr Scalar -> IO (Ptr Tensor)
softshrink_backward_tts _grad_output _self _lambd = [C.block| at::Tensor* { return new at::Tensor(at::native::softshrink_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Scalar* _lambd))); }|]

adaptive_avg_pool2d_out_cpu_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_avg_pool2d_out_cpu_tlT _self _output_size _output = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_out_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output))); }|]

adaptive_avg_pool2d_out_cuda_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_avg_pool2d_out_cuda_tlT _self _output_size _output = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_out_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output))); }|]

adaptive_avg_pool2d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
adaptive_avg_pool2d_tl _self _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

adaptive_avg_pool2d_cpu_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
adaptive_avg_pool2d_cpu_tl _self _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

adaptive_avg_pool2d_cuda_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
adaptive_avg_pool2d_cuda_tl _self _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

adaptive_avg_pool2d_backward_cpu_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_avg_pool2d_backward_cpu_tt _grad_output _self = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self))); }|]

adaptive_avg_pool2d_backward_cuda_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_avg_pool2d_backward_cuda_tt _grad_output _self = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool2d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self))); }|]

adaptive_avg_pool3d_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_avg_pool3d_tlT _self _output_size _output = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output))); }|]

adaptive_avg_pool3d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
adaptive_avg_pool3d_tl _self _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

adaptive_avg_pool3d_backward_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_ttT _grad_output _self _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _grad_input))); }|]

adaptive_avg_pool3d_backward_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_tt _grad_output _self = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_avg_pool3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self))); }|]

adaptive_max_pool2d_tlTT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool2d_tlTT _self _output_size _output _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output), *$(at::Tensor* _indices))); }|]

adaptive_max_pool2d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool2d_tl _self _output_size = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

adaptive_max_pool2d_backward_tttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_tttT _grad_output _self _indices _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_max_pool2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::Tensor* _grad_input))); }|]

adaptive_max_pool2d_backward_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_ttt _grad_output _self _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_max_pool2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _indices))); }|]

adaptive_max_pool3d_tlTT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool3d_tlTT _self _output_size _output _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output), *$(at::Tensor* _indices))); }|]

adaptive_max_pool3d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr (Tensor,Tensor))
adaptive_max_pool3d_tl _self _output_size = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::adaptive_max_pool3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

adaptive_max_pool3d_backward_tttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_max_pool3d_backward_tttT _grad_output _self _indices _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_max_pool3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::Tensor* _grad_input))); }|]

adaptive_max_pool3d_backward_ttt :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
adaptive_max_pool3d_backward_ttt _grad_output _self _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::adaptive_max_pool3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _indices))); }|]

avg_pool2d_tlllbbT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
avg_pool2d_tlllbbT _self _kernel_size _stride _padding _ceil_mode _count_include_pad _output = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad), *$(at::Tensor* _output))); }|]

avg_pool2d_tlllbb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> IO (Ptr Tensor)
avg_pool2d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad))); }|]

avg_pool2d_backward_ttlllbbT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
avg_pool2d_backward_ttlllbbT _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad), *$(at::Tensor* _grad_input))); }|]

avg_pool2d_backward_ttlllbb :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> IO (Ptr Tensor)
avg_pool2d_backward_ttlllbb _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad))); }|]

avg_pool3d_tlllbbT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
avg_pool3d_tlllbbT _self _kernel_size _stride _padding _ceil_mode _count_include_pad _output = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad), *$(at::Tensor* _output))); }|]

avg_pool3d_tlllbb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> IO (Ptr Tensor)
avg_pool3d_tlllbb _self _kernel_size _stride _padding _ceil_mode _count_include_pad = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad))); }|]

avg_pool3d_backward_ttlllbbT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
avg_pool3d_backward_ttlllbbT _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad), *$(at::Tensor* _grad_input))); }|]

avg_pool3d_backward_ttlllbb :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> CBool -> IO (Ptr Tensor)
avg_pool3d_backward_ttlllbb _grad_output _self _kernel_size _stride _padding _ceil_mode _count_include_pad = [C.block| at::Tensor* { return new at::Tensor(at::native::avg_pool3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), $(bool _ceil_mode), $(bool _count_include_pad))); }|]

fractional_max_pool2d_out_cpu_tlltTT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
fractional_max_pool2d_out_cpu_tlltTT _self _kernel_size _output_size _random_samples _output _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool2d_out_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _random_samples), *$(at::Tensor* _output), *$(at::Tensor* _indices))); }|]

fractional_max_pool2d_out_cuda_tlltTT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
fractional_max_pool2d_out_cuda_tlltTT _self _kernel_size _output_size _random_samples _output _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool2d_out_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _random_samples), *$(at::Tensor* _output), *$(at::Tensor* _indices))); }|]

fractional_max_pool2d_cpu_tllt :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
fractional_max_pool2d_cpu_tllt _self _kernel_size _output_size _random_samples = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool2d_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _random_samples))); }|]

fractional_max_pool2d_cuda_tllt :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
fractional_max_pool2d_cuda_tllt _self _kernel_size _output_size _random_samples = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool2d_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _random_samples))); }|]

fractional_max_pool2d_backward_out_cpu_ttlltT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
fractional_max_pool2d_backward_out_cpu_ttlltT _grad_output _self _kernel_size _output_size _indices _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool2d_backward_out_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _indices), *$(at::Tensor* _grad_input))); }|]

fractional_max_pool2d_backward_out_cuda_ttlltT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
fractional_max_pool2d_backward_out_cuda_ttlltT _grad_output _self _kernel_size _output_size _indices _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool2d_backward_out_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _indices), *$(at::Tensor* _grad_input))); }|]

fractional_max_pool2d_backward_cpu_ttllt :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
fractional_max_pool2d_backward_cpu_ttllt _grad_output _self _kernel_size _output_size _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool2d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _indices))); }|]

fractional_max_pool2d_backward_cuda_ttllt :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
fractional_max_pool2d_backward_cuda_ttllt _grad_output _self _kernel_size _output_size _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool2d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _indices))); }|]

fractional_max_pool3d_out_cpu_tlltTT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
fractional_max_pool3d_out_cpu_tlltTT _self _kernel_size _output_size _random_samples _output _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool3d_out_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _random_samples), *$(at::Tensor* _output), *$(at::Tensor* _indices))); }|]

fractional_max_pool3d_out_cuda_tlltTT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
fractional_max_pool3d_out_cuda_tlltTT _self _kernel_size _output_size _random_samples _output _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool3d_out_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _random_samples), *$(at::Tensor* _output), *$(at::Tensor* _indices))); }|]

fractional_max_pool3d_cpu_tllt :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
fractional_max_pool3d_cpu_tllt _self _kernel_size _output_size _random_samples = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool3d_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _random_samples))); }|]

fractional_max_pool3d_cuda_tllt :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
fractional_max_pool3d_cuda_tllt _self _kernel_size _output_size _random_samples = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::fractional_max_pool3d_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _random_samples))); }|]

fractional_max_pool3d_backward_out_cpu_ttlltT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
fractional_max_pool3d_backward_out_cpu_ttlltT _grad_output _self _kernel_size _output_size _indices _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool3d_backward_out_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _indices), *$(at::Tensor* _grad_input))); }|]

fractional_max_pool3d_backward_out_cuda_ttlltT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
fractional_max_pool3d_backward_out_cuda_ttlltT _grad_output _self _kernel_size _output_size _indices _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool3d_backward_out_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _indices), *$(at::Tensor* _grad_input))); }|]

fractional_max_pool3d_backward_cpu_ttllt :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
fractional_max_pool3d_backward_cpu_ttllt _grad_output _self _kernel_size _output_size _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool3d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _indices))); }|]

fractional_max_pool3d_backward_cuda_ttllt :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
fractional_max_pool3d_backward_cuda_ttllt _grad_output _self _kernel_size _output_size _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::fractional_max_pool3d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _indices))); }|]

max_pool2d_with_indices_tllllbTT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
max_pool2d_with_indices_tllllbTT _self _kernel_size _stride _padding _dilation _ceil_mode _output _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool2d_with_indices(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode), *$(at::Tensor* _output), *$(at::Tensor* _indices))); }|]

max_pool2d_with_indices_tllllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr (Tensor,Tensor))
max_pool2d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool2d_with_indices(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode))); }|]

max_pool2d_with_indices_backward_ttllllbtT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
max_pool2d_with_indices_backward_ttllllbtT _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool2d_with_indices_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode), *$(at::Tensor* _indices), *$(at::Tensor* _grad_input))); }|]

max_pool2d_with_indices_backward_ttllllbt :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
max_pool2d_with_indices_backward_ttllllbt _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool2d_with_indices_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode), *$(at::Tensor* _indices))); }|]

max_pool3d_with_indices_tllllbTT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
max_pool3d_with_indices_tllllbTT _self _kernel_size _stride _padding _dilation _ceil_mode _output _indices = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool3d_with_indices(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode), *$(at::Tensor* _output), *$(at::Tensor* _indices))); }|]

max_pool3d_with_indices_tllllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr (Tensor,Tensor))
max_pool3d_with_indices_tllllb _self _kernel_size _stride _padding _dilation _ceil_mode = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::max_pool3d_with_indices(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode))); }|]

max_pool3d_with_indices_backward_ttllllbtT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
max_pool3d_with_indices_backward_ttllllbtT _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool3d_with_indices_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode), *$(at::Tensor* _indices), *$(at::Tensor* _grad_input))); }|]

max_pool3d_with_indices_backward_ttllllbt :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
max_pool3d_with_indices_backward_ttllllbt _grad_output _self _kernel_size _stride _padding _dilation _ceil_mode _indices = [C.block| at::Tensor* { return new at::Tensor(at::native::max_pool3d_with_indices_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), $(bool _ceil_mode), *$(at::Tensor* _indices))); }|]

max_unpool2d_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
max_unpool2d_ttlT _self _indices _output_size _output = [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool2d(*$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output))); }|]

max_unpool2d_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
max_unpool2d_ttl _self _indices _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool2d(*$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::IntArrayRef* _output_size))); }|]

max_unpool2d_backward_tttlT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
max_unpool2d_backward_tttlT _grad_output _self _indices _output_size _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _grad_input))); }|]

max_unpool2d_backward_tttl :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
max_unpool2d_backward_tttl _grad_output _self _indices _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::IntArrayRef* _output_size))); }|]

max_unpool3d_ttlllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
max_unpool3d_ttlllT _self _indices _output_size _stride _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool3d(*$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

max_unpool3d_ttlll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
max_unpool3d_ttlll _self _indices _output_size _stride _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool3d(*$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding))); }|]

max_unpool3d_backward_tttlllT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
max_unpool3d_backward_tttlllT _grad_output _self _indices _output_size _stride _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

max_unpool3d_backward_tttlll :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
max_unpool3d_backward_tttlll _grad_output _self _indices _output_size _stride _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::max_unpool3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _indices), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding))); }|]

reflection_pad1d_out_cpu_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
reflection_pad1d_out_cpu_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_out_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

reflection_pad1d_out_cuda_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
reflection_pad1d_out_cuda_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_out_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

reflection_pad1d_cpu_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reflection_pad1d_cpu_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

reflection_pad1d_cuda_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reflection_pad1d_cuda_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

reflection_pad1d_backward_out_cpu_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
reflection_pad1d_backward_out_cpu_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_backward_out_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

reflection_pad1d_backward_out_cuda_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
reflection_pad1d_backward_out_cuda_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_backward_out_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

reflection_pad1d_backward_cpu_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reflection_pad1d_backward_cpu_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

reflection_pad1d_backward_cuda_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reflection_pad1d_backward_cuda_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad1d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

reflection_pad2d_out_cpu_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
reflection_pad2d_out_cpu_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_out_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

reflection_pad2d_out_cuda_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
reflection_pad2d_out_cuda_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_out_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

reflection_pad2d_cpu_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reflection_pad2d_cpu_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

reflection_pad2d_cuda_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reflection_pad2d_cuda_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

reflection_pad2d_backward_out_cpu_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
reflection_pad2d_backward_out_cpu_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_backward_out_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

reflection_pad2d_backward_out_cuda_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
reflection_pad2d_backward_out_cuda_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_backward_out_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

reflection_pad2d_backward_cpu_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reflection_pad2d_backward_cpu_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

reflection_pad2d_backward_cuda_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
reflection_pad2d_backward_cuda_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::reflection_pad2d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad1d_out_cpu_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad1d_out_cpu_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_out_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

replication_pad1d_out_cuda_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad1d_out_cuda_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_out_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

replication_pad1d_cpu_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad1d_cpu_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad1d_cuda_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad1d_cuda_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad1d_backward_out_cpu_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad1d_backward_out_cpu_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_backward_out_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

replication_pad1d_backward_out_cuda_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad1d_backward_out_cuda_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_backward_out_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

replication_pad1d_backward_cpu_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad1d_backward_cpu_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad1d_backward_cuda_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad1d_backward_cuda_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad1d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad2d_out_cpu_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad2d_out_cpu_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_out_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

replication_pad2d_out_cuda_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad2d_out_cuda_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_out_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

replication_pad2d_cpu_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad2d_cpu_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad2d_cuda_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad2d_cuda_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad2d_backward_out_cpu_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad2d_backward_out_cpu_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_backward_out_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

replication_pad2d_backward_out_cuda_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad2d_backward_out_cuda_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_backward_out_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

replication_pad2d_backward_cpu_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad2d_backward_cpu_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad2d_backward_cuda_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad2d_backward_cuda_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad2d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad3d_out_cpu_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad3d_out_cpu_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_out_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

replication_pad3d_out_cuda_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad3d_out_cuda_tlT _self _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_out_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

replication_pad3d_cpu_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad3d_cpu_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_cpu(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad3d_cuda_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad3d_cuda_tl _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_cuda(*$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad3d_backward_out_cpu_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad3d_backward_out_cpu_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_backward_out_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

replication_pad3d_backward_out_cuda_ttlT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
replication_pad3d_backward_out_cuda_ttlT _grad_output _self _padding _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_backward_out_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding), *$(at::Tensor* _grad_input))); }|]

replication_pad3d_backward_cpu_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad3d_backward_cpu_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_backward_cpu(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

replication_pad3d_backward_cuda_ttl :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
replication_pad3d_backward_cuda_ttl _grad_output _self _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::replication_pad3d_backward_cuda(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::IntArrayRef* _padding))); }|]

upsample_linear1d_tlbT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
upsample_linear1d_tlbT _self _output_size _align_corners _output = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_linear1d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), $(bool _align_corners), *$(at::Tensor* _output))); }|]

upsample_linear1d_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
upsample_linear1d_tlb _self _output_size _align_corners = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_linear1d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), $(bool _align_corners))); }|]

upsample_linear1d_backward_tllbT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
upsample_linear1d_backward_tllbT _grad_output _output_size _input_size _align_corners _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_linear1d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), $(bool _align_corners), *$(at::Tensor* _grad_input))); }|]

upsample_linear1d_backward_tllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr Tensor)
upsample_linear1d_backward_tllb _grad_output _output_size _input_size _align_corners = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_linear1d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), $(bool _align_corners))); }|]

upsample_bilinear2d_tlbT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
upsample_bilinear2d_tlbT _self _output_size _align_corners _output = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bilinear2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), $(bool _align_corners), *$(at::Tensor* _output))); }|]

upsample_bilinear2d_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
upsample_bilinear2d_tlb _self _output_size _align_corners = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bilinear2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), $(bool _align_corners))); }|]

upsample_bilinear2d_backward_tllbT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
upsample_bilinear2d_backward_tllbT _grad_output _output_size _input_size _align_corners _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bilinear2d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), $(bool _align_corners), *$(at::Tensor* _grad_input))); }|]

upsample_bilinear2d_backward_tllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr Tensor)
upsample_bilinear2d_backward_tllb _grad_output _output_size _input_size _align_corners = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bilinear2d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), $(bool _align_corners))); }|]

upsample_bicubic2d_tlbT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
upsample_bicubic2d_tlbT _self _output_size _align_corners _output = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bicubic2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), $(bool _align_corners), *$(at::Tensor* _output))); }|]

upsample_bicubic2d_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
upsample_bicubic2d_tlb _self _output_size _align_corners = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bicubic2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), $(bool _align_corners))); }|]

upsample_bicubic2d_backward_tllbT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
upsample_bicubic2d_backward_tllbT _grad_output _output_size _input_size _align_corners _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bicubic2d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), $(bool _align_corners), *$(at::Tensor* _grad_input))); }|]

upsample_bicubic2d_backward_tllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr Tensor)
upsample_bicubic2d_backward_tllb _grad_output _output_size _input_size _align_corners = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_bicubic2d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), $(bool _align_corners))); }|]

upsample_trilinear3d_tlbT :: Ptr Tensor -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
upsample_trilinear3d_tlbT _self _output_size _align_corners _output = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_trilinear3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), $(bool _align_corners), *$(at::Tensor* _output))); }|]

upsample_trilinear3d_tlb :: Ptr Tensor -> Ptr IntList -> CBool -> IO (Ptr Tensor)
upsample_trilinear3d_tlb _self _output_size _align_corners = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_trilinear3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), $(bool _align_corners))); }|]

upsample_trilinear3d_backward_tllbT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> Ptr Tensor -> IO (Ptr Tensor)
upsample_trilinear3d_backward_tllbT _grad_output _output_size _input_size _align_corners _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_trilinear3d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), $(bool _align_corners), *$(at::Tensor* _grad_input))); }|]

upsample_trilinear3d_backward_tllb :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> CBool -> IO (Ptr Tensor)
upsample_trilinear3d_backward_tllb _grad_output _output_size _input_size _align_corners = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_trilinear3d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), $(bool _align_corners))); }|]

upsample_nearest1d_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
upsample_nearest1d_tlT _self _output_size _output = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest1d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output))); }|]

upsample_nearest1d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
upsample_nearest1d_tl _self _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest1d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

upsample_nearest1d_backward_tllT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
upsample_nearest1d_backward_tllT _grad_output _output_size _input_size _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest1d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), *$(at::Tensor* _grad_input))); }|]

upsample_nearest1d_backward_tll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
upsample_nearest1d_backward_tll _grad_output _output_size _input_size = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest1d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size))); }|]

upsample_nearest2d_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
upsample_nearest2d_tlT _self _output_size _output = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output))); }|]

upsample_nearest2d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
upsample_nearest2d_tl _self _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest2d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

upsample_nearest2d_backward_tllT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
upsample_nearest2d_backward_tllT _grad_output _output_size _input_size _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest2d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), *$(at::Tensor* _grad_input))); }|]

upsample_nearest2d_backward_tll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
upsample_nearest2d_backward_tll _grad_output _output_size _input_size = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest2d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size))); }|]

upsample_nearest3d_tlT :: Ptr Tensor -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
upsample_nearest3d_tlT _self _output_size _output = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::Tensor* _output))); }|]

upsample_nearest3d_tl :: Ptr Tensor -> Ptr IntList -> IO (Ptr Tensor)
upsample_nearest3d_tl _self _output_size = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest3d(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size))); }|]

upsample_nearest3d_backward_tllT :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
upsample_nearest3d_backward_tllT _grad_output _output_size _input_size _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest3d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size), *$(at::Tensor* _grad_input))); }|]

upsample_nearest3d_backward_tll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
upsample_nearest3d_backward_tll _grad_output _output_size _input_size = [C.block| at::Tensor* { return new at::Tensor(at::native::upsample_nearest3d_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _input_size))); }|]

sigmoid_backward_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
sigmoid_backward_ttT _grad_output _output _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::sigmoid_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _output), *$(at::Tensor* _grad_input))); }|]

sigmoid_backward_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
sigmoid_backward_tt _grad_output _output = [C.block| at::Tensor* { return new at::Tensor(at::native::sigmoid_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _output))); }|]

tanh_backward_ttT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
tanh_backward_ttT _grad_output _output _grad_input = [C.block| at::Tensor* { return new at::Tensor(at::native::tanh_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _output), *$(at::Tensor* _grad_input))); }|]

tanh_backward_tt :: Ptr Tensor -> Ptr Tensor -> IO (Ptr Tensor)
tanh_backward_tt _grad_output _output = [C.block| at::Tensor* { return new at::Tensor(at::native::tanh_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _output))); }|]

thnn_conv_transpose2d_ttltllllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
thnn_conv_transpose2d_ttltllllT _self _weight _kernel_size _bias _stride _padding _output_padding _dilation _output = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_transpose2d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output))); }|]

thnn_conv_transpose2d_ttltllll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_conv_transpose2d_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_transpose2d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_transpose2d_forward_ttltllllTTT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_forward_ttltllllTTT _self _weight _kernel_size _bias _stride _padding _output_padding _dilation _output _columns _ones = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output), *$(at::Tensor* _columns), *$(at::Tensor* _ones))); }|]

thnn_conv_transpose2d_forward_ttltllll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_forward_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_transpose2d_backward_tttlllllttTTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_backward_tttlllllttTTT _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _columns _ones _grad_input _grad_weight _grad_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _columns), *$(at::Tensor* _ones), *$(at::Tensor* _grad_input), *$(at::Tensor* _grad_weight), *$(at::Tensor* _grad_bias))); }|]

thnn_conv_transpose2d_backward_tttllllltta :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose2d_backward_tttllllltta _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _columns _ones _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _columns), *$(at::Tensor* _ones), *$(std::array<bool,3>* _output_mask))); }|]

thnn_conv_transpose3d_ttltllllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
thnn_conv_transpose3d_ttltllllT _self _weight _kernel_size _bias _stride _padding _output_padding _dilation _output = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_transpose3d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output))); }|]

thnn_conv_transpose3d_ttltllll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_conv_transpose3d_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_transpose3d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_transpose3d_forward_ttltllllTTT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_forward_ttltllllTTT _self _weight _kernel_size _bias _stride _padding _output_padding _dilation _output _finput _fgrad_input = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose3d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input))); }|]

thnn_conv_transpose3d_forward_ttltllll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_forward_ttltllll _self _weight _kernel_size _bias _stride _padding _output_padding _dilation = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose3d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_transpose3d_backward_tttlllllttTTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_backward_tttlllllttTTT _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _finput _fgrad_input _grad_input _grad_weight _grad_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input), *$(at::Tensor* _grad_input), *$(at::Tensor* _grad_weight), *$(at::Tensor* _grad_bias))); }|]

thnn_conv_transpose3d_backward_tttllllltta :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_transpose3d_backward_tttllllltta _grad_output _self _weight _kernel_size _stride _padding _output_padding _dilation _finput _fgrad_input _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_transpose3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _output_padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input), *$(std::array<bool,3>* _output_mask))); }|]

thnn_conv2d_ttltllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
thnn_conv2d_ttltllT _self _weight _kernel_size _bias _stride _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv2d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

thnn_conv2d_ttltll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_conv2d_ttltll _self _weight _kernel_size _bias _stride _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv2d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding))); }|]

thnn_conv2d_forward_ttltllTTT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_forward_ttltllTTT _self _weight _kernel_size _bias _stride _padding _output _finput _fgrad_input = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input))); }|]

thnn_conv2d_forward_ttltll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_forward_ttltll _self _weight _kernel_size _bias _stride _padding = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding))); }|]

thnn_conv2d_backward_tttlllttTTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_backward_tttlllttTTT _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _grad_input _grad_weight _grad_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input), *$(at::Tensor* _grad_input), *$(at::Tensor* _grad_weight), *$(at::Tensor* _grad_bias))); }|]

thnn_conv2d_backward_tttllltta :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv2d_backward_tttllltta _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input), *$(std::array<bool,3>* _output_mask))); }|]

thnn_conv_depthwise2d_ttltlllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttltlllT _self _weight _kernel_size _bias _stride _padding _dilation _output = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_depthwise2d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output))); }|]

thnn_conv_depthwise2d_ttltlll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_conv_depthwise2d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_depthwise2d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_depthwise2d_forward_ttltlllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
thnn_conv_depthwise2d_forward_ttltlllT _self _weight _kernel_size _bias _stride _padding _dilation _output = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_depthwise2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output))); }|]

thnn_conv_depthwise2d_forward_ttltlll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_conv_depthwise2d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_depthwise2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_depthwise2d_backward_tttllllTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor))
thnn_conv_depthwise2d_backward_tttllllTT _grad_output _self _weight _kernel_size _stride _padding _dilation _grad_input _grad_weight = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::thnn_conv_depthwise2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _grad_input), *$(at::Tensor* _grad_weight))); }|]

thnn_conv_depthwise2d_backward_tttlllla :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr (StdArray CBool 2) -> IO (Ptr (Tensor,Tensor))
thnn_conv_depthwise2d_backward_tttlllla _grad_output _self _weight _kernel_size _stride _padding _dilation _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::native::thnn_conv_depthwise2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(std::array<bool,2>* _output_mask))); }|]

thnn_conv3d_ttltllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
thnn_conv3d_ttltllT _self _weight _kernel_size _bias _stride _padding _output = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv3d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output))); }|]

thnn_conv3d_ttltll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_conv3d_ttltll _self _weight _kernel_size _bias _stride _padding = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv3d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding))); }|]

thnn_conv3d_forward_ttltllTTT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_forward_ttltllTTT _self _weight _kernel_size _bias _stride _padding _output _finput _fgrad_input = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv3d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _output), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input))); }|]

thnn_conv3d_forward_ttltll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_forward_ttltll _self _weight _kernel_size _bias _stride _padding = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv3d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding))); }|]

thnn_conv3d_backward_tttlllttTTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_backward_tttlllttTTT _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _grad_input _grad_weight _grad_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input), *$(at::Tensor* _grad_input), *$(at::Tensor* _grad_weight), *$(at::Tensor* _grad_bias))); }|]

thnn_conv3d_backward_tttllltta :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv3d_backward_tttllltta _grad_output _self _weight _kernel_size _stride _padding _finput _fgrad_input _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::Tensor* _finput), *$(at::Tensor* _fgrad_input), *$(std::array<bool,3>* _output_mask))); }|]

thnn_conv_dilated2d_ttltlllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
thnn_conv_dilated2d_ttltlllT _self _weight _kernel_size _bias _stride _padding _dilation _output = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_dilated2d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output))); }|]

thnn_conv_dilated2d_ttltlll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_conv_dilated2d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_dilated2d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_dilated2d_forward_ttltlllTTT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_forward_ttltlllTTT _self _weight _kernel_size _bias _stride _padding _dilation _output _columns _ones = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output), *$(at::Tensor* _columns), *$(at::Tensor* _ones))); }|]

thnn_conv_dilated2d_forward_ttltlll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated2d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_dilated2d_backward_tttllllttTTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_backward_tttllllttTTT _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _grad_input _grad_weight _grad_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _columns), *$(at::Tensor* _ones), *$(at::Tensor* _grad_input), *$(at::Tensor* _grad_weight), *$(at::Tensor* _grad_bias))); }|]

thnn_conv_dilated2d_backward_tttlllltta :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated2d_backward_tttlllltta _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated2d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _columns), *$(at::Tensor* _ones), *$(std::array<bool,3>* _output_mask))); }|]

thnn_conv_dilated3d_ttltlllT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> IO (Ptr Tensor)
thnn_conv_dilated3d_ttltlllT _self _weight _kernel_size _bias _stride _padding _dilation _output = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_dilated3d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output))); }|]

thnn_conv_dilated3d_ttltlll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_conv_dilated3d_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_conv_dilated3d(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_dilated3d_forward_ttltlllTTT :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_forward_ttltlllTTT _self _weight _kernel_size _bias _stride _padding _dilation _output _columns _ones = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated3d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _output), *$(at::Tensor* _columns), *$(at::Tensor* _ones))); }|]

thnn_conv_dilated3d_forward_ttltlll :: Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_forward_ttltlll _self _weight _kernel_size _bias _stride _padding _dilation = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated3d_forward(*$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::Tensor* _bias), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation))); }|]

thnn_conv_dilated3d_backward_tttllllttTTT :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_backward_tttllllttTTT _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _grad_input _grad_weight _grad_bias = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _columns), *$(at::Tensor* _ones), *$(at::Tensor* _grad_input), *$(at::Tensor* _grad_weight), *$(at::Tensor* _grad_bias))); }|]

thnn_conv_dilated3d_backward_tttlllltta :: Ptr Tensor -> Ptr Tensor -> Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr Tensor -> Ptr Tensor -> Ptr (StdArray CBool 3) -> IO (Ptr (Tensor,Tensor,Tensor))
thnn_conv_dilated3d_backward_tttlllltta _grad_output _self _weight _kernel_size _stride _padding _dilation _columns _ones _output_mask = [C.block| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::native::thnn_conv_dilated3d_backward(*$(at::Tensor* _grad_output), *$(at::Tensor* _self), *$(at::Tensor* _weight), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _stride), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _dilation), *$(at::Tensor* _columns), *$(at::Tensor* _ones), *$(std::array<bool,3>* _output_mask))); }|]

thnn_col2im_tlllll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_col2im_tlllll _self _output_size _kernel_size _dilation _padding _stride = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_col2im(*$(at::Tensor* _self), *$(at::IntArrayRef* _output_size), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _dilation), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride))); }|]

thnn_col2im_backward_tllll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_col2im_backward_tllll _grad_output _kernel_size _dilation _padding _stride = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_col2im_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _dilation), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride))); }|]

thnn_im2col_tllll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_im2col_tllll _self _kernel_size _dilation _padding _stride = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_im2col(*$(at::Tensor* _self), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _dilation), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride))); }|]

thnn_im2col_backward_tlllll :: Ptr Tensor -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> Ptr IntList -> IO (Ptr Tensor)
thnn_im2col_backward_tlllll _grad_output _input_size _kernel_size _dilation _padding _stride = [C.block| at::Tensor* { return new at::Tensor(at::native::thnn_im2col_backward(*$(at::Tensor* _grad_output), *$(at::IntArrayRef* _input_size), *$(at::IntArrayRef* _kernel_size), *$(at::IntArrayRef* _dilation), *$(at::IntArrayRef* _padding), *$(at::IntArrayRef* _stride))); }|]


