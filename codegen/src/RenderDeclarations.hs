{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}
module RenderDeclarations where

import Data.Yaml (ParseException)
import qualified Data.Yaml as Y
import Text.Shakespeare.Text (st)
import Data.Text (Text, replace)
import qualified Data.Text.IO as T
import System.Directory (createDirectoryIfMissing)

import qualified ParseDeclarations as D
import ParseFunctionSig as P
import RenderCommon

dropGenerator :: [Parameter] -> [Parameter]
dropGenerator params = filter (\v' -> ptype v' /= Ptr GeneratorType) params

toFunction :: D.Declaration -> P.Function
toFunction dl = P.Function
  { P.name = D.name dl
  , P.parameters = map (\a -> P.Parameter (D.type2type a) (D.name' a) Nothing) $ D.arguments dl
  , P.retType = case D.returns dl of
      [a] -> D.type2type a
      ax -> P.Tuple $ map D.type2type ax
  }

renderFunctions :: Bool -> Bool -> String -> [D.Declaration] -> Text
renderFunctions is_managed enb_type_initials namespace nfs = mconcat $ flip map nfs $ \nf -> functionToCpp is_managed enb_type_initials namespace "" (toFunction nf)

decodeAndCodeGen :: String -> String -> IO ()
decodeAndCodeGen basedir fileName = do
  funcs <- Y.decodeFileEither fileName :: IO (Either ParseException [D.Declaration])
  case funcs of
    Left err' -> print err'
    Right fns -> do
      createDirectoryIfMissing True (basedir <> "/Aten")
      T.writeFile (basedir <> "/Aten/Type.hs") $
        typeTemplate
      T.writeFile (basedir <> "/Aten/Managed/NN.hs") $
        template True "Aten.Managed.NN" (renderFunctions True False "at::" (filter (\a -> D.mode a == D.NN) fns))
      T.writeFile (basedir <> "/Aten/Managed/TH.hs") $
        template True "Aten.Managed.TH" (renderFunctions True True "at::" (filter (\a -> D.mode a == D.TH) fns))
      T.writeFile (basedir <> "/Aten/Managed/Native.hs") $
        template True "Aten.Managed.Native" $
        renderFunctions True True "at::" (filter (\a -> D.mode a == D.Native && "namespace" `elem` (D.method_of a)) fns)
      T.writeFile (basedir <> "/Aten/Unmanaged/NN.hs") $
        template False "Aten.Unmanaged.NN" (renderFunctions False False "at::" (filter (\a -> D.mode a == D.NN) fns))
      T.writeFile (basedir <> "/Aten/Unmanaged/TH.hs") $
        template False "Aten.Unmanaged.TH" (renderFunctions False True "at::" (filter (\a -> D.mode a == D.TH) fns))
      T.writeFile (basedir <> "/Aten/Unmanaged/Native.hs") $
        template False "Aten.Unmanaged.Native" $
        renderFunctions False True "at::" (filter (\a -> D.mode a == D.Native && "namespace" `elem` (D.method_of a)) fns)

renderImport :: Bool -> Text-> Text
renderImport is_managed module_name =  if is_managed then  [st|
import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.Type
import Aten.Class
import Aten.Cast
import qualified #{replace "Managed" "Unmanaged" module_name} as Unmanaged
import Aten.Unmanaged.Type.Generator
import Aten.Unmanaged.Type.IntArray
import Aten.Unmanaged.Type.Scalar
import Aten.Unmanaged.Type.SparseTensorRef
import Aten.Unmanaged.Type.Storage
import Aten.Unmanaged.Type.Tensor
import Aten.Unmanaged.Type.TensorList
import Aten.Unmanaged.Type.TensorOptions
import Aten.Unmanaged.Type.Tuple
import Aten.Unmanaged.Type.StdString
import Aten.Unmanaged.Type.StdArray
|] else [st|
import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.Type
import Aten.Class

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"
C.include "<vector>"
|]

template :: Bool -> Text -> Text -> Text
template is_managed module_name functions = [st|
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module #{module_name} where

#{renderImport is_managed module_name}
#{functions}
|]

typeTemplate :: Text
typeTemplate = [st|
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Aten.Type where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign

type ScalarType = Int8
type DeviceType = Int16

data Tensor
data Scalar
data TensorOptions
data TensorList
data IntArrayRef
data IntArray
data TensorAVector
data SparseTensorRef
data Storage
data StdArray a b
data StdString
data Generator
data Device

typeTable = Map.fromList [
        (C.TypeName "at::Scalar", #{bra}t|Scalar|#{cket})
      , (C.TypeName "at::Tensor", #{bra}t|Tensor|#{cket})
      , (C.TypeName "at::TensorOptions", #{bra}t|TensorOptions|#{cket})
      , (C.TypeName "at::TensorList", #{bra}t|TensorList|#{cket})
      , (C.TypeName "at::IntArrayRef", #{bra}t|IntArrayRef|#{cket})
      , (C.TypeName "std::vector<int64_t>", #{bra}t|IntArray|#{cket})
      , (C.TypeName "at::ScalarType", #{bra}t|ScalarType|#{cket})
      , (C.TypeName "at::DeviceType", #{bra}t|DeviceType|#{cket})
      , (C.TypeName "at::SparseTensorRef", #{bra}t|SparseTensorRef|#{cket})
      , (C.TypeName "at::Storage", #{bra}t|Storage|#{cket})
      , (C.TypeName "at::Device", #{bra}t|Device|#{cket})
      , (C.TypeName "at::Generator", #{bra}t|Generator|#{cket})
      , (C.TypeName "std::string", #{bra}t|StdString|#{cket})
      , (C.TypeName "std::array<bool,2>", #{bra}t|StdArray CBool 2|#{cket})
      , (C.TypeName "std::array<bool,3>", #{bra}t|StdArray CBool 3|#{cket})
      , (C.TypeName "std::array<bool,4>", #{bra}t|StdArray CBool 4|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor>", #{bra}t|(Tensor,Tensor)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor>", #{bra}t|(Tensor,Tensor,Tensor)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>", #{bra}t|(Tensor,Tensor,Tensor,Tensor)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>", #{bra}t|(Tensor,Tensor,Tensor,Tensor,Tensor)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::TensorList>", #{bra}t|(Tensor,Tensor,Tensor,TensorList)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,double,int64_t>", #{bra}t|(Tensor,Tensor,CDouble,Int64)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,float,int>", #{bra}t|(Tensor,Tensor,CFloat,CInt)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,int64_t>", #{bra}t|(Tensor,Tensor,Tensor,Int64)|#{cket})
      , (C.TypeName "std::vector<at::Tensor>", #{bra}t|TensorAVector|#{cket})
    ]
|]
