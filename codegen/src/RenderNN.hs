{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}
module RenderNN where

import Data.Yaml (ParseException)
import qualified Data.Yaml as Y
import Text.Shakespeare.Text (st)
import Data.Text (Text)
import qualified Data.Text.IO as T

import qualified ParseNN as NN
import ParseFunctionSig as P
import RenderCommon

dropGenerator :: [Parameter] -> [Parameter]
dropGenerator params = filter (\v' -> ptype v' /= Ptr GeneratorType) params

mkBackwardAndForward :: NN.NN' -> [P.Function]
mkBackwardAndForward nn = [nn_forward, nn_forward_out, nn_backward, nn_backward_out]
  where
    fn = NN.func' nn
    params = parameters fn
--    has_target = or $ map (\v -> pname v == "target") params
    nn_forward = fn {
      name = (name fn) ++ "_forward"
      }
    nn_forward_out = fn {
      name = (name fn) ++ "_forward_out"
      , parameters = [tensor_param] ++ buffer_param ++ params
      }
    nn_backward = fn {
      name = (name fn) ++ "_backward"
      , parameters = dropGenerator $ [grad_output] ++ params ++ buffer_param
      , retType = TenType Tensor
      }
    nn_backward_out = fn {
      name = (name fn) ++ "_backward_out"
      , parameters = dropGenerator $ [grad_input, grad_output] ++ params ++ buffer_param
      , retType = TenType Tensor
      }
    tensor_param = Parameter
      (TenType Tensor)
      "output"
      Nothing
    grad_input = Parameter
      (TenType Tensor)
      "grad_input"
      Nothing
    grad_output = Parameter
      (TenType Tensor)
      "grad_output"
      Nothing
    buffer_param =
      case (NN.buffers' nn) of
        Nothing -> []
        Just b -> map (\n -> Parameter (TenType Tensor) n Nothing) b

renderFunctions :: [NN.NN'] -> Text
renderFunctions nfs = mconcat $ concat $ flip map nfs $ \nf -> map (functionToCpp False "at::") (mkBackwardAndForward nf)

decodeAndCodeGen :: String -> String -> IO ()
decodeAndCodeGen basedir fileName = do
  funcs <- Y.decodeFileEither fileName :: IO (Either ParseException [NN.NN'])
  case funcs of
    Left err' -> print err'
    Right fns -> do
      T.writeFile (basedir <> "/Aten/NN.hs") [st|
-- generated by using spec/nn.yaml and deps/libtorch/include/ATen/Functions.h

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Aten.NN where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign

import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.NativeFunctions.Type

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"

#{renderFunctions fns}
|]
