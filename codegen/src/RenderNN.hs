{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}
module RenderNN where

import Data.Yaml

import qualified Data.Yaml as Y
import Text.Shakespeare.Text (st,sbt)
import Data.Char (toLower)
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as T
import qualified Data.List as L

import qualified ParseNN as NN
import ParseFunctionSig as P
import RenderCommon

mkBackwardAndForward :: NN.NN' -> [P.Function]
mkBackwardAndForward nn = [nn_forward, nn_forward_out, nn_backward, nn_backward_out]
  where
    fn = NN.func' nn
    params = parameters fn
    nn_forward = fn {
      name = (name fn) ++ "_forward"
      }
    nn_forward_out = fn {
      name = (name fn) ++ "_forward_out"
      , parameters = [tensor_param] ++ buffer_param ++ params
      }
    nn_backward = fn {
      name = (name fn) ++ "_backward"
      , parameters = [grad_output] ++ params ++ buffer_param
      , retType = TenType Tensor
      }
    nn_backward_out = fn {
      name = (name fn) ++ "_backward_out"
      , parameters = [grad_input, grad_output] ++ params ++ buffer_param
      , retType = TenType Tensor
      }
    tensor_param = Parameter
      (TenType Tensor)
      "output"
      Nothing
    grad_input = Parameter
      (TenType Tensor)
      "grad_input"
      Nothing
    grad_output = Parameter
      (TenType Tensor)
      "grad_output"
      Nothing
    buffer_param =
      case (NN.buffers' nn) of
        Nothing -> []
        Just b -> map (\n -> Parameter (TenType Tensor) n Nothing) b

renderFunctions :: [NN.NN'] -> Text
renderFunctions nfs = mconcat $ concat $ flip map nfs $ \nf -> map (functionToCpp False "at::") (mkBackwardAndForward nf)

decodeAndCodeGen :: String -> IO ()
decodeAndCodeGen fileName = do
  funcs <- Y.decodeFileEither fileName :: IO (Either ParseException [NN.NN'])
  case funcs of
    Left err' -> print err'
    Right fns -> do
      T.writeFile "ffi/NN.hs" [st|
-- generated by using spec/nn.yaml and deps/libtorch/include/ATen/Functions.h

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module NN where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign

data Scalar
data Tensor
data TensorOptions
data TensorList
data IndexTensor
data IntList
data StdArray a b
data ScalarType
data SparseTensorRef

data StdString
data Generator
data Device
data Storage

C.context $ C.cppCtx <> mempty {
    C.ctxTypesTable = Map.fromList [
        (C.TypeName "at::Scalar", #{bra}t|Scalar|#{cket})
      , (C.TypeName "at::Tensor", #{bra}t|Tensor|#{cket})
      , (C.TypeName "at::TensorOptions", #{bra}t|TensorOptions|#{cket})
      , (C.TypeName "at::TensorList", #{bra}t|TensorList|#{cket})
      , (C.TypeName "at::IndexTensor", #{bra}t|IndexTensor|#{cket})
      , (C.TypeName "at::IntArrayRef", #{bra}t|IntList|#{cket})
      , (C.TypeName "at::ScalarType", #{bra}t|ScalarType|#{cket})
      , (C.TypeName "at::SparseTensorRef", #{bra}t|SparseTensorRef|#{cket})
      , (C.TypeName "at::Storage", #{bra}t|Storage|#{cket})
      , (C.TypeName "at::Device", #{bra}t|Device|#{cket})
      , (C.TypeName "at::Generator", #{bra}t|Generator|#{cket})
      , (C.TypeName "std::string", #{bra}t|StdString|#{cket})
      , (C.TypeName "std::array<bool,2>", #{bra}t|StdArray CBool 2|#{cket})
      , (C.TypeName "std::array<bool,3>", #{bra}t|StdArray CBool 3|#{cket})
      , (C.TypeName "std::array<bool,4>", #{bra}t|StdArray CBool 4|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor>", #{bra}t|(Tensor,Tensor)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor>", #{bra}t|(Tensor,Tensor,Tensor)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor>", #{bra}t|(Tensor,Tensor,Tensor,Tensor)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::Tensor,at::Tensor>", #{bra}t|(Tensor,Tensor,Tensor,Tensor,Tensor)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,at::Tensor,at::TensorList>", #{bra}t|(Tensor,Tensor,Tensor,TensorList)|#{cket})
      , (C.TypeName "std::tuple<at::Tensor,at::Tensor,double,int64_t>", #{bra}t|(Tensor,Tensor,CDouble,Int64)|#{cket})
    ]
}

C.include "<ATen/ATen.h>"

#{renderFunctions fns}
|]
