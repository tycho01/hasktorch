{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}
module RenderTuples where

import Data.Yaml (ParseException)
import qualified Data.Yaml as Y
import Text.Shakespeare.Text (st)
import Data.Text (Text)
import qualified Data.Text.IO as T
import qualified Data.Text as T
import System.Directory (createDirectoryIfMissing)

import qualified ParseTuples as PT
import ParseFunctionSig as P
import RenderCommon


tupleToCpp :: PT.Tuple -> Text
tupleToCpp (PT.Tuple parsables) = [st|std::tuple<#{T.intercalate "," (map parsableToCppType parsables)}>|]

tupleToHs :: PT.Tuple -> Text
tupleToHs (PT.Tuple parsables) = [st|(#{T.intercalate "," (map parsableToHsType parsables)})|]

toHs :: P.Parsable -> Text
toHs typ =
  if isCType typ
  then [st|#{parsableToHsType typ}|]
  else [st|Ptr #{parsableToHsType typ}|]

toCpp :: P.Parsable -> Text
toCpp typ =
  if isCType typ
  then [st|#{parsableToCppType typ}|]
  else [st|#{parsableToCppType typ}*|]

toCpp' :: P.Parsable -> Text
toCpp' typ =
  if isCType typ
  then [st||]
  else [st|new #{parsableToCppType typ}|]

renderCppObject :: PT.Tuple -> Text
renderCppObject typ = [st|

-----------------#{tupleToHs typ}---------------------

instance CppObject #{tupleToHs typ} where
  fromPtr ptr = newForeignPtr ptr #{bra}C.block| void { delete $(#{tupleToCpp typ}* ptr); return; }|#{cket}
|]

renderCppTuple2 :: PT.Tuple -> Text
renderCppTuple2 typ@(PT.Tuple (a:b:_)) = [st|
instance CppTuple2 (Ptr #{tupleToHs typ}) where
  type A (Ptr #{tupleToHs typ}) = #{toHs a}
  type B (Ptr #{tupleToHs typ}) = #{toHs b}
  get0 v = #{bra}C.block| #{toCpp a} { return #{toCpp' a}(std::get<0>(*$(#{tupleToCpp typ}* v)));}|#{cket}
  get1 v = #{bra}C.block| #{toCpp b} { return #{toCpp' b}(std::get<1>(*$(#{tupleToCpp typ}* v)));}|#{cket}
|]
renderCppTuple2 _ = ""

renderCppTuple3 :: PT.Tuple -> Text
renderCppTuple3 typ@(PT.Tuple (_:_:c:_)) = [st|
instance CppTuple3 (Ptr #{tupleToHs typ}) where
  type C (Ptr #{tupleToHs typ}) = #{toHs c}
  get2 v = #{bra}C.block| #{toCpp c} { return #{toCpp' c}(std::get<2>(*$(#{tupleToCpp typ}* v)));}|#{cket}
|]
renderCppTuple3 _ = ""

renderCppTuple4 :: PT.Tuple -> Text
renderCppTuple4 typ@(PT.Tuple (_:_:_:d:_)) = [st|
instance CppTuple4 (Ptr #{tupleToHs typ}) where
  type D (Ptr #{tupleToHs typ}) = #{toHs d}
  get3 v = #{bra}C.block| #{toCpp d} { return #{toCpp' d}(std::get<3>(*$(#{tupleToCpp typ}* v)));}|#{cket}
|]
renderCppTuple4 _ = ""


renderCppTuple5 :: PT.Tuple -> Text
renderCppTuple5 typ@(PT.Tuple (_:_:_:_:e:_)) = [st|
instance CppTuple5 (Ptr #{tupleToHs typ}) where
  type E (Ptr #{tupleToHs typ}) = #{toHs e}
  get4 v = #{bra}C.block| #{toCpp e} { return #{toCpp' e}(std::get<4>(*$(#{tupleToCpp typ}* v)));}|#{cket}
|]
renderCppTuple5 _ = ""


renderTuples :: [PT.Tuple] -> Text
renderTuples [] = ""
renderTuples (x:xs) =
  renderCppObject x <>
  renderCppTuple2 x <>
  renderCppTuple3 x <>
  renderCppTuple4 x <>
  renderCppTuple5 x <>
  renderTuples xs

decodeAndCodeGen :: String -> String -> IO ()
decodeAndCodeGen basedir fileName = do
  funcs <- Y.decodeFileEither fileName :: IO (Either ParseException [PT.Tuple])
  case funcs of
    Left err' -> print err'
    Right fns -> do
      createDirectoryIfMissing True (basedir <> "/Aten/Type")
      T.writeFile (basedir <> "/Aten/Type/Tuple.hs") $
        template "Aten.Type.Tuple" fns


template :: Text -> [PT.Tuple] -> Text
template module_name types = [st|
-- generated by using spec/tuples.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleInstances #-}

module #{module_name} where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map
import Foreign.C.String
import Foreign.C.Types
import Foreign hiding (newForeignPtr)
import Foreign.Concurrent
import Aten.Type
import Aten.Class

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"

#{renderTuples types}
|]

