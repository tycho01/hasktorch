{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}
module RenderPure where

import Data.Yaml (ParseException)
import qualified Data.Yaml as Y
import Text.Shakespeare.Text (st)
import Data.Text (Text, replace)
import Data.List (isPrefixOf, isSuffixOf, sort)
import qualified Data.Text.IO as T
import System.Directory (createDirectoryIfMissing)

import qualified ParseDeclarations as D
import ParseFunctionSig as P
import RenderCommon

data BindingName
  = HsName String
  | CppName String
  deriving (Show, Eq, Generic)

data Binding
  = BindRename { src :: BindingName, hsName :: String }
  | Bind       { src :: BindingName }
  | BindRemove { src :: BindingName }
  deriving (Show, Eq, Generic)

instance FromJSON BindingName
instance FromJSON Binding


toFunction :: D.Declaration -> P.Function
toFunction dl = P.Function
  { P.name = D.name dl
  , P.parameters = map (\a -> P.Parameter (D.type2type a) (D.name' a) Nothing) $ D.arguments dl
  , P.retType = case D.returns dl of
      [a] -> D.type2type a
      ax -> P.Tuple $ map D.type2type ax
  , P.variant = P.VFunction
  }

renderFunctions :: [D.Declaration] -> Text
renderFunctions nfs = mconcat $ flip map nfs $ \nf -> pureFunction True (toFunction nf)

nativeFunctionsFilter :: [D.Declaration] -> [D.Declaration]
nativeFunctionsFilter fns =
  filter (\a ->
            D.mode a == D.Native &&
            "namespace" `elem` (D.method_of a) &&
            D.is_factory_method a == Nothing &&
            not (isPrefixOf "_" (D.name a)) &&
            not (isSuffixOf "_" (D.name a)) &&
            not (isSuffixOf "_out" (D.name a)) &&
            all (/= P.Ptr P.GeneratorType) (map D.dynamic_type' (D.arguments a)) &&
            not ((D.name a) `elem` notUniqList)
--            map D.dynamic_type' (D.returns a) == [P.TenType P.Tensor]
         ) fns
  where
    notUniqList :: [String]
    notUniqList = notUniq (sort $ map D.name fns) []
    notUniq [] a = a
    notUniq (x:y:xs) ys = if x == y then notUniq xs (y:ys) else (notUniq (y:xs) ys)
    notUniq a b = b

decodeAndCodeGen :: String -> String -> IO ()
decodeAndCodeGen basedir yamlSpecFileName bindingsFileName = do
  funcs <- Y.decodeFileEither yamlSpecFileName :: IO (Either ParseException [D.Declaration])
  bindings <- Y.decodeFileEither bindingsFileName :: IO (Either ParseException [Bindings])
  case funcs of
    Left err' -> print err'
    Right fns -> do
      createDirectoryIfMissing True (basedir <> "/Torch/Pure")
      T.writeFile (basedir <> "/ATen/Pure/Native.hs") $
        template "ATen.Pure.Native" $
        renderFunctions $ nativeFunctionsFilter fns

renderImport :: Text -> Text
renderImport module_name = [st|
import Foreign.C.String
import Foreign.C.Types
import Foreign
import ATen.Type
import ATen.Class
import ATen.Cast
import ATen.Managed.Native
import ATen.Managed.Type.Generator
import ATen.Managed.Type.IntArray
import ATen.Managed.Type.Scalar
import ATen.Managed.Type.SparseTensorRef
import ATen.Managed.Type.Storage
import ATen.Managed.Type.Tensor
import ATen.Managed.Type.TensorList
import ATen.Managed.Type.TensorOptions
import ATen.Managed.Type.Tuple
import ATen.Managed.Type.StdString
import ATen.Managed.Type.StdArray
|]

template :: Text -> Text -> Text
template module_name functions = [st|
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module #{module_name} where

#{renderImport module_name}
#{functions}
|]
